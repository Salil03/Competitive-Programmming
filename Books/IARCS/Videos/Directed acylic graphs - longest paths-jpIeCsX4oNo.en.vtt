WEBVTT
Kind: captions
Language: en

00:00:00.710 --> 00:00:05.170
Let us continue to look at DAGs and in this
section we will look at a different problem

00:00:05.170 --> 00:00:08.010
called identifying the Longest Path in a DAG.

00:00:08.010 --> 00:00:14.240
So, recall that a directed acyclic graph is
just a directed graph in which there is no

00:00:14.240 --> 00:00:20.779
directed path from any vertex back to itself,
so it is direct and it is acyclic.

00:00:20.779 --> 00:00:25.970
Any directed acyclic graph can be topologically
ordered. If you think of the vertices as being

00:00:25.970 --> 00:00:31.449
1 to n, you can write out 1 to n as a sequence
in such a way that for every pair j, k which

00:00:31.449 --> 00:00:36.710
is an edge if j, k is an edge in my graph,
then j will appear before k in the sequence.

00:00:36.710 --> 00:00:42.839
So, if you think of these as tasks with dependencies
means that I can do the task in such a way

00:00:42.839 --> 00:00:48.410
that before I do k, I would have finished
its dependence task j. So, this is called

00:00:48.410 --> 00:00:49.949
a topological sorting.

00:00:49.949 --> 00:00:57.520
So, let us look at a different question about
DAGs. So, supposing we have this DAG and we

00:00:57.520 --> 00:01:02.829
imagine that the vertices represent courses
and the edges are prerequisites. Now, these

00:01:02.829 --> 00:01:07.600
are courses that we have to do to may be complete
the degree, every course requires a semester,

00:01:07.600 --> 00:01:13.079
but we can do more than one course in a semester.
So, the question is, what is the minimum number

00:01:13.079 --> 00:01:18.090
of semesters that I need to complete this
program consisting of these 8 courses, with

00:01:18.090 --> 00:01:22.640
these prerequisites.
So, clearly I can start putting courses 1

00:01:22.640 --> 00:01:26.310
and 2 in the first semester, because they
have no prerequisites, so they can be done

00:01:26.310 --> 00:01:33.500
immediately. Now, having done 1 and 2 I can
do 3, because 3 has only depends on 1 and

00:01:33.500 --> 00:01:38.970
2. Similarly, I can do 4 and 5 because they
depend only on 1, now 8 depends on 1 and 2

00:01:38.970 --> 00:01:44.090
I need the material or at least depends on
2. I need to have done, 2 to do 8, but I still

00:01:44.090 --> 00:01:51.659
cannot do 8, because it also requires 5, 4
and 7. So, at this point the only courses

00:01:51.659 --> 00:01:56.469
which are available are 3, 4 and 5. So, in
my second semester I can do 3, 4 and 5.

00:01:56.469 --> 00:02:01.229
Now, the only course for which all prerequisites
are satisfied is 6, 7 requires 6 which has

00:02:01.229 --> 00:02:05.390
not been done and 8 requires 7 which has not
been done. So, in the third semester I am

00:02:05.390 --> 00:02:10.860
struck with doing only one course namely 6.
In the 4th semester, I can do 7 and finally,

00:02:10.860 --> 00:02:17.411
after 5 semesters I can complete these requirements.
So, in general we can ask this question, if

00:02:17.411 --> 00:02:21.840
I think of these as DAG as representing courses,
what is the minimum number of semesters.

00:02:21.840 --> 00:02:28.480
Now, this problem corresponds to asking for
the longest path in the DAG. What we are saying

00:02:28.480 --> 00:02:33.890
is that it takes 5 semesters to complete 8,
because there is a chain of dependencies,

00:02:33.890 --> 00:02:41.680
where 8 depends on 7, 7 depends on 6, 6 depends
on say 3 or 4 it does not matter which one

00:02:41.680 --> 00:02:47.371
we choose and 3 depends on 1 and this chain
forces us to spend 4 semesters, because it

00:02:47.371 --> 00:02:52.650
is a chain of length 4, 4 semesters before
I can do 8. Notice that it is not the shortest

00:02:52.650 --> 00:02:57.150
chain, because there are shorter chains for
example, 8 to 2 takes back to a vertex which

00:02:57.150 --> 00:03:01.170
has indegree 0, but this does not help us
because after 2 I cannot do 8. So, I must

00:03:01.170 --> 00:03:06.550
wait for everything that has to happen before
8 in order to get the job done. So, unlike

00:03:06.550 --> 00:03:10.100
other problems where we might be looking at
shortest paths, here we are actually interested

00:03:10.100 --> 00:03:16.040
in the longest path.
So, we can set up this problem as follows,

00:03:16.040 --> 00:03:21.010
so we can say that for any vertex which has
indegree 0, the longest path to that vertex

00:03:21.010 --> 00:03:26.610
is of length 0, because I can do it immediately.
And on the other hand, if I have a vertex

00:03:26.610 --> 00:03:35.410
whose indegree is not 0, then it has some
incoming edges. So, I have a vertex k, so

00:03:35.410 --> 00:03:40.530
I must wait for all of these to finish and
then do it. So, if I take all of these I have

00:03:40.530 --> 00:03:47.330
to take, among all of these I have to take
the maximum length, because that will be the

00:03:47.330 --> 00:03:52.810
last thing to finish and after that I have
to do plus 1 account for k. So, if indegree

00:03:52.810 --> 00:03:58.740
is not 0 then the longest path to k has length
1 plus the maximum of the longest path to

00:03:58.740 --> 00:04:01.970
all its incoming neighbours.

00:04:01.970 --> 00:04:08.710
So, therefore in order to compute the longest
path to k, I need to compute the longest path

00:04:08.710 --> 00:04:14.210
to all its incoming neighbours. Now, if we
have arranged the vertices in topological

00:04:14.210 --> 00:04:21.180
order and we compute the longest path in that
sequence, then when we get to k every incoming

00:04:21.180 --> 00:04:26.500
neighbour j will be on its left. Hence, we
would already computed its longest path, so

00:04:26.500 --> 00:04:30.990
we would be able to take the maximum number
of all of those and add 1.

00:04:30.990 --> 00:04:36.259
So, by sorting these vertices in topological
order, I can then compute the longest path

00:04:36.259 --> 00:04:39.949
in the same order with the guarantee that
when I want to compute the longest path to

00:04:39.949 --> 00:04:44.949
a given vertex, I have all the information
available need to do that namely all the longest

00:04:44.949 --> 00:04:49.169
paths for its incoming neighbours.

00:04:49.169 --> 00:05:02.689
So, if I do it naively then I will write out
my vertices in some topological order and

00:05:02.689 --> 00:05:06.969
now when I come to this vertex and I want
to compute its longest path, I will look at

00:05:06.969 --> 00:05:11.639
in my graph all the incoming edges and they
will all be from vertices which appear before.

00:05:11.639 --> 00:05:16.870
So, I can take the value here, the value here,
the value here and then take the maximum and

00:05:16.870 --> 00:05:22.020
then add 1. So, actually we will see that
you do not need to do this backward, you can

00:05:22.020 --> 00:05:24.830
actually do it forward.
So, we can actually incrementally compute

00:05:24.830 --> 00:05:29.430
the value at i k as you are going forwards.
Because, going backwards requires you to scan

00:05:29.430 --> 00:05:35.249
this list and look for all the incoming neighbours.
So, we will kind of implicitly do this longest

00:05:35.249 --> 00:05:41.169
path calculation along with topological sort
side by side, as we will see in the next example.

00:05:41.169 --> 00:05:48.900
So, here is an example in which we are going
to compute the longest path as we are computing

00:05:48.900 --> 00:05:55.090
the topological order. So, as before the red
numbers against the vertices are used for

00:05:55.090 --> 00:05:59.930
topological sort and they denote the indegrees.
So, the initial indegrees are given by the

00:05:59.930 --> 00:06:05.779
initial edges in our graph and what we do
is we compute the longest path incrementally

00:06:05.779 --> 00:06:10.360
by starting by assuming that the longest path
to every vertex is actually 0.

00:06:10.360 --> 00:06:17.569
Now, when we enumerate a vertex in topological
sort what we did earlier was to update the

00:06:17.569 --> 00:06:21.860
indegrees, so this is something that we already
did. But, now the additional thing that we

00:06:21.860 --> 00:06:28.800
do is we say that well if the vertex 1 had
to be enumerated before 3, 4 and 5, then among

00:06:28.800 --> 00:06:34.819
the values that I know for the incoming edges
of 3, 4 and 5, 0 was the maximum in length.

00:06:34.819 --> 00:06:40.330
So, I must do 1 plus that, so these paths
are at least of length 1. So, the longest

00:06:40.330 --> 00:06:43.270
path to 3, 4 and 5 is at least 1.

00:06:43.270 --> 00:06:51.620
Now, if I enumerate vertex 4, then its longest
path is at least 1, so therefore, the longest

00:06:51.620 --> 00:06:57.939
path to 6 must be at least 1 plus 1. Similarly,
the longest path to 8 must be at least 1 plus

00:06:57.939 --> 00:07:02.840
1 and of course, the indegrees will also reduce
as before. So, the indegree of 6 goes on to

00:07:02.840 --> 00:07:07.090
1, the indegree of 8 goes on to 3, but the
longest path to 6 is now the longest path

00:07:07.090 --> 00:07:15.580
to 4 plus 1, so it is 2, it is same for 8.
Now, supposing I enumerate the vertex 2, now

00:07:15.580 --> 00:07:21.020
2 will again say that the longest path, because
of 2 the longest path to 3 is 1, but it is

00:07:21.020 --> 00:07:24.801
already 1, so we do not change it.
This will say because of 2 the longest path

00:07:24.801 --> 00:07:30.300
to 8 is at least 1, but we know it is at least
2, so again we do not change. So, when we

00:07:30.300 --> 00:07:34.860
delete a node, then we take basically the
current value of the longest path for its

00:07:34.860 --> 00:07:40.259
outgoing thing plus 1, the current value of
the deleted node plus 1 and what is already

00:07:40.259 --> 00:07:45.939
known about that node and we keep the maximum.
So, in this case this 1 will become 0, this

00:07:45.939 --> 00:07:52.620
3 will become 2, but here there is no change
and here there is no change.

00:07:52.620 --> 00:07:59.110
Now likewise when I remove this 5, this 2
will become 1, but because 1 plus 1 is 2 and

00:07:59.110 --> 00:08:04.610
we already know that 8 has a longest path
of at least 2, we do not make any change in

00:08:04.610 --> 00:08:05.650
the 2.

00:08:05.650 --> 00:08:14.050
Now, when we go to 3, 3 says it has a longest
path of 1, so therefore because of 3 the longest

00:08:14.050 --> 00:08:17.979
path of 6 at least 2, but we already know
it is 2, so again there is no change.

00:08:17.979 --> 00:08:23.749
Now, we shall do something interesting, so
we say that 6 has a longest path of 2, 7 we

00:08:23.749 --> 00:08:27.669
so far have believed it has longest path of
0, but through 6 it has a longer path. So,

00:08:27.669 --> 00:08:35.940
the path to 7 must now be updated from 0 to
3.

00:08:35.940 --> 00:08:42.680
And now because of this, when we go from 7
to 8, the longest path for 8 must be updated

00:08:42.680 --> 00:08:46.490
from 2 to 4.

00:08:46.490 --> 00:08:51.770
And now finally, this is my last vertex, so
I just enumerate it and I compute its longest

00:08:51.770 --> 00:08:52.770
path as 4.

00:08:52.770 --> 00:08:56.340
So, what this has said is the longest path
is 4, now we said that it will be done in

00:08:56.340 --> 00:09:00.280
5 semesters, this same example which basically
means that in the first semester all those

00:09:00.280 --> 00:09:04.380
whose longest path is 0, in the second semester
all those whose longest path is 1 and so we

00:09:04.380 --> 00:09:09.340
have the same sequence you had before. So,
we initially do 1 and 2 in the first semester,

00:09:09.340 --> 00:09:15.330
then we do 3, 4 and 5 in the second semester,
then we do 6 in the third semester, 7 in the

00:09:15.330 --> 00:09:18.960
fourth semester and 8 in the fifth semester.
So, this is the exactly the solution that

00:09:18.960 --> 00:09:22.710
we obtained informally on our initial example.

00:09:22.710 --> 00:09:28.580
So, the pseudo code for longest path as we
saw is very similar to what we did for the

00:09:28.580 --> 00:09:32.990
topological sort, we just have keep track
of this extra longest path value. So, when

00:09:32.990 --> 00:09:38.950
we initialize the indegree we also initialize
the longest path to i to be 0 for every vertex.

00:09:38.950 --> 00:09:44.630
So, this we are doing again for the adjacency
matrix version. So, we do n squared work for

00:09:44.630 --> 00:09:50.580
each vertex, we compute the indegree by looking
at the column of the adjacency matrix with

00:09:50.580 --> 00:09:55.420
entry, column entry i.
But, we also update, we initialize longest

00:09:55.420 --> 00:10:02.170
path to each i as 0, now when we are doing
this enumeration as before we choose any vertex

00:10:02.170 --> 00:10:06.690
with indegree 0, we enumerate it and we update
the indegree of this vertex to minus 1. So,

00:10:06.690 --> 00:10:12.340
it is no long were in contention for being
chosen again. Now, for all its out going neighbours,

00:10:12.340 --> 00:10:15.740
we update the indegree and we also update
the longest path.

00:10:15.740 --> 00:10:20.510
So, we take the longest path that we already
know to that neighbour, the LPT of k and we

00:10:20.510 --> 00:10:25.710
take 1 plus the longest path for this node
and whichever is larger we replace that back

00:10:25.710 --> 00:10:31.090
in LPT of k. So, it is a very simple variation
of the basic topological ordering thing which

00:10:31.090 --> 00:10:34.250
allows us also to compute the longest path.

00:10:34.250 --> 00:10:42.330
So, this has complexity order n squared for
the same reason that we had found that topological

00:10:42.330 --> 00:10:46.780
short with adjacency matrix is order n squared.
Because, we have these nested loops in order

00:10:46.780 --> 00:10:52.420
to scan all the neighbours, so as before we
can update this whole thing using adjacency

00:10:52.420 --> 00:10:55.720
list and a queue to make it a linear then
algorithm.

00:10:55.720 --> 00:11:01.790
So, if you go back and look at the topological
ordering algorithm, you will find that the

00:11:01.790 --> 00:11:07.300
same changes are required to make a... additional
compute the longest path. So, what we do is

00:11:07.300 --> 00:11:11.070
initializing is again the same we do it for
every vertex. So, this is an order n step,

00:11:11.070 --> 00:11:17.290
we initialize both the indegree and the longest
path. Then we go through all the adjacency

00:11:17.290 --> 00:11:22.350
lists and together this is an order m step
to compute the initial indegrees.

00:11:22.350 --> 00:11:28.620
And now we have an order n step in order to
setup this queue, where we will process the

00:11:28.620 --> 00:11:36.410
topological ordering. And then, we do an outer
loop of order n, so this is an order n loop,

00:11:36.410 --> 00:11:39.760
because everything is going to go into the
queue once and come out. So, we are going

00:11:39.760 --> 00:11:47.260
to remove from the queue n times and now because
we are scanning the list across all the n

00:11:47.260 --> 00:11:51.790
iterations we are going to process each edge
once. So, the total work done in this loop

00:11:51.790 --> 00:11:57.380
is going to be order n.
So, we do exactly as before we update the

00:11:57.380 --> 00:12:03.500
indegree, we update the longest path to k
as maximum of the current value and 1 plus

00:12:03.500 --> 00:12:09.760
the value of the current node and if we do
find that the k has now become a vertex with

00:12:09.760 --> 00:12:15.010
indegree 0 we added to the queue.

00:12:15.010 --> 00:12:20.320
So, DAGs are very useful because there many
situations, where we want to model dependencies

00:12:20.320 --> 00:12:28.250
between various objects. And topological ordering
is a canonical algorithm to list out vertices

00:12:28.250 --> 00:12:35.230
without violating dependencies, what we are
seen today is that, we can compute the longest

00:12:35.230 --> 00:12:41.850
path in a DAG and longest path in a DAG in
some sense if we can list out vertices in

00:12:41.850 --> 00:12:46.840
groups, longest path in a DAG represents the
minimum number of steps in order to enumerate

00:12:46.840 --> 00:12:49.821
all the vertices.
So, if we going to do courses in groups, then

00:12:49.821 --> 00:12:54.560
if you want to bunch it and do things which
are at the same level at one time, then the

00:12:54.560 --> 00:12:58.790
minimum number of steps we need, minimum of
semesters to complete set of courses or the

00:12:58.790 --> 00:13:05.140
minimum number of days to complete a set of
tasks is given by the longest path. Now, it

00:13:05.140 --> 00:13:10.240
is important that we have been able to find
an efficient linear time algorithm for longest

00:13:10.240 --> 00:13:13.180
path only because we restricted our attention
to DAGs.

00:13:13.180 --> 00:13:18.990
If we look at arbitrary graphs which are not
necessarily DAGs and we want to find longest

00:13:18.990 --> 00:13:22.550
paths of course, if we have loops there the
longest path will be undefined, because the

00:13:22.550 --> 00:13:27.310
can go round and round the loop. So, if we
define a longest path to be one in which we

00:13:27.310 --> 00:13:33.990
have a sequence of vertices with no duplicates.
So, the length is at most n, then in an arbitrary

00:13:33.990 --> 00:13:37.460
graph this is a very challenging problem and
there is no known efficient algorithm. In

00:13:37.460 --> 00:13:41.600
fact, it is part of a group of highly intractable
problems which are all equivalent to each

00:13:41.600 --> 00:13:47.790
other and all are believed to be very hard.
So, DAGs are a very significant subclass of

00:13:47.790 --> 00:13:52.600
graphs which have many practical applications
and which admit efficient solutions for very

00:13:52.600 --> 00:13:57.350
important problems, which are not in general
solvable easily and on the full class of graphs.

