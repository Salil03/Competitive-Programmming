WEBVTT
Kind: captions
Language: en

00:00:01.180 --> 00:00:06.710
In the bandwidth allocation problem, we use
one variable per path in order to encode a

00:00:06.710 --> 00:00:10.680
network flow problem as a linear program and
we argued that that’s not an efficient way

00:00:10.680 --> 00:00:14.710
to do it. So, let us look at a mode direct
way to represent network flows in terms of

00:00:14.710 --> 00:00:16.640
linear programs.

00:00:16.640 --> 00:00:22.950
So, suppose we have an oil network which is
shown as given in this directed graph. So,

00:00:22.950 --> 00:00:32.570
we have a source vertex s and we have a target
or a sink vertex t and our aim is to ship

00:00:32.570 --> 00:00:40.280
as much oil as we can from s to t given the
pipes that we are given. So, of course, one

00:00:40.280 --> 00:00:45.760
property of a flow is that it is must flow,
so I cannot keep any quantity at any intermediate

00:00:45.760 --> 00:00:50.500
node. So, anything that enters b must leave
b, anything that enters d must leave d.

00:00:50.500 --> 00:00:56.829
So, if we try to do this, then for instance
this green quantity represents one possible

00:00:56.829 --> 00:01:03.100
flow, I send 2 units from s to a 1 from s
to b 4 from s to c and you can check that

00:01:03.100 --> 00:01:08.100
these are infact within the capacity. I could
have sent 3, 3 and 4 and have set 2, 1 and

00:01:08.100 --> 00:01:13.729
4 and I keep on going. And therefore, now
at this particular thing I have a total of

00:01:13.729 --> 00:01:19.310
7 units which flows out of s and 7 units which
comes into t. So, I am able to flow 7 units

00:01:19.310 --> 00:01:25.220
from s to t given this network.
So, we can just verify this locally that this

00:01:25.220 --> 00:01:29.320
is a flow by check instance at d, the total
quantity flowing in 2 plus 1, 3 if nothing

00:01:29.320 --> 00:01:34.280
is stored because the total quantity flowing
out is again 2 plus 1, 3. So, if we can do

00:01:34.280 --> 00:01:38.220
local checks like this, we can satisfy our
self that this is a valid flow, the total

00:01:38.220 --> 00:01:42.100
amount is 7. But, the question is, is this
the maximum? How do we know that we achieve

00:01:42.100 --> 00:01:44.610
the maximum or not?

00:01:44.610 --> 00:01:53.310
So, the problem just to face it formally is
that we have given a special type of graph,

00:01:53.310 --> 00:02:01.649
it is a directed graph and it has two special
nodes, a source and a sink. The source has

00:02:01.649 --> 00:02:08.560
no incoming edges and the sink has no outgoing
edges. Each edge has a capacity, which is

00:02:08.560 --> 00:02:13.569
a weight associated with the edge and our
aims to come up with the flow, the flow is

00:02:13.569 --> 00:02:18.409
again the quantity that we will assign each
edge. And now the flow must satisfy some basic

00:02:18.409 --> 00:02:23.519
conditions, the flow must always be less than
the capacity, then we have no storage.

00:02:23.519 --> 00:02:28.230
So, at every internal node the total amount
flowing into the node must be equal to the

00:02:28.230 --> 00:02:36.629
total amount flowing out. So, this is called
conservation of flow. We cannot lose anything

00:02:36.629 --> 00:02:41.680
or generate anything at an intermediate node,
anything that comes in must go out. And finally,

00:02:41.680 --> 00:02:45.959
what we want to do is we want to optimize
the total volume of flow, the total volume

00:02:45.959 --> 00:02:49.819
of flow is the amount of flow which is coming
out of here which is also of course, the amount

00:02:49.819 --> 00:02:53.449
of flow which is going there because no flow
can be lost. So, we can look at either end,

00:02:53.449 --> 00:03:00.719
but lets just define it, to be the total volume
of the outgoing flow from the source.

00:03:00.719 --> 00:03:08.480
So, now we have this formulation in mind,
so we can now set up a linear program for

00:03:08.480 --> 00:03:13.069
it, what we associate it do is that we associate
as we said one, variable for each edge. So,

00:03:13.069 --> 00:03:20.169
for instance for the edge s a we have f s
a and then for the edge b d for example, we

00:03:20.169 --> 00:03:30.049
have f b d and then for c e, we have f c e
and so on. So, we have 1, 2, 3, 4, 5, 6, 7,

00:03:30.049 --> 00:03:36.379
8, 9, 10, 11, I believe, edges the 11 edges
and therefore, we have 11 variables in this

00:03:36.379 --> 00:03:39.860
linear program.
Now, what can we do in this variables, one

00:03:39.860 --> 00:03:44.540
first is we can say that each variable is
constrained by the capacity of the corresponding

00:03:44.540 --> 00:03:52.249
edge. So, f b a, so b a is now this edge,
it has a capacity of 10. So, whatever flow

00:03:52.249 --> 00:03:59.499
I finally arrive at from b to a must be less
than 10 and the other thing that we can say

00:03:59.499 --> 00:04:04.790
is that we must have a conservation of flow
at each internal node. So, for instance if

00:04:04.790 --> 00:04:11.849
I look at this node d, then the incoming flow
is a d plus b d, the outgoing flow is d c

00:04:11.849 --> 00:04:18.919
plus d e plus d t and these two quantities
must be equal, f a d plus f b d must be equal

00:04:18.919 --> 00:04:25.210
to f d c plus f d e plus f d t.
And finally, so these are the constraints,

00:04:25.210 --> 00:04:31.960
so the constraint says that every edge can
only carry or flow with in this capacity and

00:04:31.960 --> 00:04:37.120
in every internal node there is a conservation
of flow. And finally, our objective is to

00:04:37.120 --> 00:04:43.979
maximize what happens on these three edges
f s a plus f s b plus f s c, this is our objective

00:04:43.979 --> 00:04:46.120
function.

00:04:46.120 --> 00:04:52.930
So, of course as before we will just invoke
a linear programming solver such as simplex

00:04:52.930 --> 00:05:01.060
on this and get an answer. But, what we will
do now is to understand what this actually

00:05:01.060 --> 00:05:05.280
means, remember how simplex works. So, simplex
start with the vertex of feasible region gives

00:05:05.280 --> 00:05:11.360
going from one vertex to the next. So, as
long as it’s increasing the flow is actually

00:05:11.360 --> 00:05:15.129
taking an existing flow and adding something
do it and this can actually be interpreted

00:05:15.129 --> 00:05:18.860
directly in terms of the flow finding algorithm.

00:05:18.860 --> 00:05:26.380
So, this is an algorithm called the Ford-Fulkerson
algorithm which actually tries to directly

00:05:26.380 --> 00:05:31.729
solve a network flow problem by gradually
building up an optimum flow. So, the algorithm

00:05:31.729 --> 00:05:39.560
assume you starts with 0 flow and then you
choose some path on which there is pair capacity

00:05:39.560 --> 00:05:45.539
and then on this path, you augment the flow
as much as possible, so that path become saturated.

00:05:45.539 --> 00:05:50.740
So, now if you look at the algorithm network
on the right, it is very clear that there

00:05:50.740 --> 00:05:55.980
is a flow possible of two, you can send one
unit of flow that way, you can sent one unit

00:05:55.980 --> 00:06:03.639
of flow this way. But, Ford-Fulkerson algorithm
says take any path which exists and starts

00:06:03.639 --> 00:06:05.210
flowing things to there.

00:06:05.210 --> 00:06:10.219
So, you could for instances begin with this
path, the one that goes from s to d then from

00:06:10.219 --> 00:06:15.849
the d down to e and then to t. So, flows one
unit, but now this point this edge is not

00:06:15.849 --> 00:06:20.379
saturated and this edge is not saturated and
of course, this edge is in the wrong direction.

00:06:20.379 --> 00:06:26.719
So, I cannot make use of these two capacities
to generate the second unit of flow, so it

00:06:26.719 --> 00:06:33.740
looks like the Ford-Fulkerson algorithm reaches
a bottle neck, if you choose the wrong path

00:06:33.740 --> 00:06:35.850
to start with.

00:06:35.850 --> 00:06:44.139
So, the solution is to save that even if you
have taken a bad path, one of the things we

00:06:44.139 --> 00:06:48.660
can do is reverse the decision we made earlier.
So, we want to say that if we are flowing

00:06:48.660 --> 00:06:54.710
one through this, then we can reduce this
flow. So, we can divert this flow back another

00:06:54.710 --> 00:07:01.279
way, so that is a bit complicated to describe,
but one way to solve it is to actually setup

00:07:01.279 --> 00:07:07.490
and extra edge allowing us flow things back.
So, this is what we call the residual graph,

00:07:07.490 --> 00:07:12.159
so in the residual graph what we will do is
we will actually take the flow that we just

00:07:12.159 --> 00:07:19.349
constructed and then we will change the capacities.
So, the forward edge s to d which had capacity

00:07:19.349 --> 00:07:25.789
1 and flow 1, now has residual capacity 0.
So, we have a regular edge then we replaced

00:07:25.789 --> 00:07:32.389
it is weight by the actual amount that is
still available. So, that is the capacity

00:07:32.389 --> 00:07:39.479
minus the current flow and in addition we
add these new edges - these backward edges,

00:07:39.479 --> 00:07:43.949
which correspond to these flows that we have
committed, but which we may want to change

00:07:43.949 --> 00:07:47.219
later.
So, we have sent a flow 1 from s to d, but

00:07:47.219 --> 00:07:53.430
now we can reduce that flow by sending some
flow back from d to s that is what this is

00:07:53.430 --> 00:07:55.860
supposed to do. So, formally this is how we
construct the residual graph, you take the

00:07:55.860 --> 00:08:00.219
original graph then any flow that you have
set up in an existing edge, you reduce the

00:08:00.219 --> 00:08:06.520
capacity of that edge by that flow, and corresponding
to that flow you setup a reverse edge which

00:08:06.520 --> 00:08:11.300
allows us later to undo this.

00:08:11.300 --> 00:08:16.529
So, going back to this example, so what we
would do is we would first start with this

00:08:16.529 --> 00:08:22.180
wrong flow and then we will say, but then
we build this residual graph and now we will

00:08:22.180 --> 00:08:28.569
observe that in this residual graph, there
is a path which goes like this. So, we are

00:08:28.569 --> 00:08:31.909
not talking about the original graph, we are
only talking about residual graph at each

00:08:31.909 --> 00:08:35.190
stage. So, we will now build this. Now this
will result in the new flows. So, this will

00:08:35.190 --> 00:08:43.979
end up reducing a 0 here a new edge back here,
similarly a 0 here, a new edge back here and

00:08:43.979 --> 00:08:49.160
this one will now become canceled out.
Because now this path has this flow restored

00:08:49.160 --> 00:08:56.149
to one and this edge will disappear and now
in this new graph we will find that there

00:08:56.149 --> 00:08:59.630
are no edges left, because I have 0 capacity
going from s to d and 0 capacity going to

00:08:59.630 --> 00:09:05.320
s to e. So, I cannot leave any flow from s,
so this is my final flow, so this is the ford

00:09:05.320 --> 00:09:10.790
Fulkerson algorithm, let us look at it again
in a slightly similar structure, but with

00:09:10.790 --> 00:09:12.620
us slightly different set of numbers.

00:09:12.620 --> 00:09:18.660
So, this is a graph which has no 1s, but some
20s and 30s, so here intuitively with the

00:09:18.660 --> 00:09:23.440
claim is that all the 30 units can flow. But,
the 30 units cannot flow unlike the earlier

00:09:23.440 --> 00:09:27.899
case along the edges of the diagonal, because
if I take 20 units up then I must split it

00:09:27.899 --> 00:09:35.260
as 10 plus 10. So, I must recognize that 10
must go down and 10 must go there, similarly

00:09:35.260 --> 00:09:39.980
if I put 10 here then this 10 and then incoming
10 combine from these 20, so this is have

00:09:39.980 --> 00:09:43.990
I get of flow of 30 in this graph.

00:09:43.990 --> 00:09:47.610
But, if I start the Ford-Fulkerson algorithm,
it will try to saturated the path. So, supposing

00:09:47.610 --> 00:09:53.990
it identifies the path s to d to e to t, then
if it identifies this path then it is put

00:09:53.990 --> 00:09:56.670
at 20 flow through this edge.

00:09:56.670 --> 00:10:02.250
So, we start with it in this flow and we build
the residual graph, the residual graph says

00:10:02.250 --> 00:10:09.390
that this 10 is 30 minus 20. The residual
capacity from d to e is now 10 because I had

00:10:09.390 --> 00:10:16.380
a capacity of 30 and I put 23. And the blue
edge is now, the residual edge which allows

00:10:16.380 --> 00:10:22.759
me to reduce this 20 back, similarly from
s to d I had earlier a capacity of 20. I have

00:10:22.759 --> 00:10:27.000
put 20 through it. So, its reduced capacity
is now 0. But, I have a backward edge which

00:10:27.000 --> 00:10:31.070
allows we to undo this later requirement and
the same width e to t, e to t is reduced to

00:10:31.070 --> 00:10:36.269
0, but I have a backward edge. Now, I look
for another path in this graph, so for instances

00:10:36.269 --> 00:10:43.610
I find that this path is there I have a path
from s to e to d to t.

00:10:43.610 --> 00:10:49.050
And in s to e to d to t my constraint is 10,
because I have only ten flowing out of s to

00:10:49.050 --> 00:10:54.250
begin with, so I take that 10 and then I build
a residual graph.

00:10:54.250 --> 00:11:02.040
So, when I take that 10 these quantities here
which are associated with this edge gets restored

00:11:02.040 --> 00:11:07.800
back by 10. Because the total flow from d
to e was 20 in the first round minus 10 in

00:11:07.800 --> 00:11:16.360
the second round so it’s 10 therefore, the
residues 30 minus 10, it will 20 and everywhere

00:11:16.360 --> 00:11:21.949
else now I’ve got 0 because I’ve saturated,
now if I look at s there is no outgoing flow

00:11:21.949 --> 00:11:23.840
possible in this residual graph.

00:11:23.840 --> 00:11:29.061
So, then I say that there are no more feasible
path and I stop and the residual edges, or

00:11:29.061 --> 00:11:30.530
if I have been keeping track of that flow,
it will tell me that I have achieved a flow

00:11:30.530 --> 00:11:37.320
of 30 in this graph.

00:11:37.320 --> 00:11:44.360
So, again if you want to ask the question
as to why a given flow is optimal, we can

00:11:44.360 --> 00:11:53.339
ask for some quantity which is a certificate
of optimality. So, if we go back to that original

00:11:53.339 --> 00:11:57.760
oil shipping thing we claim that we could
setup a flow of 7. So, by hand we constructed

00:11:57.760 --> 00:12:04.069
a flow of 7, now let us look at these three
edges, the edge a to d, the edge b to d, the

00:12:04.069 --> 00:12:10.959
edge s to c, if we disconnect this graph by
cutting these edges, or if we cut these edges

00:12:10.959 --> 00:12:15.509
we disconnect this graph.
So, these three edges form what is called

00:12:15.509 --> 00:12:22.509
a cut between s and t, now in this cut the
total capacity is 4 plus 1 plus 2, 7. Now

00:12:22.509 --> 00:12:28.690
if there is any flow at all; however, it flows
it must cross from this side to this side

00:12:28.690 --> 00:12:33.220
from the left to the right. So, it can only
flow from the left to the right through the

00:12:33.220 --> 00:12:39.130
edges with a part of that cut that the cut
can only support a flow of 7. So, therefore

00:12:39.130 --> 00:12:46.319
our optimum flow can definitely not exceed
7 in this example, which we have already achieved.

00:12:46.319 --> 00:12:50.160
So, we know that we can do flow of 7, but
no more than 7 is possible, because this cut

00:12:50.160 --> 00:12:54.190
will prevent anything more than 7 from flowing
from the left to the right. So, actually in

00:12:54.190 --> 00:13:00.570
this case this shows us that 7 is optimum,
so in general you can look at various such

00:13:00.570 --> 00:13:05.500
cuts. So, cut is any set of edges with disconnects
s from t and you can calculate the minimum

00:13:05.500 --> 00:13:11.470
cut across all of these and it is pretty clear
that the maximum flow cannot exceed the minimum

00:13:11.470 --> 00:13:16.060
cut, because it has to cross this cut. So,
you have to go from one side to another it

00:13:16.060 --> 00:13:19.940
can only take that much of capacities, so
the flow cannot exceed that.

00:13:19.940 --> 00:13:26.399
So, what is surprising is that actually that
it will always in this example of the we did

00:13:26.399 --> 00:13:32.470
it was equal, but it always going to be equal.
So, the max flow min cut theorem says, that

00:13:32.470 --> 00:13:37.380
the max flow is actually always equal to the
minimum cut. So, here is one way to understand

00:13:37.380 --> 00:13:45.339
this, so if we look at our l p solution, when
we achieve the maximum flow, then s is going

00:13:45.339 --> 00:13:50.029
to be disconnected from t, there is no further
path if I look at edge weight 0 and I remove

00:13:50.029 --> 00:13:54.370
those edges, then there is no further path.
So, s is disconnected from t, so there is

00:13:54.370 --> 00:14:01.269
a cut there are some edges which disconnect
edge s from t. Now, let us look at any edge

00:14:01.269 --> 00:14:05.790
in the residual graph at that point which
goes from the left hand side to the right

00:14:05.790 --> 00:14:11.769
hand side. So, left is everything, so everywhere
inside this I do have paths with nonzero edges

00:14:11.769 --> 00:14:17.990
and everywhere inside this I do have paths
with nonzero weights. So, now but I cannot

00:14:17.990 --> 00:14:21.910
get from the blue side to the green side.
So; that means, that in the forward direction

00:14:21.910 --> 00:14:28.750
all the edges must have saturated their capacity.
So, every edge from l to r is actually at

00:14:28.750 --> 00:14:34.589
full capacity, what about an edge in my residual
graph f to r to l, the claim is a there was

00:14:34.589 --> 00:14:40.610
some capacity here then they would be a reverse
edge which goes this way, which would be at

00:14:40.610 --> 00:14:43.970
non zero capacity. So, there would be a path
from s to t but there are no paths, so this

00:14:43.970 --> 00:14:47.060
must be at 0.
So, all the reverse edges must be at 0 all

00:14:47.060 --> 00:14:53.040
the forward edges must be a full capacity.
So, this gives a not very precise, but a reason

00:14:53.040 --> 00:14:57.420
why, the max flow will actually saturate this
cut, but this could be any cut. So, therefore

00:14:57.420 --> 00:15:01.720
the minimum cut in particular will be saturated
and therefore, the max flow cannot exceed

00:15:01.720 --> 00:15:08.570
the minimum cut anyway, so the maximum must
achieve the minimum cut value.

00:15:08.570 --> 00:15:14.089
So, one think that one has to be careful about
in the Ford-Fulkerson algorithm is the choice

00:15:14.089 --> 00:15:19.579
of how to increase the path. So, remember
that in our pathological examples, we instead

00:15:19.579 --> 00:15:22.889
of going around the diamond you go through
the center. So, supposing we keep doing that

00:15:22.889 --> 00:15:27.470
the model happen is here after one iteration,
we go through this center and then we reduce

00:15:27.470 --> 00:15:33.149
this 99 this to 0 this to 99 and we will set
up a reverse edge of size 1.

00:15:33.149 --> 00:15:37.330
Then this next iteration we will go in the
reverse direction and we will again reduce

00:15:37.330 --> 00:15:43.089
this to 99 this to 99 and then we’ll set
up this reset this way back to one. So, this

00:15:43.089 --> 00:15:48.430
way we can keep zig-zagging. So, I will go
from 99 to 98 and the down algorithm 99 to

00:15:48.430 --> 00:15:54.760
98, so it will take me 200 iterations in order
to find this path, that this flow has 200.

00:15:54.760 --> 00:15:58.089
on the other hand it’s pretty clear that
I could done it two iteration if had been

00:15:58.089 --> 00:15:59.089
cleverer.

00:15:59.089 --> 00:16:02.490
Because I could have just said, initially
there is a path of 200 there and that saturates

00:16:02.490 --> 00:16:07.570
those two edges and there is another path
of 200 there, in a path of 100 there in the

00:16:07.570 --> 00:16:13.250
path of 100 here. So, in two iterations I
can achieve 200, So it depends quite crucially

00:16:13.250 --> 00:16:17.910
on how I pick the path to augment, how do
I take the feasible path which still exist

00:16:17.910 --> 00:16:21.639
in the residual graph and choose which one
to add to.

00:16:21.639 --> 00:16:26.189
So, in general we cannot say anything good
and Ford-Fulkerson is going to take time which

00:16:26.189 --> 00:16:30.339
is proportional to the capacity of the edges
which is not a great idea. Because although

00:16:30.339 --> 00:16:33.610
the edges may be large you might may be able
to directly say this edge can take 100 the

00:16:33.610 --> 00:16:36.740
next edge can take 100. So, in one shot I
can say the whole path can take 100, but if

00:16:36.740 --> 00:16:41.319
I have to do one at a time then it becomes
an extra parameter and not the actual size

00:16:41.319 --> 00:16:46.959
of the graph. But, how do we do this feasible
path business at all. So, every time we set

00:16:46.959 --> 00:16:56.420
up a residual graph we have to find a path
from s to t and then augment it.

00:16:56.420 --> 00:17:00.120
So, this we would have seen right in the beginning
of this course, we will either do it through

00:17:00.120 --> 00:17:05.370
breadth first search or depth first search,
finding a path from one node to another node

00:17:05.370 --> 00:17:10.721
is typically just the exportation of the graph,
if we use breadth first search, then what

00:17:10.721 --> 00:17:16.880
we know we find the shortest path in terms
of number of edges. So, one can prove that

00:17:16.880 --> 00:17:21.890
in this the Ford-Fulkerson algorithm, if we
use breadth first search at every iteration

00:17:21.890 --> 00:17:26.750
to decide which path to augment, then you
will be augmenting always the shortest path

00:17:26.750 --> 00:17:30.130
in terms of edges.
So, for instance in this example here, if

00:17:30.130 --> 00:17:36.640
you had a choice between augmenting that path
the 100 path which goes above like this and

00:17:36.640 --> 00:17:41.680
the path which goes like this, then breadth
first search will say that the first the red

00:17:41.680 --> 00:17:46.630
path has got two edges and the orange path
has got three edges. So, the red path is shorter,

00:17:46.630 --> 00:17:51.680
so we must augment that first, so if we use
breadth first search in the ford Fulkerson

00:17:51.680 --> 00:17:56.030
algorithm, it turns out that you will always
get something which is proportional to the

00:17:56.030 --> 00:18:00.070
product on the vertex in the edges. So, it
will be polynomial in the size of network

00:18:00.070 --> 00:18:01.290
independent of the capacities.

