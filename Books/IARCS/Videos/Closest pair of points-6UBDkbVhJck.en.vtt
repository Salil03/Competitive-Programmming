WEBVTT
Kind: captions
Language: en

00:00:01.170 --> 00:00:05.841
We now look at another divide and conquer
algorithm, this is a geometric problem, given

00:00:05.841 --> 00:00:10.740
a set of points we would like to compute the
closest pair of points among them.

00:00:10.740 --> 00:00:16.679
So, recall that at the beginning of this set
of lectures to motivate the need for more

00:00:16.679 --> 00:00:21.460
efficient algorithms, you consider the example
of a video game, if there are several objects

00:00:21.460 --> 00:00:26.340
on the screen and you might want to find it
at any given point, the closest pair of objects

00:00:26.340 --> 00:00:32.109
among them. So, for this again a naive algorithm
could be to explicitly compute the distance

00:00:32.109 --> 00:00:37.850
between every pair of these n objects, which
should be an order n squared algorithm. So,

00:00:37.850 --> 00:00:42.670
what we are going to see is that we can actually
use divide and conquer and produce an order

00:00:42.670 --> 00:00:46.940
n log n algorithm for this problem.

00:00:46.940 --> 00:00:51.980
So, formally we are looking at points in two
dimensions, so each point is given by an x

00:00:51.980 --> 00:00:57.899
y coordinate x p, y p and we are using the
usual Euclidian notion of distance that is

00:00:57.899 --> 00:01:02.539
the distance given by Pythagoras used formula,
which is that the distance between p 1 and

00:01:02.539 --> 00:01:07.490
p 2 is the square root of x 2 minus x 1 whole
square plus y 2 minus y 1 whole square. So,

00:01:07.490 --> 00:01:12.240
you just assume that there is a distance formula
which we can use whenever we want to compute

00:01:12.240 --> 00:01:18.310
the distance between a pair of points.
So, our target is given a set of n points

00:01:18.310 --> 00:01:24.020
p 1 to p n to find the closest pair among
them and it will be convenient for the analysis

00:01:24.020 --> 00:01:29.030
of the algorithm that we are going to suggest
that no two points in this set have the same

00:01:29.030 --> 00:01:33.780
x or y coordinate. So, every x coordinate
among these n x coordinates is different,

00:01:33.780 --> 00:01:38.850
every y coordinate among these n coordinates
is different. Now, it can be extended by algorithm

00:01:38.850 --> 00:01:42.140
we are going to show, it can be extended to
deal with the case where this assumption is

00:01:42.140 --> 00:01:46.420
not true, but it will then unnecessarily complicate
the understanding of the algorithm.

00:01:46.420 --> 00:01:50.710
So, let us just assume that we are solving
this special case of the problem, where every

00:01:50.710 --> 00:01:55.240
point is at a different x coordinate and at
different y coordinate from every other point.

00:01:55.240 --> 00:02:01.909
So, as we have seen a brute force solution
would be to try every pair, compute d of p

00:02:01.909 --> 00:02:06.649
i p j and then report the minimum amount of
distances. So, this would be an order n squared

00:02:06.649 --> 00:02:08.259
algorithm.

00:02:08.259 --> 00:02:15.590
So, let us see first the same problem if we
had only one dimensional points. If we have

00:02:15.590 --> 00:02:19.840
one dimensional points then all these points
lie along the line, which we can assume this

00:02:19.840 --> 00:02:24.430
the x axis. So, we have a bunch of points
and we want to find the closest point. So,

00:02:24.430 --> 00:02:30.360
what we can do is we can first sort them,
so that we have the points in increasing order

00:02:30.360 --> 00:02:37.200
of x coordinate and then it is easy to see
that the distances that we need are the distances

00:02:37.200 --> 00:02:39.319
between two adjacent points.
Because, if I look at a point, the nearest

00:02:39.319 --> 00:02:44.040
point if either the one on it is left and
one on it is right. So, I just need to scan

00:02:44.040 --> 00:02:48.900
this x 2 minus x 1 distance, then x 3 minus
x 2, so I just need to scan these n minus

00:02:48.900 --> 00:02:53.610
1 distances and then keep track of the smallest
gap between these two points and that would

00:02:53.610 --> 00:02:59.260
give me the smallest distance among the overall
pair of overall n points. So, here the algorithm

00:02:59.260 --> 00:03:03.680
is n log n, because it takes n log n times
to sort the points in x coordinate, after

00:03:03.680 --> 00:03:07.470
that finding the minimum is actually very
easy. So, in one dimension this problem is

00:03:07.470 --> 00:03:12.140
very easy to solve, the challenge is to solve
it in two dimensions.

00:03:12.140 --> 00:03:18.780
So, it two dimensions if we are going to use
divide and conquer, we need a way of separating

00:03:18.780 --> 00:03:25.270
the points into two groups, of roughly equal
size or a hopefully exactly equal size. So,

00:03:25.270 --> 00:03:30.620
a natural way is this is the geometric problem
is to separate them based on their positions.

00:03:30.620 --> 00:03:34.620
So, this is my overall set of points, then
this natural to try and draw some kind of

00:03:34.620 --> 00:03:38.920
a line and say that half the points are here
and half the points are there.

00:03:38.920 --> 00:03:45.660
So, we will do it using a vertical line, so
we will split this set not by some arbitrary

00:03:45.660 --> 00:03:56.150
line like this, but rather we will try and
split it by a vertical line. So, somewhere

00:03:56.150 --> 00:04:00.709
which may not be half way across, because
the points may be scattered in an uneven way,

00:04:00.709 --> 00:04:04.260
we will split it, so that there are exactly
the same number of points the left to the

00:04:04.260 --> 00:04:08.640
line and to the right to the line.
So, now because of we divide and conquer thing

00:04:08.640 --> 00:04:13.540
what we will do is, we will compute the smallest
distance among the points to the left, separately

00:04:13.540 --> 00:04:17.410
we will compute the smallest distance points
from the right. But, this does not tell us

00:04:17.410 --> 00:04:21.080
anything about distances between points on
the left and points on the right and they

00:04:21.080 --> 00:04:24.230
could very well be points very close to each
other across the boundary.

00:04:24.230 --> 00:04:29.470
So, I could have add four points here, four
points there and I could have add a pair of

00:04:29.470 --> 00:04:34.250
points which spans this black line, which
are actually closer together, then any two

00:04:34.250 --> 00:04:40.250
points to the left or two point to the right.
So, we need to compute the closest pairs across

00:04:40.250 --> 00:04:43.360
the separating line and this is the challenge.

00:04:43.360 --> 00:04:52.760
So, let us look a little closer at how we
do this. So, we will make a further step before

00:04:52.760 --> 00:04:59.410
we do this thing recursively. Given our points
P we will compute points, the set of points

00:04:59.410 --> 00:05:05.251
we will compute two sorted orders. So, we
will first scan these points by x coordinate

00:05:05.251 --> 00:05:12.020
from left to right and we will list it in
this order and call it P x, then we will scan

00:05:12.020 --> 00:05:16.480
this, the list P from...
So, we will sort on the y coordinate and call

00:05:16.480 --> 00:05:23.280
this P y, so from P we will produce two list,
one sorted by x and one sorted by y. Then,

00:05:23.280 --> 00:05:26.540
so we will assume that we have done this of
course, we can do this we know in order n

00:05:26.540 --> 00:05:34.660
log n time right to the beginning. Now, the
next step is to do this recursive call and

00:05:34.660 --> 00:05:39.121
so when we do the recursive call, because
we have P x sort it by x coordinate, we know

00:05:39.121 --> 00:05:44.340
that the line that we need to draw is the
one that separates P x into two equal parts.

00:05:44.340 --> 00:05:49.380
So, we need to go to the midpoint of P x and
draw a line at the x coordinate separating

00:05:49.380 --> 00:05:54.440
the midpoint from the next point. So, the
position of this line is fixed once we know

00:05:54.440 --> 00:05:58.970
P x, fix meaning we know between which two
points. Remember, we assume that no two points

00:05:58.970 --> 00:06:02.850
at the same x coordinate, no two points at
the same y coordinate. So, I just look for

00:06:02.850 --> 00:06:07.810
the median value or the value at the middle
of x, I draw a line there.

00:06:07.810 --> 00:06:12.260
Now, I separately doubt into two equal parts
they assumption, because I have done this

00:06:12.260 --> 00:06:18.230
able midpoint of P x. So, I have two set Q
and R, but in order to continue this recursion

00:06:18.230 --> 00:06:25.620
I need to assume that Q is sorted in both
x and y and so is R. So, I need to assume

00:06:25.620 --> 00:06:30.660
that I have some efficient way of extracting
for the each of these some problems, a similar

00:06:30.660 --> 00:06:35.570
ordering of the points sorted by x, sorted
by y. So, I need to efficiently compute Q

00:06:35.570 --> 00:06:40.610
x and Q y, R x and R y.

00:06:40.610 --> 00:06:47.660
Q x and Q y is easy, because this whole thing
earlier was P x and then we split this thing

00:06:47.660 --> 00:06:52.810
midpoint. So, everything to the left of the
midpoint is Q x and everything to the right

00:06:52.810 --> 00:06:57.050
of the midpoint is R x. So, in one scan of
P x I go up to half way and I put everything

00:06:57.050 --> 00:07:03.270
in Q x and then in half way point I put everything
in R x and I am done. Now, what about y? Now,

00:07:03.270 --> 00:07:08.590
y the problem is as I am going up these two
points are in Q y, then this point goes into

00:07:08.590 --> 00:07:12.690
R y because in the overall scheme of things
in P y, these are all listed globally by y

00:07:12.690 --> 00:07:16.690
coordinate.
So, I would have to move this to R, then I

00:07:16.690 --> 00:07:22.400
would to put this back into... So, next one
again possibly R any one how you use this,

00:07:22.400 --> 00:07:29.150
the next one is Q and so on. So, as I am going
up some points going Q y and some going R

00:07:29.150 --> 00:07:36.900
y. Now, how do I determine that without going
over this too many times, so the key is that

00:07:36.900 --> 00:07:43.830
having done this split of x, we note this
dividing line. So, we know which x coordinate

00:07:43.830 --> 00:07:52.030
separates Q from R.
So, as we go through P y, we will look at

00:07:52.030 --> 00:07:59.250
each point and if the x coordinate is less
than this midpoint, so let us call this x

00:07:59.250 --> 00:08:07.220
Q, if it is less than x Q, then we push it
into Q y, if it is x is greater than x Q then

00:08:07.220 --> 00:08:12.680
we push it into R y and because if it is originally
sorted, we are building up Q y and R y also

00:08:12.680 --> 00:08:18.980
in sorted order. So, ones scan of P y you
get Q y and R y. So, in linear time we can

00:08:18.980 --> 00:08:25.590
take the given sorted list P x and P y and
separate it out into sorted list Q x, Q y

00:08:25.590 --> 00:08:30.620
for the left half R x, R y for the right half.

00:08:30.620 --> 00:08:37.620
So, now when we call our algorithm with closest
pair P x, P y it will split recursively into

00:08:37.620 --> 00:08:43.539
closest pair Q x, Q y and R x, R y to the
left and right half. So, we will, you can

00:08:43.539 --> 00:08:48.420
assume as usual that we will solve these recursively,
we will get the closest distance there. Now,

00:08:48.420 --> 00:08:52.980
we have to worry about how to combine them,
how to take care of these points whose distance

00:08:52.980 --> 00:08:58.839
pans the interval, the line separating the
two halves.

00:08:58.839 --> 00:09:07.460
So, if we solve this problem on the left among
all the points in Q, I will identify some

00:09:07.460 --> 00:09:13.690
pair of points as being the nearest pair with
the distance d Q. And now similarly, if I

00:09:13.690 --> 00:09:17.600
do solve the problem right I would identify
some pair of points as being the minimum of

00:09:17.600 --> 00:09:24.389
the right with distance d R. So, now we are
interested in this smaller or these two, because

00:09:24.389 --> 00:09:27.620
the smaller are these two is a candidate for
the overall minimum distance.

00:09:27.620 --> 00:09:34.490
So, now we are looking at points which could
be within at d Q is smaller than the d Q across

00:09:34.490 --> 00:09:41.450
this boundary. So, let d be the minimum of
d Q and d R, so it is the smaller of these

00:09:41.450 --> 00:09:47.430
two, so in this particular example d is d
Q. Now, the claim is that if you look at this

00:09:47.430 --> 00:09:58.209
zone here which is plus minus d distance away
from the separated line, then if I have some

00:09:58.209 --> 00:10:02.980
point outside this and if I want to look at
any point across on the other side, this distance

00:10:02.980 --> 00:10:07.060
from here to here is key plus some distance
on either side therefore, it is more than

00:10:07.060 --> 00:10:09.300
d.
So, it is more than the smaller of d Q and

00:10:09.300 --> 00:10:15.110
d R, so it cannot be a candidate for our overall
smallest distance. So, these kind of things

00:10:15.110 --> 00:10:21.380
are useless, there is no point in looking
for any line which is any pair whose one end

00:10:21.380 --> 00:10:25.740
point is outside this zone. Because, if it
is outside the zone, then it can only be at

00:10:25.740 --> 00:10:30.600
least b plus something away from something
on the other side to the line. So, it is enough

00:10:30.600 --> 00:10:35.330
to look at points inside the zone on both
sides. So, we only need to consider points

00:10:35.330 --> 00:10:40.829
across the separator which line within this
plus minus d, any pair outside this cannot

00:10:40.829 --> 00:10:42.600
be the closest pair overall.

00:10:42.600 --> 00:10:49.270
So, let us take a closer look, so this is
my plus minus d zone. Let, so this is minus

00:10:49.270 --> 00:10:53.600
d, this is plus d. Now, what we are going
to do is, we are going to further break it

00:10:53.600 --> 00:11:01.290
up into these squares of size d by 2, so I
had d by 2 plus d by 2. So, this whole thing

00:11:01.290 --> 00:11:06.551
with d, I am going to construct all these
squares. So, the claim is that inside such

00:11:06.551 --> 00:11:12.649
a box I can have at most one point, I cannot
have two points. Why, because the furthest

00:11:12.649 --> 00:11:18.139
separation within a box is across the diagonal,
the further step two points can be in the

00:11:18.139 --> 00:11:24.819
box is at 2 end points to the diagonal.
But, the diagonal of this square of size d

00:11:24.819 --> 00:11:31.630
by 2 is square root of d by 2, so this is
some points 0.047 d. So, this is less than

00:11:31.630 --> 00:11:35.820
d strictly less than d, but notice that this
square is completely on one side the right

00:11:35.820 --> 00:11:39.850
times, either on the left or the right and
both on the left and right we know that the

00:11:39.850 --> 00:11:45.339
minimum separation is d, there is no point
on one side of the line there are no two points

00:11:45.339 --> 00:11:48.699
closer than d, because d is a minimum of d
Q and d R.

00:11:48.699 --> 00:11:56.759
So, therefore in each of these boxes we can
have at most one point and now we start looking

00:11:56.759 --> 00:12:02.259
at any point. So, look at a point here in
this box, now the claim is that if I have

00:12:02.259 --> 00:12:10.569
to be within distance d, then how far away
can I be well, if you think about it the furthest

00:12:10.569 --> 00:12:17.620
you can be or the furthest box you can go
to, go to that box. So, you can be a little

00:12:17.620 --> 00:12:21.220
more careful about is, but it certainly cannot
be any further than that box.

00:12:21.220 --> 00:12:29.209
So, if you have to go from this box basically
if we have to go more than this distance away,

00:12:29.209 --> 00:12:36.699
then it will be more than d away. So, the
claim is that any point within this distance

00:12:36.699 --> 00:12:45.360
d must lie within the next 4 by 4 segments.
So, we have to compare each point only against

00:12:45.360 --> 00:12:49.680
15. Now of course, we will compare it will
one scan from bottom to top. So, this could

00:12:49.680 --> 00:12:53.019
have the points below this they could again
compared when we consider those and before.

00:12:53.019 --> 00:12:58.389
So, we will consider, we will do this scan
in this order as we will see in the net. So,

00:12:58.389 --> 00:13:02.519
therefore, we only need to consider this point
against points in these 16 squares around

00:13:02.519 --> 00:13:07.760
it. So, that is the fix number independent
of how many points they actually have.

00:13:07.760 --> 00:13:14.449
So, formally what we will do is we have this
and this side we have Q y which is sorted

00:13:14.449 --> 00:13:18.210
and this side we have R y which is sorted,
but remember they are both sorted. So, we

00:13:18.210 --> 00:13:23.629
will do a kind of merge, so we will go through
Q y and R y we will pick the next one in sorted

00:13:23.629 --> 00:13:29.750
y order between Q y and R y. If the x coordinate
is remember this is an x Q are originally

00:13:29.750 --> 00:13:34.540
separating point plus d and minus d. If the
x coordinate of the point that be find is

00:13:34.540 --> 00:13:39.740
between x Q plus d and x Q minus d, then we
will added to a list S y.

00:13:39.740 --> 00:13:48.199
So, S y will now the sorted list of points
within this band from bottom to top extracted

00:13:48.199 --> 00:13:56.499
from Q y and R y in linear line. Now, within
this list, these next 15 boxes, these boxes

00:13:56.499 --> 00:14:01.649
will now be all ordered. So, if I just scan
them then I will find that I all these...

00:14:01.649 --> 00:14:06.110
So, they would be possibly 4 points which
come from these 4 boxes, 4 from these 4 boxes

00:14:06.110 --> 00:14:12.160
and so on. So, I can definitely find the next
15 points in this list and I compare only

00:14:12.160 --> 00:14:14.339
with these. So, this is the linear scan.

00:14:14.339 --> 00:14:20.389
So, in other words we have this following
algorithm, so we start with by assuming that

00:14:20.389 --> 00:14:25.529
we have set off a problem. So, that P has
been split into two copies P x and P y sort

00:14:25.529 --> 00:14:30.560
it by x, sort it by y. Now, if we have less
than 3 points, 3 points are less then, we

00:14:30.560 --> 00:14:34.970
just do it by brute force compute them closest
pair and return the answer. So, the answer

00:14:34.970 --> 00:14:40.449
consists of the distance and a pair, the points
which are at the distance, if it is more than

00:14:40.449 --> 00:14:44.470
3 then we do this recursive thing.
So, we from P x and P y as we said we construct

00:14:44.470 --> 00:14:49.980
Q x, Q y and R x, R y and this we saw we can
do linear time. Then, we have recursively

00:14:49.980 --> 00:14:54.249
solve this solution, the solve problem of
Q and R and we will get these two distances

00:14:54.249 --> 00:15:03.940
d x and d R from this we will take d to be
the minimum of d Q and d R. So, using this

00:15:03.940 --> 00:15:08.899
we will set up this S y the list of all points
inside that zone and then we will scan that

00:15:08.899 --> 00:15:15.019
list to find within that zone which are the
points, which are in closest distance d S.

00:15:15.019 --> 00:15:20.249
Now, if d S is more than d Q the minimum of
d Q and d R, then s does not contribute anything,

00:15:20.249 --> 00:15:25.860
but if it is less gives as the correct answer.
So, we will return either the d Q the answer

00:15:25.860 --> 00:15:30.449
produce from the left or the answer produce
from the right or the answer produced from

00:15:30.449 --> 00:15:35.930
our in between zone depending on which of
these distances is the smallest. So, this

00:15:35.930 --> 00:15:39.839
is the basic algorithm you have to do a little
bit more work actually code it correctly,

00:15:39.839 --> 00:15:44.089
but this gives the overall structure of the
algorithm.

00:15:44.089 --> 00:15:50.040
So, we have a non recursive part which is
to first compute the initial sort it list

00:15:50.040 --> 00:15:55.769
P x and P y, this takes order on n log n time
force. Because, sorting takes n log n time

00:15:55.769 --> 00:16:02.639
then having set of this recursive thing the
overall recursive problem divides n points

00:16:02.639 --> 00:16:09.769
into two sets of n by 2. So, we have a familiar
thing which is T of n is 2 times T of n by

00:16:09.769 --> 00:16:15.670
2 and then because all the setting up time
and all these combining time is linear, we

00:16:15.670 --> 00:16:20.470
have exactly the recurrence for merge sort.
So, therefore, the recursive part also gives

00:16:20.470 --> 00:16:27.139
as order n log n, so we have a initial sorting
phase which n log n, we have a recursive part

00:16:27.139 --> 00:16:30.520
which is n log n and therefore, overall this
algorithm is n log n.

