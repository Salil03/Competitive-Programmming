WEBVTT
Kind: captions
Language: en

00:00:01.500 --> 00:00:04.480
Let us go back and look at Divide and Conquer
again.

00:00:04.480 --> 00:00:11.450
So, recall the divide and conquer paradigm
consists of breaking up a problem into disjoint

00:00:11.450 --> 00:00:16.970
subproblems. Then, we solve each of these
subproblems separately and then we combine

00:00:16.970 --> 00:00:22.110
them efficiently to form a solution to the
original form. So, we have seen two examples

00:00:22.110 --> 00:00:27.320
of divide and conquer, merge sort is a classic
example of divided conquer, where we divide

00:00:27.320 --> 00:00:31.550
the list to be sorted of the array to be sorted
into equal parts.

00:00:31.550 --> 00:00:38.120
We sort these two parts separately and then,
we efficiently merge them, into a sorted list.

00:00:38.120 --> 00:00:43.500
Quick sort has the different strategy, what
it tries to do is avoid the merging step.

00:00:43.500 --> 00:00:48.079
So, you rearrange the original list, so that
you have a lower and upper partition with

00:00:48.079 --> 00:00:52.600
respect to a pivot. Having rearranged them,
you can sort the lower half and the upper

00:00:52.600 --> 00:00:57.720
half independently and now, because they already
rearranged, you do not have to merge them.

00:00:57.720 --> 00:01:02.680
So, basically there is a cost involve with
setting up this sub problems and a cost to

00:01:02.680 --> 00:01:08.070
involved with combining the subproblems. And
if this set up cost and combination cost is

00:01:08.070 --> 00:01:14.130
efficient, then the overall solution gives
you something much better than a direct approach

00:01:14.130 --> 00:01:15.130
could.

00:01:15.130 --> 00:01:21.880
So, let us look at the following situation,
very often when you go to an online store,

00:01:21.880 --> 00:01:27.010
you find a recommendation. For example, it
would say, the customers like you who were

00:01:27.010 --> 00:01:32.090
interested in books like these or customers
who bought this phone also look for this pair

00:01:32.090 --> 00:01:38.900
of head phones. So, these services are recommended
to you based on your profile, your online

00:01:38.900 --> 00:01:43.830
service maintains some profile information
about what you like and what you do not like.

00:01:43.830 --> 00:01:48.850
It compares what you likes and do not like
with others and identifies the similar category

00:01:48.850 --> 00:01:51.939
of people.
And then, it looks for products or services

00:01:51.939 --> 00:01:57.920
that category has opted for, which you have
not and then recommends these three. So, fundamental

00:01:57.920 --> 00:02:06.560
step in such a recommendations system is that
of comparing profiles, how does one persons

00:02:06.560 --> 00:02:12.510
likes, how do one persons likes and dislikes
compare to those of others.

00:02:12.510 --> 00:02:21.960
So, one instance of this is when you have
preferences over things like movies or books,

00:02:21.960 --> 00:02:28.090
so suppose over the sequence of time, you
have gone to some website and entered your

00:02:28.090 --> 00:02:32.599
preferences about movies that you watch. So,
say there are five movies, let us just call

00:02:32.599 --> 00:02:37.680
them A, B, C, D and E which both you and somebody
else have ranked on this website.

00:02:37.680 --> 00:02:42.310
So, you in general, two individual who come
up with different rankings. So, perhaps you

00:02:42.310 --> 00:02:48.760
rank D first and E last and your friend ranked
B first and E last. So, you both agreed that

00:02:48.760 --> 00:02:53.330
E was the worst, but you disagree on whether
B or D was better. In fact, your friend thinks

00:02:53.330 --> 00:02:58.810
D was so bad, that is actually only next E
and from the bottom. So, D which was your

00:02:58.810 --> 00:03:04.300
first has become your friends 4th.
So, now what we can do is we can take two

00:03:04.300 --> 00:03:11.840
such sets of rankings and ask how similar
or dissimilar they are. So, one way of measuring

00:03:11.840 --> 00:03:19.220
this is to compare how you rank pairs of movies.
So, for each pair of movies, you can compare

00:03:19.220 --> 00:03:23.340
whether you rank one better than the other
and your friend also does or you done. So,

00:03:23.340 --> 00:03:30.410
here for instants, if you look at B and C,
then this is ranked in a similar way by you

00:03:30.410 --> 00:03:35.020
and your friend.
On the other hand, if you looked at D and

00:03:35.020 --> 00:03:41.360
B, then in one case, you rank D above B and
your friend rank B above D. So, we do not

00:03:41.360 --> 00:03:44.019
particularly care how far a part there are,
how many other things there are, we are just

00:03:44.019 --> 00:03:48.730
saying given choice of two things, which do
you would prefer, which does your friend prefer

00:03:48.730 --> 00:03:53.019
and combine the choices across all the choices
available in the given list.

00:03:53.019 --> 00:04:02.010
So, what we are trying to do is measure the
dissimilarity in terms of what we call inversion.

00:04:02.010 --> 00:04:08.060
How many pairs of movies or rank in the opposite
way between you and your friend? So, if you

00:04:08.060 --> 00:04:12.200
and your friend rank every pair of movies
in the same order, then your total order of

00:04:12.200 --> 00:04:17.030
performances must be the same. So, if there
are zero inversions, then you have exactly

00:04:17.030 --> 00:04:21.060
similar in your taste to your friend and the
rankings are identical.

00:04:21.060 --> 00:04:29.160
On the other hand, if you have n movies, then
you can do n choice, n choose to pairs. So,

00:04:29.160 --> 00:04:34.210
the number of different pairs of movies are
n choose 2 which is n into n minus 1 by 2.

00:04:34.210 --> 00:04:39.220
So, if every possible movie you disagree with
your friend, then the number of inversions

00:04:39.220 --> 00:04:44.840
will be n into n minus n by 2, which is an
order n squared. So, you can use now this

00:04:44.840 --> 00:04:51.200
as a measure, how many pairs are out of order,
as a measure of how similar or dissimilar,

00:04:51.200 --> 00:04:55.590
two sets of rankings are and this could be
used for instance in this recommendation since

00:04:55.590 --> 00:05:00.520
to decide which customers to compare in making
a recommendation. So, you only want to pick

00:05:00.520 --> 00:05:04.730
customers who are close to the one, whose
recommendation is being made. There is no

00:05:04.730 --> 00:05:07.699
point recommending something that the personal
is not going to like because you comparing

00:05:07.699 --> 00:05:12.970
it with somebody who has very different taste.

00:05:12.970 --> 00:05:19.280
So, we can formulate this in another way.
So, now, we take our ranking and we assume

00:05:19.280 --> 00:05:25.460
that is the given order. So, we pick the certain
order for the movies and we call that the

00:05:25.460 --> 00:05:31.229
basic ranking 1, 2, 3, 4 up to n. Now, our
friends ranking would rank what we called

00:05:31.229 --> 00:05:37.380
1 as may be 5, what we call 2 is may be 3
and so on. So, everything that we rank with

00:05:37.380 --> 00:05:42.560
a rank i will be ranked where different rank
j by our friend and of course, every rank

00:05:42.560 --> 00:05:46.610
will appear there somewhere or the other.
So, the friends ranking will be a permutation

00:05:46.610 --> 00:05:51.930
of 1 to n and what you are asking is if I
rank i before j, that is before i is the smaller

00:05:51.930 --> 00:05:57.319
number than j, does the friend rank j before
i, any such think would be an inversion. So,

00:05:57.319 --> 00:06:01.460
inversion would be a pair i comma j in my
list, where i smaller than j. So, my list

00:06:01.460 --> 00:06:08.410
i is ahead of j, but in my friends list, j
appears before i in that permutation.

00:06:08.410 --> 00:06:12.810
Let us look at this little more concretely.
So, supposing this was our original example.

00:06:12.810 --> 00:06:18.699
So, there was 5 movies A, B, C, D, E and I
rank them and you rank them is D, B, C, A,

00:06:18.699 --> 00:06:25.580
E. Then, I would say D is 1, B is 2, C is
3 A is 4 and E is 5. So, this is my original

00:06:25.580 --> 00:06:33.039
list 1 to 5. Now, because I have this correspondence
between the movies and that things and the

00:06:33.039 --> 00:06:43.940
rankings, then I know that the D for a since
is 2. So, B is 2, A is 4, C is 3, D is 1 and

00:06:43.940 --> 00:06:49.710
E is 5.
So, from this list of preferences, I can rewrite

00:06:49.710 --> 00:06:55.210
it as a reordering of my ranking and now,
we are asking when whether there are pairs

00:06:55.210 --> 00:07:03.139
like this 2 and 1. So, 2 appear before 1 and
my friends list, it appears after 1 obviously

00:07:03.139 --> 00:07:09.190
in the original list, so this is an inversion.
So, 2, 1 is inversion, likewise 4, 1 is inversion,

00:07:09.190 --> 00:07:13.710
so it is 3, 1, so we have these three inversion,
whether we have write them as 1 of 2, 1; 3

00:07:13.710 --> 00:07:17.889
of 3, 1, because these are pairs, so it was
in order is not important, these pairs of

00:07:17.889 --> 00:07:24.020
movies a rank oppositely by you and your friend.
And the final inversion in this particular

00:07:24.020 --> 00:07:29.460
example is 3 and 4, so 3 and 4 appear in opposite
order, you can check therefore, every other

00:07:29.460 --> 00:07:35.010
pair for example, 4, 5 or 2, 3 or 2, 4 the
order is preserved. So, there are four inversions

00:07:35.010 --> 00:07:39.320
in this particular list between your ranking
and your friends ranking and our goal is to

00:07:39.320 --> 00:07:43.729
count this number of inversions given to permutations.

00:07:43.729 --> 00:07:49.150
So, another way of thinking about this, though
it will not materially affect how we compute

00:07:49.150 --> 00:07:55.509
it, is to draw this kind of a graph. So, you
take the rankings to start with as the correct

00:07:55.509 --> 00:07:59.950
order on top. So, you have one set of vertices
1 to 5 and then, you have to permutation of

00:07:59.950 --> 00:08:04.860
the vertices 1 to 5 listed in the order of
your friends ranking. And then, you combine

00:08:04.860 --> 00:08:09.070
1 to 1, 2 to 2 and so on, so that you build
up in the graph which as if you have 5 on

00:08:09.070 --> 00:08:13.270
top and 5 in the bottom, you have 5 edges,
if you have n and n you have n edges.

00:08:13.270 --> 00:08:20.379
Now, in this graph every time a line crosses
this indicates a mismatch, so 2 has a gone

00:08:20.379 --> 00:08:26.830
ahead of 1, likewise 4 is gone ahead of 3
and so on. So, there are 4 crossing is between

00:08:26.830 --> 00:08:35.459
these lines and that really corresponds to
four inversions in this example. So, now,

00:08:35.459 --> 00:08:39.600
there is a very simple brute force way to
check, because we know that every inversion

00:08:39.600 --> 00:08:43.530
is a pair i j, such that j appears before
i my friends list.

00:08:43.530 --> 00:08:47.769
So, we can just check that, we can just check
for every i and every j which is different

00:08:47.769 --> 00:08:52.500
from i, whether i and j is an inversion and
this will give us a Brute force order n squared

00:08:52.500 --> 00:08:56.370
algorithm. So, this actually enumerates all
the inversions, it is checks every possible

00:08:56.370 --> 00:09:00.940
pairs and if it is an inversion it says yes,
if it is not an inversion it says no and then,

00:09:00.940 --> 00:09:04.640
you count how many inversions you solve. And
we saw and that we can actually in the worst

00:09:04.640 --> 00:09:10.160
case have complete set n into n minus 1 by
2 inversions. So, this will exhaustedly enumerate

00:09:10.160 --> 00:09:13.170
every inversion in check it with yes or no.

00:09:13.170 --> 00:09:19.490
So, our goal is to give a more efficient algorithm,
so we will move to this divide and conquer

00:09:19.490 --> 00:09:26.120
paradigm. So, suppose your friend’s permutation,
our permutation always 1 to n, so we can just

00:09:26.120 --> 00:09:31.210
assume it is given. So, what is early interesting
is our friends permutation, so the friends

00:09:31.210 --> 00:09:36.540
permutation is some order of 1 to n jumbled
up, let us call it i 1 to i n.

00:09:36.540 --> 00:09:41.150
So, now, we will do something similar to merge
sort, so you will take this list i 1 to i

00:09:41.150 --> 00:09:47.230
n and divide in two parts. So, we have i 1
to i n by 2 which is the left and i n by 2

00:09:47.230 --> 00:09:52.769
plus 1 to n which is the right. So, divide
and conquer is a very simple minded strategy,

00:09:52.769 --> 00:09:59.730
you can only do one thing, you can solve this
and then, you can combine. So, this is the

00:09:59.730 --> 00:10:04.330
basic paradigm, so you have to divide, solve
the divided parts and combine.

00:10:04.330 --> 00:10:09.800
So, we will recursively assume that we can
count the inversions in left and right. Now,

00:10:09.800 --> 00:10:15.399
what is left to count are those inversions
which cross the boundaries. So, is there at

00:10:15.399 --> 00:10:20.750
j, i pair that is looks like this. This would
not be counted when I count only the left,

00:10:20.750 --> 00:10:24.149
because i is not in the left, it will not
be count only in the right, because j is not

00:10:24.149 --> 00:10:29.710
in the right. So, there would be an inversion
give i is less than j as numbers, but j appears

00:10:29.710 --> 00:10:33.480
in the left, i appears in the right.
So, this has to be done after we are solve

00:10:33.480 --> 00:10:36.990
the recursively, so this is basically the
combinations step, how many elements in the

00:10:36.990 --> 00:10:42.050
right are bigger than elements in the left.
Anything on the left, if it is smaller than

00:10:42.050 --> 00:10:46.510
something on the right, then it is not an
inversion, because it is already in the correct

00:10:46.510 --> 00:10:49.800
order in the overall list. But, it something
on the right is bigger than something on the

00:10:49.800 --> 00:10:54.540
left, then that is an inversion, we have to
count all such pairs.

00:10:54.540 --> 00:11:01.190
So, in order to solve this, we will make or
recursive procedure a little stronger than

00:11:01.190 --> 00:11:07.250
just counting. So, we will assume that not
only doings count in the two halves; we sort

00:11:07.250 --> 00:11:13.339
them well we were counting. So, what happens
is now we have divide our problem in two parts

00:11:13.339 --> 00:11:23.779
and then, we come back, so this is my L and
this is my R, I have now sorted L sorted R

00:11:23.779 --> 00:11:28.050
and I have a counter, so I have a count L
and a count R.

00:11:28.050 --> 00:11:34.510
Now, the factors these are sorted, means that
I can do some kind of merging. So, I can use

00:11:34.510 --> 00:11:39.620
a version of merge. So, we will describe a
version of merging which allows us to count.

00:11:39.620 --> 00:11:44.459
So, this gives as other count and then, we
have three counts the left count the right

00:11:44.459 --> 00:11:47.959
count and the count return by merge and so
what you want to a merging is to actually

00:11:47.959 --> 00:11:52.070
check how many elements on the right or bigger
than how many elements on the left.

00:11:52.070 --> 00:12:01.810
So, how do we do this? So, what is the principle
of merge and count? So, remember that an inversion

00:12:01.810 --> 00:12:10.520
across L and R consist of an element in R.
So, we have an element in R and an element

00:12:10.520 --> 00:12:21.600
in L, such that this number is smaller than
this number. So, we have some i here and some

00:12:21.600 --> 00:12:26.620
j here, such that i is smaller than j. So,
what will happen in a merge procedure is at

00:12:26.620 --> 00:12:32.019
some point, so we are merging, so we pick
the smaller of these two and pulled out.

00:12:32.019 --> 00:12:38.790
So, any time now if I had pulled out an element
from here; that means, at this current point

00:12:38.790 --> 00:12:44.709
I have merge up to this an up to this. So,
there are two pointers in my list left and

00:12:44.709 --> 00:12:49.389
right, sorted list, up to which the merged
is proceeded so far. Now, at this point I

00:12:49.389 --> 00:12:54.790
choose the right hand side element, because
it is smaller. So, if it is smaller than,

00:12:54.790 --> 00:12:58.010
it is smaller than everything which I not
yet looked at, that is why, because it is

00:12:58.010 --> 00:13:01.910
smaller than the first element I am looking
at in L. Therefore, smaller everything else

00:13:01.910 --> 00:13:05.070
in L, because everything else in L is sorted
with respect to this.

00:13:05.070 --> 00:13:11.490
So, therefore, this entire segment which is
left in L, corresponds to elements which are

00:13:11.490 --> 00:13:16.310
smaller than the current element am pulling
out from R. In other words, this element in

00:13:16.310 --> 00:13:21.510
R contributes as many inversion as there are
elements in L at the point when it is extracted

00:13:21.510 --> 00:13:29.950
in the merge process. So, whenever I add an
element from R to the output, it is inverted

00:13:29.950 --> 00:13:33.640
with respect to the all the elements currently
in L. So, I should add the current size of

00:13:33.640 --> 00:13:37.820
L to the number of inversions.
So, this gives as are merge and count, while

00:13:37.820 --> 00:13:41.420
we are merging, every time we pull from the
left, there is no inversion, every time pull

00:13:41.420 --> 00:13:46.540
in the right, we see how many elements are
still remaining in the left and that many

00:13:46.540 --> 00:13:51.230
items need to be added to our inversion part.

00:13:51.230 --> 00:13:56.850
So, here is a merge procedure for merge and
count which is very similar to the merge procedure

00:13:56.850 --> 00:14:05.170
in the basic merge sort. So, we had two list
A and B to be merged, both are sorted and

00:14:05.170 --> 00:14:09.990
A has m elements and B has n elements and
we want to produce an output list C, which

00:14:09.990 --> 00:14:17.850
has m plus n element. So, we begin with assigning
a pointer to tell us how far we have gone

00:14:17.850 --> 00:14:21.980
on each list, we just set as 0. And now, we
have to keep track of the number of inversions,

00:14:21.980 --> 00:14:25.980
so we keep a variable called count which is
initialized 0, the total number of inversions

00:14:25.980 --> 00:14:29.949
which have been seen so far.
So, along the something is there to move into

00:14:29.949 --> 00:14:35.820
C, we move something, so there are two cases,
the first cases to move from A. So, I have

00:14:35.820 --> 00:14:41.831
B is empty, j is equal to n are the element
of the head of A, A i is smaller than equal

00:14:41.831 --> 00:14:47.270
to B j in which case we do the usual think,
we copy the ith element of A into C k and

00:14:47.270 --> 00:14:51.709
then, we increment both i and k. The other
cases when either A is an empty, i is equal

00:14:51.709 --> 00:14:58.110
to m or B j as a smaller value, in this case
we have possibly an inversion.

00:14:58.110 --> 00:15:03.279
So, how many inversions do we have, we have
exactly m minus i inversions, we have as many

00:15:03.279 --> 00:15:08.649
inversions as so this is i, we have as many
inversions as are elements currently in A,

00:15:08.649 --> 00:15:14.820
which is m minus i. Now, notices that in the
specific case where we are copying from B,

00:15:14.820 --> 00:15:20.329
because A is empty, we have i equal to m.
So, this would actually be 0. So, they should

00:15:20.329 --> 00:15:23.790
not be an inversion, if they are just duplicating
B and C, because A is exhausted.

00:15:23.790 --> 00:15:28.910
So, that is also taken care of the m minus
i being 0, so although we are updating the

00:15:28.910 --> 00:15:32.910
count, we are assuming not adding in it. So,
only we are doing an nontrivial merge that

00:15:32.910 --> 00:15:37.060
is when we are moving something from B, when
A is still not empty do we increment the count,

00:15:37.060 --> 00:15:41.079
we are moving because we are run out the elements
in a count to remains these same. So, the

00:15:41.079 --> 00:15:46.940
end of this merge procedure, we return these
number of inversions we saw plus the merge

00:15:46.940 --> 00:15:47.940
list.

00:15:47.940 --> 00:15:53.759
So, now, we incorporate or merge procedure
into the merge sort with counting as follows.

00:15:53.759 --> 00:15:58.970
As usual, we will sort in general an array
from some left index to some right index,

00:15:58.970 --> 00:16:03.400
because we would sort different segments at
different times. So, if the current segment

00:16:03.400 --> 00:16:08.500
is to be sorted as length 1, then there is
nothing to be done, we just set up a new,

00:16:08.500 --> 00:16:12.910
the sorted segment is just the value that
we see and there is no inversion, because

00:16:12.910 --> 00:16:16.519
there is only one value.
On the other hand, if it is bigger than 1,

00:16:16.519 --> 00:16:19.920
then we compute the midpoint and we do these
two recursive calls, each of them will return

00:16:19.920 --> 00:16:26.040
the count on the left and right respectively,
then we call or merge procedure and get a

00:16:26.040 --> 00:16:32.130
count from the merge section. So, then our
total number of inversions is the count from

00:16:32.130 --> 00:16:37.480
the left and the right count from the merge
together and the new array is the one return

00:16:37.480 --> 00:16:42.199
by the merge. So, this is the very simple
extension of merge sort which allows us to

00:16:42.199 --> 00:16:46.839
count inversions which is useful for a recommendations
system.

00:16:46.839 --> 00:16:51.230
So, the analysis of course, given that the
structure resources is similar to merge sort,

00:16:51.230 --> 00:16:57.210
the analysis is similar, we have this recursion
for the time taken on n steps. So, T of 1

00:16:57.210 --> 00:17:02.540
is 1 and T of n is 2 times T n by 2 plus n
exactly. So, merge sort because it only take

00:17:02.540 --> 00:17:07.189
as a linear time to merge sort with count.
So, you merge with count it takes a same amount

00:17:07.189 --> 00:17:12.710
of time as merging without counted, so we
solve this and we get n log n.

00:17:12.710 --> 00:17:18.079
Now, an important think to note is when we
did are Brute force calculation, we looked

00:17:18.079 --> 00:17:22.240
at every possible pair and decided whether
are not it is an inversion, so they actually

00:17:22.240 --> 00:17:27.370
explicitly counted the inversions to get the
answer. Now, here we are doing it an n log

00:17:27.370 --> 00:17:31.250
n which is potentially much smaller than the
number of inversion you want to get. So, we

00:17:31.250 --> 00:17:36.580
are actually counting the number of inversions
or estimating or actually calculating how

00:17:36.580 --> 00:17:40.080
many inversions are there without actually
counting them manually one by one. Because,

00:17:40.080 --> 00:17:44.490
they could be a n squared inversions, but
use there are n squared inversions, we could

00:17:44.490 --> 00:17:50.210
find that out in n log n time. So, we not
manually counting every step, rather we are

00:17:50.210 --> 00:17:53.120
getting this through a recursive calculation.

