WEBVTT
Kind: captions
Language: en

00:00:00.780 --> 00:00:07.470
So, recall that our goal is to implement a
priority queue.

00:00:07.470 --> 00:00:11.730
In a priority queue, we have a sequence of
jobs that keeps entering the system, each

00:00:11.730 --> 00:00:13.500
job has a priority.

00:00:13.500 --> 00:00:18.100
Whenever, we are ready to schedule a job to
execute, we must pick up not the latest job

00:00:18.100 --> 00:00:22.740
or the earliest job that we got, but the job
which currently has the highest priority among

00:00:22.740 --> 00:00:23.740
the waiting jobs.

00:00:23.740 --> 00:00:28.060
Therefore, we need an operation called delete
max which will search for the highest priority

00:00:28.060 --> 00:00:30.230
job among those that are pending and schedule
it next.

00:00:30.230 --> 00:00:35.180
And we obviously, have an insert operation
which adds these jobs dynamically as they

00:00:35.180 --> 00:00:36.180
arrive.

00:00:36.180 --> 00:00:42.039
So, we saw last time that a linear structure
will not allow us to simultaneously optimize

00:00:42.039 --> 00:00:43.070
these two.

00:00:43.070 --> 00:00:48.510
We end up with an order N operation for delete
max or an order N operation for insert.

00:00:48.510 --> 00:00:53.979
Then, we saw trivial two dimensional array
which gives us an N root N solution that is

00:00:53.979 --> 00:00:58.309
the root N operation for each of these, so
over N operations is order N root N.

00:00:58.309 --> 00:01:03.550
But, we said that we will find a much better
data structure using a tree of a special type

00:01:03.550 --> 00:01:04.640
called a heap.

00:01:04.640 --> 00:01:10.180
So, the heap is going to be a balance tree
whose height is logarithmic in the size that

00:01:10.180 --> 00:01:14.640
is if have N nodes in the tree, the height
that is the number of edges from the root

00:01:14.640 --> 00:01:20.030
to any leaf will be log N. And with this,
it will turn out the both insert and delete

00:01:20.030 --> 00:01:25.520
max are proportional to log N and therefore,
processing N jobs will take time N log N as

00:01:25.520 --> 00:01:30.270
supposed to N root N for the array or N square
for the linear representation.

00:01:30.270 --> 00:01:34.770
We also said that this heap in principle is
flexible and can grow as large as we want.

00:01:34.770 --> 00:01:39.659
So, we do not have to fix in advance the size
of the heap that we need to keep.

00:01:39.659 --> 00:01:43.750
So, let us start looking first at what a heap
is.

00:01:43.750 --> 00:01:51.479
So, a binary tree is a tree where we have
a root and every node has 0, 1 or 2 children.

00:01:51.479 --> 00:01:55.060
So, binary trees in general can have arbitrary
shapes.

00:01:55.060 --> 00:01:58.979
So, we could have binary trees which look
like this, where the root has 1 child, this

00:01:58.979 --> 00:02:04.070
has 2 children or it could look even more
skewed in one direction.

00:02:04.070 --> 00:02:09.880
So, binary trees can have very strange shapes,
but a heap is a binary tree which has a very

00:02:09.880 --> 00:02:14.790
specific shape, where we fill up the tree
nodes or we add the tree nodes in a specific

00:02:14.790 --> 00:02:15.790
order.

00:02:15.790 --> 00:02:19.989
So, first we start at the root, then we must
add the left child of the root, then the right

00:02:19.989 --> 00:02:22.620
child and this way keep going level by level
left to right.

00:02:22.620 --> 00:02:25.580
So, we add this node, then we add this node,
then we add this node.

00:02:25.580 --> 00:02:30.040
So, once I know how many nodes are there in
the tree, I know precisely what the shape

00:02:30.040 --> 00:02:32.190
is, so the shape is fixed.

00:02:32.190 --> 00:02:41.511
So, that is the first feature of the heap
that if I have a heap with n nodes, then the

00:02:41.511 --> 00:02:46.310
shape of the tree is deterministically fixed
by this rule that the n nodes must be inserted

00:02:46.310 --> 00:02:50.540
top to bottom, left to right, then we have
a value property.

00:02:50.540 --> 00:02:52.849
So, the value property says that...

00:02:52.849 --> 00:02:57.680
So, what does happening in the tree is that
we have nodes and each nodes has a value,

00:02:57.680 --> 00:03:04.430
so whenever I see a node with value v 1 which
has children v 2 and v 3, then what we want

00:03:04.430 --> 00:03:09.459
is, this is bigger than or equal to v 2 and
bigger than or equal to v 3.

00:03:09.459 --> 00:03:13.680
So, among these three nodes the largest one
must be v 1, so this is what is called the

00:03:13.680 --> 00:03:14.909
max heap property.

00:03:14.909 --> 00:03:18.939
So, this is the local property, it just tells
us at every node look at that node, look at

00:03:18.939 --> 00:03:24.230
the 2 children, the node must be bigger than
it is 2 children.

00:03:24.230 --> 00:03:29.520
So, here is an example of the heap with 4
nodes, so first because it is 4 nodes, every

00:03:29.520 --> 00:03:30.870
4 node heap will have the shape.

00:03:30.870 --> 00:03:35.819
Because, the first node will be the root,
the second will be the roots left child, third

00:03:35.819 --> 00:03:38.900
node will be the right child and the fourth
node will start a new line, then more over

00:03:38.900 --> 00:03:40.530
we can check the heap property.

00:03:40.530 --> 00:03:44.909
So, we see the 24 is bigger than 11, 24 is
bigger than 7.

00:03:44.909 --> 00:03:50.950
So, this is a valid node for a heap property,
11 is bigger than 10 there is no right child,

00:03:50.950 --> 00:03:54.150
so this is a valid heap, there is no child
of 7 at all.

00:03:54.150 --> 00:03:58.970
So, by trivially this is a valid heap node
and 10 is the valid heap node for the same

00:03:58.970 --> 00:03:59.970
reason.

00:03:59.970 --> 00:04:10.079
So, every leaf node which has no children
always satisfies the heap property.

00:04:10.079 --> 00:04:14.920
So, once you have a leaf node, then nothing
to check.

00:04:14.920 --> 00:04:19.979
So, here is another heap, this one has 7 nodes,
so again the shape is fixed and again you

00:04:19.979 --> 00:04:25.840
can check that this is bigger than 11 and
7, 11 is bigger than 10 and 5 and 7 is bigger

00:04:25.840 --> 00:04:29.740
than 6 and 5 and the rest are all leaf node,
so there is no problem.

00:04:29.740 --> 00:04:31.770
So, these are two examples of heaps.

00:04:31.770 --> 00:04:35.729
So, what is an example of something that is
not a heap?

00:04:35.729 --> 00:04:39.360
So, here we have something which is not a
heap, because the structure is wrong.

00:04:39.360 --> 00:04:43.800
So, we said that you cannot leaf holes, you
must go top to bottom left to right, so there

00:04:43.800 --> 00:04:46.919
should be some node here, before you add the
node in the right.

00:04:46.919 --> 00:04:48.180
So, where is this node?

00:04:48.180 --> 00:04:50.970
This node is missing, so this structure is
not right.

00:04:50.970 --> 00:04:57.400
For the same reason, this structure is also
not correct, because we have here something

00:04:57.400 --> 00:05:01.500
which is missing, a node at this level and
we started a new line.

00:05:01.500 --> 00:05:06.190
So, both of these are not a heaps for structural
reasons.

00:05:06.190 --> 00:05:09.600
Here on the other have, we saw something which
is a valid structure, in fact we saw heap

00:05:09.600 --> 00:05:12.750
before which has the structure, the problem
is with this node.

00:05:12.750 --> 00:05:17.410
So, we want 7 to be bigger than 8 and 5, but
this is of course, not case.

00:05:17.410 --> 00:05:20.169
7 is not bigger than 8, 7 is smaller than
8.

00:05:20.169 --> 00:05:24.759
So, this node 8 actually violates the heap
property, so something can fail to be a heap,

00:05:24.759 --> 00:05:30.181
either because the tree structure is wrong
or because at some node the heap property

00:05:30.181 --> 00:05:31.181
is violated.

00:05:31.181 --> 00:05:34.410
In this case, node that violates the heap
property is 7, because one of it is children

00:05:34.410 --> 00:05:38.710
are actually bigger than the node itself.

00:05:38.710 --> 00:05:43.810
So, now we have to implement these two operations
on heaps, insert and delete max.

00:05:43.810 --> 00:05:46.120
So, let us see how it works?

00:05:46.120 --> 00:05:51.681
So, first let us insert 12, so insert 12 means
I have to add a value to the heap.

00:05:51.681 --> 00:05:55.270
So, the first thing when I add a value to
the heap is I must expand a tree.

00:05:55.270 --> 00:05:57.710
So, where do I put this node?

00:05:57.710 --> 00:06:02.400
So, this is now fixed because we know that
heaps can only grow and shrink in a particular

00:06:02.400 --> 00:06:07.310
way, so I must add the new node left to right,
top to bottom.

00:06:07.310 --> 00:06:12.900
So, in this case if I go left to right, top
to bottom I come to this point, now I cannot

00:06:12.900 --> 00:06:15.520
add anything more, so it must come at the
next level.

00:06:15.520 --> 00:06:20.360
So, the first thing is that this is where
the new node must come to contain 12.

00:06:20.360 --> 00:06:26.080
Now, if I put 12 into this position, the problem
is that I might not have the heap properties

00:06:26.080 --> 00:06:27.080
satisfy.

00:06:27.080 --> 00:06:31.000
In this case, you can see that the heap property
actually fails right here, because 12 is bigger

00:06:31.000 --> 00:06:32.650
than it is parent.

00:06:32.650 --> 00:06:38.830
So, 10 violates the heap property, but notice
that this can only happen above, so what I

00:06:38.830 --> 00:06:41.509
mean is that when you insert something it
is a leaf.

00:06:41.509 --> 00:06:45.789
So, when you since 12 is a leaf, it cannot
fail the heap property below 12, because there

00:06:45.789 --> 00:06:47.390
is no child below 12.

00:06:47.390 --> 00:06:52.060
If at all the property fails, it is because
the parent of the new node has a value which

00:06:52.060 --> 00:06:53.100
is too small.

00:06:53.100 --> 00:06:57.670
So, there is a simple way of fix this locally
at least and that is to exchange these two.

00:06:57.670 --> 00:07:03.800
So, I exchange this 12 and 10 and now I fix
the problem here, but now I change the value

00:07:03.800 --> 00:07:04.800
at this point.

00:07:04.800 --> 00:07:10.560
So, I have to look at this configuration to
see whether what I move the 12 into violates

00:07:10.560 --> 00:07:16.330
heap property or not and here again you can
see that there is a problem because 12 is

00:07:16.330 --> 00:07:18.690
still bigger than its parent.

00:07:18.690 --> 00:07:24.800
So, then I exchange that, so now I exchange
this, now in the process what is happened

00:07:24.800 --> 00:07:28.050
is that well was gone from here to here.

00:07:28.050 --> 00:07:33.770
And now, the first thing we have to convince
ourselves is that the heap that we local heap

00:07:33.770 --> 00:07:36.710
property that we just fixed does not need
any further fixing.

00:07:36.710 --> 00:07:41.900
In other words, we have to guaranty that there
is no problem and the other side between 12

00:07:41.900 --> 00:07:48.419
and 5 and this cannot happen, because we originally
had 11, 5 and something here, we knew that

00:07:48.419 --> 00:07:53.690
11 was bigger than 5 and it to bigger than
the something, then we did an exchange and

00:07:53.690 --> 00:07:55.040
be bought at 12 here.

00:07:55.040 --> 00:07:59.639
So, if at all the problems is only would between
11 and 12 and since if there is a violation

00:07:59.639 --> 00:08:03.599
12 is bigger than a 11 that is why there is
a violation, but 11 is known to be bigger

00:08:03.599 --> 00:08:04.599
than the other side.

00:08:04.599 --> 00:08:12.330
So, if I move 12 to the top of this three
node structure, it cannot be smaller than

00:08:12.330 --> 00:08:13.330
other side.

00:08:13.330 --> 00:08:16.110
Because, the root currently is already bigger
than the other side, the only reason I move

00:08:16.110 --> 00:08:18.500
12 of this because it is still bigger than
that side.

00:08:18.500 --> 00:08:24.200
So, then in a nutshell when I do and upward
swap like this I can be sure that do not have

00:08:24.200 --> 00:08:27.020
to look on the other side I just keep looking
up.

00:08:27.020 --> 00:08:32.490
So, now I got 12 up to this point, so now
I need to check whether there is any further

00:08:32.490 --> 00:08:35.610
violation and it turns out the 12 is smaller
than 24.

00:08:35.610 --> 00:08:41.920
So, I can stop, so this was the result of
inserting 12 into this heap.

00:08:41.920 --> 00:08:47.030
Now, I can insert a new node 33 just to convince
ourselves we know what to do, so as before

00:08:47.030 --> 00:08:48.110
if I insert 33.

00:08:48.110 --> 00:08:53.000
So, this was the result of the heap after
12 and now I have inserted a 33 here, so it

00:08:53.000 --> 00:08:56.860
has to be the right because that is a next
node in the structure and I put the value,

00:08:56.860 --> 00:09:01.910
but it violates the heap property between
11 and 33, so I swap it up.

00:09:01.910 --> 00:09:05.570
And then again I have a violation here, so
I swap it up again.

00:09:05.570 --> 00:09:08.820
Again I have a violation here, so I swap it
up again.

00:09:08.820 --> 00:09:15.800
And now I reach the root, so actually it is
become the biggest node and now I can stop.

00:09:15.800 --> 00:09:18.140
So, how long does this take?

00:09:18.140 --> 00:09:22.690
So, every time we saw every time we do an
insert, we start at a leaf node a new leaf

00:09:22.690 --> 00:09:25.270
node that we create and we walk up to the
root.

00:09:25.270 --> 00:09:29.770
So, the worst case of such a thing it depend
on the worst case height of the tree, we have

00:09:29.770 --> 00:09:33.700
to bound the height of the tree, the height
of the tree by definition if I have a tree

00:09:33.700 --> 00:09:34.780
like this.

00:09:34.780 --> 00:09:40.410
So, the height of the tree is a longest such
path, the length of the longest path from

00:09:40.410 --> 00:09:41.710
the root to the node.

00:09:41.710 --> 00:09:47.220
So, we can either counted terms of number
of edges or in number of vertices is with

00:09:47.220 --> 00:09:50.660
vertices this one would be 4, if it is edges
it will be 3 does not really matter, but the

00:09:50.660 --> 00:09:54.780
point is that the longest such path will determine
the complexity, because the longer the path

00:09:54.780 --> 00:09:57.080
the more times I am in need to swap on the
via.

00:09:57.080 --> 00:10:04.110
So, what can say about the height of the heap,
so the first thing to notice is that in a

00:10:04.110 --> 00:10:06.840
heap because of the way that we are done it.

00:10:06.840 --> 00:10:17.720
So, at the root node we have at level 0 we
call this level 0, we have exactly one node

00:10:17.720 --> 00:10:20.760
at level 1 at most we have 2 nodes.

00:10:20.760 --> 00:10:26.320
So, we can write is as 2 to the power of 0,
this is 2 to the power 1 of course, each of

00:10:26.320 --> 00:10:27.320
these will have 1.

00:10:27.320 --> 00:10:31.280
So, we will double, so at every level the
number of nodes doubles, because each of the

00:10:31.280 --> 00:10:33.250
previous level has two children at most.

00:10:33.250 --> 00:10:36.570
So, we have two square, so in this way we
have number of nodes at level 0 is 2 to the

00:10:36.570 --> 00:10:42.430
power of 0 at level 1 is 2 to the power 1
at any level i is 2 to the power i.

00:10:42.430 --> 00:10:50.100
So, if you have k levels, then the levels
are 0, 1 up to k minus 1 from what we just

00:10:50.100 --> 00:10:55.360
said that is 2 to the 0 plus 2 to the 1 plus
2 to the k, the k minus 1, sorry.

00:10:55.360 --> 00:11:02.600
So, it will be 2 to the 0 plus 2 to the 1
plus 2 to the k minus 1, now this and one

00:11:02.600 --> 00:11:09.080
way to think about it this is a binary number
with k 1s.

00:11:09.080 --> 00:11:16.140
So, binary number k 1s is just 2 to the power
k minus 1, in other wards if I fill up a binary

00:11:16.140 --> 00:11:20.800
tree for k levels I will have at most 2 to
the k minus 1 nodes.

00:11:20.800 --> 00:11:26.600
So, therefore, the number of nodes is exponential
in number of levels.

00:11:26.600 --> 00:11:31.700
So, therefore, if I have the number of nodes
in the number of levels must be logarithmic

00:11:31.700 --> 00:11:32.700
in that.

00:11:32.700 --> 00:11:36.100
And the number of levels is what determines,
the logarithmic length of the longest path

00:11:36.100 --> 00:11:40.860
and therefore, insert an any heap will take
time log of N, because there is every path

00:11:40.860 --> 00:11:45.640
is going to be guaranty to be of height log
N.

00:11:45.640 --> 00:11:53.040
So, the other operation that we need to implement
for a priority queue is to delete the maximum.

00:11:53.040 --> 00:11:57.310
So, the first question is where is the maximum
in a heap?

00:11:57.310 --> 00:12:02.520
So, the claim is that the maximums always
at the root, why is that because if I start

00:12:02.520 --> 00:12:06.110
anywhere I know that among the any 3 nodes
the maximum is that the top.

00:12:06.110 --> 00:12:15.580
So, if I look at 33 for example, 33 is bigger
than 24 and 7, but inductively I know that

00:12:15.580 --> 00:12:21.310
24 must be the biggest node in this sub tree
and 7 must be the biggest node in the sub

00:12:21.310 --> 00:12:22.310
tree.

00:12:22.310 --> 00:12:26.380
So, therefore, 34 is 33 bigger than both it
must be the biggest node overall in this entire

00:12:26.380 --> 00:12:27.380
tree.

00:12:27.380 --> 00:12:31.170
So, the module is the mod 3 maximum values
already at the root.

00:12:31.170 --> 00:12:37.060
So, now the question is if the maximum values
at the root, how do we remove it from the

00:12:37.060 --> 00:12:40.060
tree efficiently.

00:12:40.060 --> 00:12:46.810
So, let say you remove the maximum value,
so then this leaves us with a hole, we do

00:12:46.810 --> 00:12:51.910
not have any value at the root now, at the
same time because we have removed the value

00:12:51.910 --> 00:12:54.800
we have reduce the number of values in the
tree by one.

00:12:54.800 --> 00:12:59.090
But, we said that the structure of the tree
is fixed, if you reduced by one we cannot

00:12:59.090 --> 00:13:03.470
remove the root, we must remove the last node
going on this left to right top to bottom

00:13:03.470 --> 00:13:04.470
order.

00:13:04.470 --> 00:13:12.490
So, we must in fact to remove the node here
this node as to go, so now we have a value

00:13:12.490 --> 00:13:17.450
which is homeless, it does not have a root
node to belong to and we have a home which

00:13:17.450 --> 00:13:18.450
is empty.

00:13:18.450 --> 00:13:24.710
So, what we will do is we will move this 11
to the root.

00:13:24.710 --> 00:13:31.500
Now, unfortunately because we are disrupt
the heap order by doing this taking some arbitrary

00:13:31.500 --> 00:13:35.600
node from leaf moving into the root, we do
not know whether we have the heap property

00:13:35.600 --> 00:13:36.600
satisfied or not.

00:13:36.600 --> 00:13:39.970
Now, the only place where the heap property
can be violated at the root, because everywhere

00:13:39.970 --> 00:13:44.250
else the local neighborhood was not touched
by this operation, you only other place their

00:13:44.250 --> 00:13:47.100
neighborhood was touch to is here, but always
did was remove a node.

00:13:47.100 --> 00:13:51.370
If you remove a leaf then it cannot violate
a heap property, because for the upper node

00:13:51.370 --> 00:13:53.450
it is already bigger than both this tree.

00:13:53.450 --> 00:13:58.060
So, this okay, So, the only place we could
have a violation is here and indeed we do,

00:13:58.060 --> 00:14:02.440
because 11 and 24 on the wrong order.

00:14:02.440 --> 00:14:08.660
So, we will start now the storing the heap
property downwards, when we inserted we did

00:14:08.660 --> 00:14:12.300
upstairs, it start here and look at this and
then we will look at both directions and we

00:14:12.300 --> 00:14:14.970
take of the bigger one of the two and move
it up.

00:14:14.970 --> 00:14:22.310
So, we swap with the largest child, suppose
for instance that this had been not 7, but

00:14:22.310 --> 00:14:27.310
17 then what could have happened, if you are
move 17 up his viewed about 17 the 11 and

00:14:27.310 --> 00:14:33.310
24 and this would not a fix the heap property,
because this would still be wrong.

00:14:33.310 --> 00:14:37.160
So, we must take the bigger of the two and
move it up, because among these three the

00:14:37.160 --> 00:14:41.580
biggest value must be at the top that is the
definition of the max heap property, so we

00:14:41.580 --> 00:14:43.340
exchange the 11 and the 24.

00:14:43.340 --> 00:14:49.700
So, 24 goes up to the root and then 11 has
come in this direction, so we must again check

00:14:49.700 --> 00:14:54.790
whether this part which has now been disturbed
satisfies the heap property.

00:14:54.790 --> 00:14:58.800
And of course, in this case it does not because
11 and 12 are not in the correct thing.

00:14:58.800 --> 00:15:03.240
So, again among these 3 I have to take the
maximum value up, so I take the 12 up and

00:15:03.240 --> 00:15:05.740
move the 11 down.

00:15:05.740 --> 00:15:08.735
And now I have to check this section whether
this heap property is satisfied, here it is

00:15:08.735 --> 00:15:11.270
satisfied now we want stop.

00:15:11.270 --> 00:15:16.640
So, in delete max I start from the root and
I walk downwards.

00:15:16.640 --> 00:15:24.260
So, supposing we do this again, then I remove
24.

00:15:24.260 --> 00:15:28.670
And then I move the 10 from the last leaf
to the top.

00:15:28.670 --> 00:15:34.330
Then, I again have to fix this problem, so
I exchange the 10 and the 12.

00:15:34.330 --> 00:15:38.540
Then, I have to look at this and fix these
problems the biggest of this trees is 11 I

00:15:38.540 --> 00:15:41.060
fix the 10 and the 11 and I get it.

00:15:41.060 --> 00:15:45.100
So, now by making sure that I take the biggest
one of again I do not walk down the other

00:15:45.100 --> 00:15:46.100
directions.

00:15:46.100 --> 00:15:51.950
So, I am always walking down as single path,
so once again just like insert the cost is

00:15:51.950 --> 00:15:53.760
proportional to the height.

00:15:53.760 --> 00:15:57.990
And since we know that in a heap the height
is logarithmic, delete max is also an order

00:15:57.990 --> 00:16:00.750
log N operation.

00:16:00.750 --> 00:16:07.240
So, what we have done is, we have shown that
a heap actually does both delete max and insert

00:16:07.240 --> 00:16:08.240
in log N time.

00:16:08.240 --> 00:16:13.170
Now, and other very nice property about heaps
is that we do not actually need to maintain

00:16:13.170 --> 00:16:18.970
a very complex tree likes structure, we can
actually do heaps in arrays to do this we

00:16:18.970 --> 00:16:25.580
observe that we can canonically number all
the nodes in a heap, we start number in the

00:16:25.580 --> 00:16:30.161
root by 0, the first node we fill below the
root by 1, the other child 2 and so on.

00:16:30.161 --> 00:16:35.660
So, I have a numbering 0, 1, 2, so I can actually
represent this heap as an arrays heap which

00:16:35.660 --> 00:16:40.420
has this is 0, 1, 2 and so on.

00:16:40.420 --> 00:16:47.540
Now, in this the claim is if I am at a position
i, so if I have some position i, then the

00:16:47.540 --> 00:16:54.370
children of this are 2 i plus 1 and 2 i plus
2 you can check this everywhere.

00:16:54.370 --> 00:17:00.060
So, therefore, if I want to actually go to
a heap and ask something about the heap property,

00:17:00.060 --> 00:17:05.220
then I will just look at the position i, then
I will jump ahead to position 2 i plus 1 and

00:17:05.220 --> 00:17:06.569
2 i plus 2.

00:17:06.569 --> 00:17:12.010
So, completely using the array alone within
the array I can look up the children of a

00:17:12.010 --> 00:17:18.160
node and by inverting this operation, if I
look at j minus 1 by 2 and take the floor

00:17:18.160 --> 00:17:19.660
of that then I will come backwards.

00:17:19.660 --> 00:17:26.230
So, with the child is 2 i plus 1 2 i plus
2 then the parent is j minus 1 by 2 and then

00:17:26.230 --> 00:17:28.190
it might be fractional, so take the integer
parts.

00:17:28.190 --> 00:17:32.510
So, floor means take the integer part of j
minus 1 by 2.

00:17:32.510 --> 00:17:37.460
So, this is not j minus half, so it has j
minus 1 the whole by 2.

00:17:37.460 --> 00:17:47.330
So, for example, for 12 j minus 1 is the 11,
the 11 by 2 is 5 and half floor of that is

00:17:47.330 --> 00:17:48.706
5, so the parent at 12 is 5.

00:17:48.706 --> 00:17:53.130
So, you can check that this is formed, so
therefore I can now do all my heap manipulation

00:17:53.130 --> 00:17:56.910
with in an array, which is very convenient
I just have to write an array and then whenever

00:17:56.910 --> 00:18:01.680
I do these operations which involve walking
up and down the heap I will just uses 2 i

00:18:01.680 --> 00:18:08.300
plus 1 2 i plus 2 formula what are use this
floor of j minus 1 by 2 formula.

00:18:08.300 --> 00:18:12.810
So, how do we start this whole process off?

00:18:12.810 --> 00:18:16.190
How do we build a heap from a given set of
values.

00:18:16.190 --> 00:18:22.050
So, a very naive strategy would work as follows
and given a set of values n values x 1 to

00:18:22.050 --> 00:18:23.050
x n.

00:18:23.050 --> 00:18:28.080
So, I start with an empty heap and then I
insert x 1, so I have a heap of size 1 then

00:18:28.080 --> 00:18:31.701
I insert x 2, so now I heap of size 2 and
so on.

00:18:31.701 --> 00:18:37.520
So, I do n inserts and each insert takes log
N time at most, so we will take less time

00:18:37.520 --> 00:18:41.430
we will take log i time if I have inserted
i items so far, so for but let us take log

00:18:41.430 --> 00:18:42.520
N as an upper bound.

00:18:42.520 --> 00:18:48.720
So, overall if I insert these N elements I
will build the heap also and N log N time.

00:18:48.720 --> 00:18:53.810
Now, in fact it turns out that there is a
better way to do this, so if I look at any

00:18:53.810 --> 00:19:00.160
array I can think of this as a heap I can
just imagine that it is ordered.

00:19:00.160 --> 00:19:06.670
Because, every array as a heap interpretation,
I can imagine that this is how the array looks,

00:19:06.670 --> 00:19:09.400
if I think of it the heap of course, it does
not satisfy the heap property.

00:19:09.400 --> 00:19:12.680
But, but this is how it would look if I arranged
as the heap.

00:19:12.680 --> 00:19:18.560
Now, in this anything which is at the leaf
level does not need to be check, because it

00:19:18.560 --> 00:19:22.540
has no children all leaves trivially satisfied
the heap property.

00:19:22.540 --> 00:19:26.313
So, I need to start fixing things only at
the previous level, so I walk back to this.

00:19:26.313 --> 00:19:32.540
So, I come here and x 3 I fix the heap property
with respective it is children, then at x

00:19:32.540 --> 00:19:36.230
2 at fix the property with respective each
children, in the process something a up and

00:19:36.230 --> 00:19:41.880
down to only one level, then I will come to
x 1 and I will fix it is problem, now this

00:19:41.880 --> 00:19:43.280
might involved 2 levels.

00:19:43.280 --> 00:19:47.680
So, for each level k minus 1 k minus 2 that
it.

00:19:47.680 --> 00:19:52.671
So, leaves are at level k at level k minus
1 k minus 2 on up to the root, we fix the

00:19:52.671 --> 00:19:53.750
heap property.

00:19:53.750 --> 00:20:01.060
So, as we go up fixing the heap property means,
walking down like we did for delete max, walking

00:20:01.060 --> 00:20:02.600
down to the leaf.

00:20:02.600 --> 00:20:09.300
So, each level we go up the length of this
path increases by 1, but because the levels

00:20:09.300 --> 00:20:12.010
double as we go down they have as we go up.

00:20:12.010 --> 00:20:16.490
So, the number of nodes for which we have
to check this extra length path goes down

00:20:16.490 --> 00:20:18.090
by factor of two.

00:20:18.090 --> 00:20:23.060
So, now if you do the analysis should we are
not going to do exactly, it turns out at in

00:20:23.060 --> 00:20:26.890
this process the number of updates you need
to make a heap is actually only order N.

00:20:26.890 --> 00:20:32.870
So, if you use this bottom up heapification,
then it will be an order N procedure.

00:20:32.870 --> 00:20:36.950
So, just to get a better picture of what is
going on, so let us assume that we had 15

00:20:36.950 --> 00:20:41.150
elements I had list and we actually through
it do it out like this and the clam is that

00:20:41.150 --> 00:20:46.800
these n minus 2 node n by 2 nodes, which is
roughly have it is actually 8 out of 15 already

00:20:46.800 --> 00:20:49.902
satisfied the heap property, so this is nothing
to be done.

00:20:49.902 --> 00:20:57.650
So, then I go one level up and I fix these,
when I fix these I have to do it for 4 nodes

00:20:57.650 --> 00:21:02.790
and each of them the repair will involve one
swap at most or no swaps, worst case it will

00:21:02.790 --> 00:21:04.530
all be one swap.

00:21:04.530 --> 00:21:09.430
Then, I will up one level and now for each
of these nodes I will have to possibly go

00:21:09.430 --> 00:21:12.630
down 2 paths of length 2.

00:21:12.630 --> 00:21:17.920
So, each of them will involve a height 2 repair
that is 2 step of thing better than all from

00:21:17.920 --> 00:21:21.020
4 nodes I have gone to 2 nodes.

00:21:21.020 --> 00:21:25.240
So, the only half as many nodes which required
only one step more.

00:21:25.240 --> 00:21:29.890
And then finally, when I go to the root I
might have to do kind of fix which involves

00:21:29.890 --> 00:21:32.720
swapping down to the last leaf, so 3 swaps.

00:21:32.720 --> 00:21:37.280
But, this only one node which does this, so
therefore since there is trade off that the

00:21:37.280 --> 00:21:41.530
number of nodes to be fix is halving and the
length is only increasing by one it turns

00:21:41.530 --> 00:21:45.930
out that this whole operand needs only order
N time.

00:21:45.930 --> 00:21:53.060
So, to summarize go to we have seen is that
heaps implement priority queues using special

00:21:53.060 --> 00:21:59.850
balance trees, in these tree both insert and
delete max are logarithmic we can use this

00:21:59.850 --> 00:22:03.580
bottom up heapify to actually build a heap
and order N time.

00:22:03.580 --> 00:22:08.640
And what is most useful is that this heap
can actually be manipulated very simply as

00:22:08.640 --> 00:22:14.200
an array, now one thing which we can do is
to invert the heap condition.

00:22:14.200 --> 00:22:20.800
So, we can say that whenever be see v 1, v
2 and v 3 we want v 1 to be smaller than both

00:22:20.800 --> 00:22:22.670
v 2 and v 3.

00:22:22.670 --> 00:22:26.660
So, this is what is called a min heap, what
we have been doing, so for is a max heap.

00:22:26.660 --> 00:22:31.200
So, sometimes you want to keep track of the
smallest priority and remove the smallest

00:22:31.200 --> 00:22:35.330
priority item, just think of how for example,
you rank people in an exam.

00:22:35.330 --> 00:22:40.070
So, you are somebody if in a competitive exam,
the smaller the rank the higher the priority.

00:22:40.070 --> 00:22:42.170
So, if you have rank 1 then you have highest
priority.

00:22:42.170 --> 00:22:45.970
So, this some situation it is natural to think
of smaller numbers is higher priority.

00:22:45.970 --> 00:22:50.430
So, you want have to do anything very much,
we just have to change the heap rule to be

00:22:50.430 --> 00:22:51.430
minimum.

00:22:51.430 --> 00:22:55.130
So, that the each node is smaller than its
two children and then everything would work

00:22:55.130 --> 00:22:56.760
exactly as we have done, so for.

00:22:56.760 --> 00:23:02.690
So, we have two types of heaps, you have max
heaps and you have min heaps and all the differs

00:23:02.690 --> 00:23:07.400
in max heaps and min heaps is the heap condition
on the nodes and the correspondingly whether

00:23:07.400 --> 00:23:10.120
the operation you implement is delete min
and delete max.

