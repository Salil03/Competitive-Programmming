WEBVTT
Kind: captions
Language: en

00:00:00.830 --> 00:00:07.450
So, we have seen two intuitive sorting algorithms;
selection sort, and insertion sort, but unfortunately

00:00:07.450 --> 00:00:11.280
for us, both of then turn out to be order
n square.

00:00:11.280 --> 00:00:16.290
And we know that order n square is not really
good enough for sorting large arrays.

00:00:16.290 --> 00:00:18.510
So, what can we do instead?

00:00:18.510 --> 00:00:24.460
So, here is one way to sort an array more
effectively.

00:00:24.460 --> 00:00:27.490
So, suppose we divide the array into two equal
parts.

00:00:27.490 --> 00:00:32.300
So, we just break it in the middle, we look
at the left separately and the right separately.

00:00:32.300 --> 00:00:38.420
Now assume that we can sort the left and right
into independently sorted halves.

00:00:38.420 --> 00:00:41.440
So, we have the left half sorted, the right
half sorted.

00:00:41.440 --> 00:00:46.700
Now if there is a way to combine the two halves
efficiently to get a fully sorted array, then

00:00:46.700 --> 00:00:52.100
we can say that we have achieved the sorting
by breaking it up into two smaller sub problems

00:00:52.100 --> 00:00:53.870
and combining the result.

00:00:53.870 --> 00:00:57.170
So, let us first look at this combining step.

00:00:57.170 --> 00:01:02.360
So, we are given two sorted lists A and B
or two sorted arrays A and B, and we want

00:01:02.360 --> 00:01:05.080
to combine them into a single sorted list.

00:01:05.080 --> 00:01:07.720
So, this is something that we can easily do.

00:01:07.720 --> 00:01:11.150
Supposing we have two stacks of cards in front
of us.

00:01:11.150 --> 00:01:15.170
Each of them is arranged in the same way in
ascending order.

00:01:15.170 --> 00:01:18.870
Then what we will do is we will look at the
top most cards in each stack, and take the

00:01:18.870 --> 00:01:21.420
smaller of the two, and move it to a new stack.

00:01:21.420 --> 00:01:26.480
And we could keep doing this, until eventually
we have moved all the elements into a new

00:01:26.480 --> 00:01:27.800
sorted stack.

00:01:27.800 --> 00:01:30.130
So, this is intuitively merging.

00:01:30.130 --> 00:01:31.870
So, I have two stacks.

00:01:31.870 --> 00:01:34.970
So, I have two stacks of cards, right.

00:01:34.970 --> 00:01:41.520
So, I look at the top most card in each, and
then one of them goes to a new stack.

00:01:41.520 --> 00:01:46.440
And then this is gone and so now I will look
at the next value, and compare it with this,

00:01:46.440 --> 00:01:48.040
and then one of these goes here and so on.

00:01:48.040 --> 00:01:52.380
So, eventually I build up a new stack of sorted
list.

00:01:52.380 --> 00:01:57.110
So, let us look at this in a very simple example.

00:01:57.110 --> 00:01:59.190
So, supposing we want to merge these two sorted
lists.

00:01:59.190 --> 00:02:03.600
So, this is sorted in ascending order and
so is this sorted in ascending order.

00:02:03.600 --> 00:02:06.570
So, the first step, is to look at the top
most.

00:02:06.570 --> 00:02:11.230
So, let us assuming that in terms of top most
these are written like this.

00:02:11.230 --> 00:02:14.880
So, I have this stack, and I have this stack.

00:02:14.880 --> 00:02:20.660
So, I look at the top most elements, and then
I say that the smaller of the two must be

00:02:20.660 --> 00:02:23.110
the top most element of my new stack.

00:02:23.110 --> 00:02:27.480
So, in this case I take 21 out, and I move
it here.

00:02:27.480 --> 00:02:31.861
Now I have to compare, what is the top most
elements in the two stacks; can be 32 and

00:02:31.861 --> 00:02:32.861
55.

00:02:32.861 --> 00:02:36.520
So, now, I compare the smaller of the 2 as
32 and move it out.

00:02:36.520 --> 00:02:42.709
Now I compare 55 and 74, and so 55 moves out,
and I compare 74 and 64.

00:02:42.709 --> 00:02:44.860
So, now 64 move out.

00:02:44.860 --> 00:02:48.841
Now I have nothing left in the second stack,
so the first stack is in sorted order, so

00:02:48.841 --> 00:02:50.290
I just copy it out in order.

00:02:50.290 --> 00:02:53.410
So, first I moves 74 and then I move 89.

00:02:53.410 --> 00:02:57.890
So, this is a very intuitively merging thing
that we do again quite naturally when we are

00:02:57.890 --> 00:03:03.830
dealing with physically two sorted lists,
and we can do it with a normal array as well.

00:03:03.830 --> 00:03:06.709
So, now, how do we use this to sort.

00:03:06.709 --> 00:03:11.800
As we said our aim is to break up problem
into two equal sub problems.

00:03:11.800 --> 00:03:15.540
Solve the sub problems, and there merge the
two solution into a final solution.

00:03:15.540 --> 00:03:21.730
So, we will sort A 0 to A n by 2 A n by 2
n minus 1 to make it distinct.

00:03:21.730 --> 00:03:26.230
So, we have A with indices 0 to n minus 1.

00:03:26.230 --> 00:03:31.840
So, we take n by 2 minus 1 and n by 2 as the
midpoint.

00:03:31.840 --> 00:03:37.210
So, we sort this separately, we sort this
separately, and then we merge them.

00:03:37.210 --> 00:03:42.489
So, this is the strategy that we have, and
this is since the final step involves merging

00:03:42.489 --> 00:03:43.640
two solutions.

00:03:43.640 --> 00:03:46.660
This is quite naturally called merge sort.

00:03:46.660 --> 00:03:50.710
Now I have said that we will break up the
thing into two sub problems.

00:03:50.710 --> 00:03:51.760
So, how do I solve this.

00:03:51.760 --> 00:03:53.750
Well I will recursively do the same thing.

00:03:53.750 --> 00:03:57.300
I will break this up into two sub problems,
and I will merge this.

00:03:57.300 --> 00:04:00.250
I will break this up into two sub problems
and merge this.

00:04:00.250 --> 00:04:06.310
So, you keep breaking up the thing into sub
problems, until you reach a trivial sub problem,

00:04:06.310 --> 00:04:09.430
which is as we have seen, which is an array
of size of 1.

00:04:09.430 --> 00:04:12.160
So, let us look at an example before we proceed.

00:04:12.160 --> 00:04:15.630
So, here is an example of an array that we
would like to sort.

00:04:15.630 --> 00:04:18.339
So, the first step is to break it up into
two parts.

00:04:18.339 --> 00:04:19.930
So, we take the left part.

00:04:19.930 --> 00:04:21.319
So, this is a midpoint.

00:04:21.319 --> 00:04:26.650
So, we take the left part, which is the first
four elements, and the right part.

00:04:26.650 --> 00:04:30.289
And now we will apply merge sort separately
to these part; finally, we will merge the

00:04:30.289 --> 00:04:31.289
answer.

00:04:31.289 --> 00:04:34.400
So, having applying merge sort to the left
part, you must again break it up into two

00:04:34.400 --> 00:04:35.400
parts.

00:04:35.400 --> 00:04:38.169
I will have to take this point and divide
it into two parts.

00:04:38.169 --> 00:04:43.889
And similarly on the right, I will have to
take this point, and divide it into two parts.

00:04:43.889 --> 00:04:50.159
Now we could say that we can easily do arrays
of size two, but let us just keep going till

00:04:50.159 --> 00:04:51.180
we reach the base case.

00:04:51.180 --> 00:04:54.389
The base case is when we have only one element
and no sorting is required.

00:04:54.389 --> 00:04:58.139
We will against split each of these into two
parts.

00:04:58.139 --> 00:05:02.740
So, notice that for convenience we have taken
something where I can keep dividing by 2,

00:05:02.740 --> 00:05:05.550
but there is no limitation in merge sort,
it will work for any size.

00:05:05.550 --> 00:05:09.930
At some point when you do an unequalâ€™s split,
the two halves will not be the same size,

00:05:09.930 --> 00:05:12.129
but that does not really matter.

00:05:12.129 --> 00:05:13.940
Now we break the last step into two parts.

00:05:13.940 --> 00:05:15.509
So, 43 is now.

00:05:15.509 --> 00:05:20.569
So, this is in green to indicate that this
is now a single element and hence sorted,

00:05:20.569 --> 00:05:21.569
so is this.

00:05:21.569 --> 00:05:27.749
And in the same way we can take each of these
last steps and get now 8 single elements,

00:05:27.749 --> 00:05:29.180
which are sorted.

00:05:29.180 --> 00:05:30.180
Now we start merging.

00:05:30.180 --> 00:05:35.599
So, we want to merge these two, in order to
sort, and similarly we want to merge these

00:05:35.599 --> 00:05:36.599
two.

00:05:36.599 --> 00:05:39.629
We want to merge these two, and we want to
merge these two.

00:05:39.629 --> 00:05:44.349
So, we merge first two, and then we merge
this, the smaller one goes first.

00:05:44.349 --> 00:05:46.400
So, this is now sorted.

00:05:46.400 --> 00:05:50.400
Similarly we merge the second pair, it does
not change in order, because 22 is smaller

00:05:50.400 --> 00:05:51.639
than 78.

00:05:51.639 --> 00:05:56.340
We merge the third pair and they get exchanged,
and we merge the fourth pair again they get

00:05:56.340 --> 00:05:57.340
exchanged.

00:05:57.340 --> 00:06:00.289
There is an important note that exchange did
not come by looking at array of size 2 directly,

00:06:00.289 --> 00:06:04.930
but rather by looking at these two value,
taking the smaller one first then the bigger

00:06:04.930 --> 00:06:05.930
one.

00:06:05.930 --> 00:06:11.119
Now I want to merge these two arrays into
a sorted segment of length 4, and these two

00:06:11.119 --> 00:06:12.960
arrays into a sorted segment of length 4.

00:06:12.960 --> 00:06:14.110
So, I again apply merging.

00:06:14.110 --> 00:06:20.280
So, note that 22 will come first then 32 will
come here, then 43 will come here, and then

00:06:20.280 --> 00:06:21.310
78 will come there.

00:06:21.310 --> 00:06:24.689
If I apply this I will get 22 32 43 and 78.

00:06:24.689 --> 00:06:31.069
The same way here 30 should come here, then
57, then 63, and then 91.

00:06:31.069 --> 00:06:33.120
So, this is the effect of merging.

00:06:33.120 --> 00:06:34.650
And finally, I have to merge these two.

00:06:34.650 --> 00:06:39.860
So, the smallest one 13 will go here, then
I will get 22, then I will get 32, then I

00:06:39.860 --> 00:06:47.849
will get 43, then I will get 57, then I will
get 63, and I will get 78, then I will get

00:06:47.849 --> 00:06:48.849
91.

00:06:48.849 --> 00:06:53.490
So, merging these two sub arrays of size four
will give me the final answer.

00:06:53.490 --> 00:06:55.669
So, this is how merge sort works.

00:06:55.669 --> 00:07:00.270
You break it up in two parts, recursively
solve two parts using the same strategy and

00:07:00.270 --> 00:07:02.179
merge them.

00:07:02.179 --> 00:07:07.949
So, this is generally a principle that can
be applied to many problems.

00:07:07.949 --> 00:07:14.189
So, if you can take a problem, and divide
it into two or more parts; such that this

00:07:14.189 --> 00:07:17.449
part can be solved independent of that part,
and there is no overlap.

00:07:17.449 --> 00:07:22.389
You solve this separately, you solve this
separately, and now you want to somehow combine.

00:07:22.389 --> 00:07:25.849
In this particular algorithm combination is
merging.

00:07:25.849 --> 00:07:29.419
We will look later on at other divide and
conquer algorithms, where the combination

00:07:29.419 --> 00:07:32.740
might require a different strategy, but the
whole idea is, that if you can break up the

00:07:32.740 --> 00:07:35.560
problem into smaller problems, and then combine
them.

00:07:35.560 --> 00:07:39.740
Then you can sometime get a lot of benefit
in terms of efficiency.

00:07:39.740 --> 00:07:43.589
The crucial thing, is to identify how to break
up the problem into disjoin sub problems,

00:07:43.589 --> 00:07:47.840
and how to combine the solution to these sub
problem efficiently to solve the problem at

00:07:47.840 --> 00:07:48.840
hand.

00:07:48.840 --> 00:07:56.080
So, let us come back to our merge sort and
try to formalize the algorithms in terms of

00:07:56.080 --> 00:07:57.080
actual code.

00:07:57.080 --> 00:08:02.809
So, how do I combine two sorted list or two
sorted arrays A and B into a third sorted

00:08:02.809 --> 00:08:08.800
list C. Well as we saw if one of the two is
empty, then I do not have to do anything I

00:08:08.800 --> 00:08:09.869
just have to copy the other one.

00:08:09.869 --> 00:08:14.050
So if there is a no element left in A, then
I can just copy the rest of B into C.

00:08:14.050 --> 00:08:19.780
If B is empty I can copy A into C; otherwise
we compare the first element of A and B and

00:08:19.780 --> 00:08:24.389
move the smaller of the two into C, and we
repeat this until everything has been moved.

00:08:24.389 --> 00:08:27.190
So, here is a simple iterative merge function.

00:08:27.190 --> 00:08:30.550
So, it takes two arrays as input.

00:08:30.550 --> 00:08:33.860
Takes an array A of size m.

00:08:33.860 --> 00:08:35.710
So, 0 to m minus 1.

00:08:35.710 --> 00:08:44.600
And takes an array B, which may be of different
size 0 to n minus 1, and the aim is to construct

00:08:44.600 --> 00:08:48.530
a new array C. Now we know the size of C,
because everything there must come here.

00:08:48.530 --> 00:08:54.370
So, it will be 0 to m plus n minus 1.

00:08:54.370 --> 00:08:57.560
So, what we do is, we maintain some position.

00:08:57.560 --> 00:09:02.070
So, we say that okay let i be the current
position I am looking at in this, j be the

00:09:02.070 --> 00:09:05.770
current position I am looking at in B, and
k be the current position I am trying to fill

00:09:05.770 --> 00:09:09.840
in C. So, now, we know that there are m plus
n steps.

00:09:09.840 --> 00:09:13.850
So we put a loop which says this thing must
run m plus n times.

00:09:13.850 --> 00:09:22.470
So, if we have already reached the end, if
j has already reached the end, or if A i is

00:09:22.470 --> 00:09:24.400
smaller than B j.

00:09:24.400 --> 00:09:26.640
So, this is the real merge step.

00:09:26.640 --> 00:09:30.830
If A i is smaller or equal to B j what we
will do is, we will copy this value here,

00:09:30.830 --> 00:09:34.400
and then we will increment i and we will increment
j.

00:09:34.400 --> 00:09:42.760
So, we will move C k will be A i and i will
be incremented and k will be incremented.

00:09:42.760 --> 00:09:46.220
But this also happens in case j is equal to
n.

00:09:46.220 --> 00:09:50.470
If j is equal to n what it means is that,
this pointer has actually reached all way

00:09:50.470 --> 00:09:51.470
there.

00:09:51.470 --> 00:09:52.470
So, there nothing left to scan.

00:09:52.470 --> 00:09:55.320
So, j is equal to n means it is actually beyond
the right point.

00:09:55.320 --> 00:09:56.770
So, it is beyond the point.

00:09:56.770 --> 00:09:58.250
So, there is nothing to scan.

00:09:58.250 --> 00:10:03.780
So, we will just copy everything from A to
C. So, either we copy element, current element

00:10:03.780 --> 00:10:07.760
from A to C if A i is smaller than B j or
if there is nothing in B, we copy the current

00:10:07.760 --> 00:10:15.760
element, because we are just copying everything
from A to C. So, the symmetric case is, when

00:10:15.760 --> 00:10:17.650
we have A i bigger then B j.

00:10:17.650 --> 00:10:22.550
So, if A i is bigger than B j, then what we
want to do is, copy this value here.

00:10:22.550 --> 00:10:24.790
So, we want to move j up and k up.

00:10:24.790 --> 00:10:30.130
So, we copy C k is equal to B j, copy the
value at B j to C k, and increment both j

00:10:30.130 --> 00:10:31.390
and k.

00:10:31.390 --> 00:10:35.640
And like we did earlier, the other reason
we might want to do this is, if we have already

00:10:35.640 --> 00:10:37.600
exceeded the length of.

00:10:37.600 --> 00:10:39.380
So, if we are currently here.

00:10:39.380 --> 00:10:44.650
So, A has been exhausted, then we would also
move the next element blindly from B to C.

00:10:44.650 --> 00:10:47.130
So, this is a simple while loop right.

00:10:47.130 --> 00:10:52.020
It takes exactly as many steps as there are
elements to move, and in each step I move

00:10:52.020 --> 00:10:55.360
one more element to C; either from A or B
depending on the criterion on the current

00:10:55.360 --> 00:10:59.600
element I am looking at.

00:10:59.600 --> 00:11:02.350
So, having got merge out of the way.

00:11:02.350 --> 00:11:04.960
Now, we can look at merge sort itself.

00:11:04.960 --> 00:11:10.510
So, if we want to sort A of size n indices
0 to n minus 1.

00:11:10.510 --> 00:11:14.010
We have to create a new array as we said,
because merging has to copy those two things

00:11:14.010 --> 00:11:15.180
into a new thing.

00:11:15.180 --> 00:11:20.550
So, we are eventually going to take A and
sort it into a new array B of the same size.

00:11:20.550 --> 00:11:22.620
So, if n is 1.

00:11:22.620 --> 00:11:27.570
If we have an element of size one, we have
the base case, nothing should be done.

00:11:27.570 --> 00:11:31.880
Otherwise we will sort the left part into
a sub array L. We will sort right half into

00:11:31.880 --> 00:11:36.680
a sub array R for left and right, and then
we will merge the two using function we just

00:11:36.680 --> 00:11:37.680
wrote.

00:11:37.680 --> 00:11:41.500
So, this is a very clear recursive algorithm.

00:11:41.500 --> 00:11:47.840
So, we want to merge sort A from left to right.

00:11:47.840 --> 00:11:52.350
So, we will assume that, when we say from
left to right, we mean that the left most

00:11:52.350 --> 00:11:57.210
position is called left, and the right most
index is actually right minus 1.

00:11:57.210 --> 00:12:02.250
So, this is actually one more then the index
of the position that we want to sort out.

00:12:02.250 --> 00:12:06.350
So, we want to sort this segment, starting
at A left and going up to and including A

00:12:06.350 --> 00:12:07.350
right minus 1.

00:12:07.350 --> 00:12:17.690
So, first of all if this segment is of length
one, then we just copy the value into B.

00:12:17.690 --> 00:12:22.350
We copy the value at A left.

00:12:22.350 --> 00:12:30.631
Otherwise what we do is, we make, we find
the midpoint, and then we copy up to, but

00:12:30.631 --> 00:12:31.631
not including mid.

00:12:31.631 --> 00:12:34.270
So, this is why we use this convention that
it is up to mid minus 1.

00:12:34.270 --> 00:12:48.070
So, this will be from A left to A mid minus
1, and this will merge sort from A mid to

00:12:48.070 --> 00:12:51.460
A right minus 1.

00:12:51.460 --> 00:12:55.620
So, what we want to makes sure is, that we
are not accidentally overlapping.

00:12:55.620 --> 00:12:59.030
So, we want to make sure that the mid value
which appears in both things.

00:12:59.030 --> 00:13:02.530
The value at A mid is only in none of them;
namely in the right hand side not in the left

00:13:02.530 --> 00:13:03.910
hand side, so having done this.

00:13:03.910 --> 00:13:09.540
Then I will use my earlier merge function,
to merge L, which is of size mid minus left,

00:13:09.540 --> 00:13:14.540
and R which is of size right minus mid into
B. So, this is the function that we already

00:13:14.540 --> 00:13:15.540
had.

00:13:15.540 --> 00:13:17.110
So it is a very simple recursive thing.

00:13:17.110 --> 00:13:23.040
Find the midpoint, sort the left half, sort
the right half and merge them.

00:13:23.040 --> 00:13:28.660
As we said, it does not really matter that
A is of even length or it is a multiple of

00:13:28.660 --> 00:13:29.660
two.

00:13:29.660 --> 00:13:32.680
So, it might be that left half and the right
half are not of same length; one will be longer,

00:13:32.680 --> 00:13:33.680
one will be shorter.

00:13:33.680 --> 00:13:34.680
It does not really matter.

00:13:34.680 --> 00:13:36.760
This works in all cases.

00:13:36.760 --> 00:13:40.980
To analysis this, is not so straight forward,
so we will postpone that to the next module.

