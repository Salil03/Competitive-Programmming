WEBVTT
Kind: captions
Language: en

00:00:01.209 --> 00:00:06.779
In the next few lectures, we will look at
a very powerful technique for designing algorithms

00:00:06.779 --> 00:00:09.010
called dynamic programming.

00:00:09.010 --> 00:00:15.590
So, the starting point of dynamic programming
is to consider, what we would call inductive

00:00:15.590 --> 00:00:20.509
definitions. Now, there are many very simple
functions which we come across which are inductive.

00:00:20.509 --> 00:00:26.710
So, we all know that mathematically n factorial
is n times n minus 1 factorial. So, we can

00:00:26.710 --> 00:00:32.570
write an inductive definition of factorial
as follows. The base case, okay, is when n

00:00:32.570 --> 00:00:38.100
is 0 and in this case the factorial is 1,
so f of 0 is 1.

00:00:38.100 --> 00:00:44.829
And in general, if we have n greater than
0, then f of n is given by n times f of n

00:00:44.829 --> 00:00:50.070
minus 1. In other words, we express the factorial
of n in terms of the same function applied

00:00:50.070 --> 00:00:55.730
to a smaller input, now this kind of inductive
definition is not restricted only to numeric

00:00:55.730 --> 00:01:01.719
problems, you can also do it for structural
problems. So, for example in a list or an

00:01:01.719 --> 00:01:06.030
array, you can consider a sub list or a sub
array as a smaller problem.

00:01:06.030 --> 00:01:14.680
So, here is a very simple way of describing
insertion sort. So, if I want to sort n elements,

00:01:14.680 --> 00:01:19.030
then the way insertion sort does is that of
course, if there is nothing to sort in the

00:01:19.030 --> 00:01:26.600
base case, then we have done. Otherwise, we
look at the rest of the list starting from

00:01:26.600 --> 00:01:34.360
the second element and we recursively sort
it, right, and then we insert the first element

00:01:34.360 --> 00:01:38.009
into the sorted list.
So, the insertion sort applied to X1 to Xn,

00:01:38.009 --> 00:01:43.750
requires us to insert the value X1 in the
recursively sorted X2 to Xn. So, again we

00:01:43.750 --> 00:01:50.130
are applying the same function that we are
trying to define to a smaller input and in

00:01:50.130 --> 00:01:53.920
the base case, the smallest input, namely
the empty one,, we have an answer which is

00:01:53.920 --> 00:01:57.079
readily available to us.

00:01:57.079 --> 00:02:03.810
So, one of the attractions of having inductive
definitions is that they yield in a very natural

00:02:03.810 --> 00:02:08.399
way recursive programs. So, we do not have
to think much, we can almost take the inductive

00:02:08.399 --> 00:02:13.510
definition and directly translate it as a
program. So, here is a translation for factorial

00:02:13.510 --> 00:02:16.920
which more or less reflects the structure
that we had before, remember that the structure

00:02:16.920 --> 00:02:23.090
that we had before that was that f of 0 is
equal to 1 and f of n is equal to n times

00:02:23.090 --> 00:02:27.690
f of n minus 1.
So, we say if n... Now, just to make it little

00:02:27.690 --> 00:02:31.100
more robust, so that people give, they give
negative numbers, we get sensible answers,

00:02:31.100 --> 00:02:36.170
so just checking n equal to 0, you can just
check for any value 0 or less, we will just

00:02:36.170 --> 00:02:41.400
return 1. If somebody asks us for a factorial
of minus 7, we will just return 1. But the

00:02:41.400 --> 00:02:45.140
expected thing is that they will start with
0 and then if they give us a positive number

00:02:45.140 --> 00:02:48.130
which is bigger than 0, then we will go to
the recursive keys.

00:02:48.130 --> 00:02:53.400
So, we will compute factorial for n minus
1 multiply by n and then return this answer,

00:02:53.400 --> 00:02:58.660
well. So, there is a very direct one to one
correspondence between this inductive definition

00:02:58.660 --> 00:03:02.620
and the recursive program and that is what
makes inductive definitions very attractive

00:03:02.620 --> 00:03:06.640
from the point of view of describing a function.
Because, the inductive definition can be mathematically

00:03:06.640 --> 00:03:12.270
justified and then the program is obviously
correct; obvious in quotes, because it follows

00:03:12.270 --> 00:03:16.830
directly from the recursive of the inductive
definition.

00:03:16.830 --> 00:03:24.410
So, what such inductive definitions exploit
is what is sometimes called the optimal substructure

00:03:24.410 --> 00:03:30.200
property. So, what this complicated phrase
means basically is what you expect from an

00:03:30.200 --> 00:03:35.280
inductive definition that is you solve the
original problem by combining solution to

00:03:35.280 --> 00:03:39.900
sub problems. So, the solutions to the original
problem are derived in terms of solutions

00:03:39.900 --> 00:03:44.280
in the sub problem and in particular to this
sub problem is of the same type, then it is

00:03:44.280 --> 00:03:48.600
computing the same type of answer.
Now, in numerical question like factorial,

00:03:48.600 --> 00:03:52.570
it does not make sense to say something is
optimal, but for example, when you doing insertion

00:03:52.570 --> 00:03:58.010
sort and certainly when you sort the sub list,
the result of that is what you want for that

00:03:58.010 --> 00:04:04.590
sub list. So, this gives raise to a notion
of a sub problem. So, factorial of n minus

00:04:04.590 --> 00:04:09.950
1 is a factorial sub problem of factorial
of n obviously, but it is just so happens

00:04:09.950 --> 00:04:13.180
that factorial of n, only required factorial
of n minus 1.

00:04:13.180 --> 00:04:18.989
Now, we could have problems which require
more than one immediate is smaller sub problem,

00:04:18.989 --> 00:04:23.610
for instance factorial n minus 2 is also a
sub problem, n minus 3 is also a sub problem

00:04:23.610 --> 00:04:31.870
and so on. So, any smaller input can be treated
as the sub problem of the original thing.

00:04:31.870 --> 00:04:38.039
Likewise, when we actually do insertion sort,
we give it the input X1 to Xn and we ask to

00:04:38.039 --> 00:04:43.350
sort X2 to Xn. So, this is the sub problem
which is directly part of the state.

00:04:43.350 --> 00:04:49.680
But, in general one could think of any segment
X i to X j to sort as a sub problem of sorting,

00:04:49.680 --> 00:04:52.849
this would happen for instance in something
like merge sort or quick sort, especially

00:04:52.849 --> 00:04:57.669
in merge sort where you break up the array
into halves and then into quarters and so

00:04:57.669 --> 00:05:01.719
on, so at any given point you are applying
the same algorithm to some segment from A

00:05:01.719 --> 00:05:05.080
i to A j.

00:05:05.080 --> 00:05:13.050
So, now let us look at a problem that we have
seen before in the context of greedy algorithms.

00:05:13.050 --> 00:05:17.580
So, we looked at the problem called interval
scheduling. So, interval scheduling said that

00:05:17.580 --> 00:05:22.419
we had a resource which is available over
a period of time and now people will come

00:05:22.419 --> 00:05:26.110
and make bookings for these resources. So,
somebody may want to book it during this segment,

00:05:26.110 --> 00:05:29.270
somebody else may want to book it in this
segment, somebody else may want it during

00:05:29.270 --> 00:05:32.570
this segment and so on.
Now, during these overlapping things, you

00:05:32.570 --> 00:05:37.340
cannot give the resource to two people, so
you have given a set of request each for the

00:05:37.340 --> 00:05:42.990
starting time and an ending time. So, we have
a start and an end or a finish time and now

00:05:42.990 --> 00:05:50.080
what you want to do is, decide which of these
requests you can allocate, so that the maximum

00:05:50.080 --> 00:05:58.130
number of bookings are actually granted. So,
the goal is to maximize the number of bookings,

00:05:58.130 --> 00:06:01.810
not the length of the bookings, but the number
of bookings.

00:06:01.810 --> 00:06:08.580
So, in this particular case, what happens
is that when you honour a booking, now if

00:06:08.580 --> 00:06:14.969
a booking happens to be overlapping with a
few other bookings, then if I decide to take

00:06:14.969 --> 00:06:20.120
this booking, then this goes away. So, these
two bookings, which overlap with it, can no

00:06:20.120 --> 00:06:24.110
longer be scheduled, because they have a conflict
with this in sometime interval. So, therefore

00:06:24.110 --> 00:06:28.879
now we have to solve or find a way of allocating
the remaining bookings for some subset of

00:06:28.879 --> 00:06:33.870
the problem of the bookings.
So, each subset of the bookings is a sub problem

00:06:33.870 --> 00:06:41.449
in this case and the strategy that we saw
was a greedy one, which said to pick the one

00:06:41.449 --> 00:06:47.139
which has the earliest finishing time. So,
among all those bookings which are still available

00:06:47.139 --> 00:06:53.240
to us to allocate, we pick one in a greedy
way by just looking at it among all those

00:06:53.240 --> 00:06:59.460
that remain at the earliest finishing time.
Now, this as we said, when we add, will eliminate

00:06:59.460 --> 00:07:05.389
some bookings which are in conflict. That
gives us a sub problem and you will solve

00:07:05.389 --> 00:07:07.169
these sub problem.

00:07:07.169 --> 00:07:13.870
So, how many sub problems are there? Now,
we have N bookings and every possible subset

00:07:13.870 --> 00:07:19.280
of this is a sub problem, so we have an exponential
number of sub problems. In general, we have

00:07:19.280 --> 00:07:23.580
any possible subset could be our answer. So,
we have to look through all these exponential

00:07:23.580 --> 00:07:27.360
things in principle in order to find the best
allocation, the one that gives the maximum

00:07:27.360 --> 00:07:32.559
number of bookings to be satisfied.
Now, what our greedy strategy does is effectively

00:07:32.559 --> 00:07:37.889
it cuts down this exponential space into a
linear space, because what it does is to pick,

00:07:37.889 --> 00:07:43.449
so we have initially bookings 1 to N. Then,
it will pick among these let us we assume

00:07:43.449 --> 00:07:48.699
that are actually sorted by order of the earliest
finishing time. So, you will take the first

00:07:48.699 --> 00:07:54.229
one, then you will rule out a few from there.
And now you will have some remaining and among

00:07:54.229 --> 00:07:58.909
those we pick the earliest one and you will
rule out of you more and so on. So, at most

00:07:58.909 --> 00:08:03.330
you will allocate all N of them, but in each
time once you rule include 1, you will rule

00:08:03.330 --> 00:08:07.729
out a few. So, certainly in a linear scan,
you would look at only that many sub problems.

00:08:07.729 --> 00:08:14.059
So, you would only look at order N sub problems
and find, what you claim is an optimal answer.

00:08:14.059 --> 00:08:18.979
And since, you are doing such a drastic deduction
from 2 to the N and order N; obviously, there

00:08:18.979 --> 00:08:23.930
is a question to ask whether you overlooked
some sub problems accidently by not examining

00:08:23.930 --> 00:08:28.909
them at all. So, you need a proof, so that
is why in a greedy strategy, you need to prove

00:08:28.909 --> 00:08:33.880
that what you are doing actually makes the
solution come out to be correct, because you

00:08:33.880 --> 00:08:40.400
are really not looking at a large number of,
not considering a large number of sub problems.

00:08:40.400 --> 00:08:47.400
So, suppose we change the interval scheduling
problem very slightly, we associate with each

00:08:47.400 --> 00:08:55.131
request a weight, a weight could be for example,
the amount somebody is willing to pay, so

00:08:55.131 --> 00:09:00.670
may be people are trying to book, so we have
an auditorium which we rent out for performances

00:09:00.670 --> 00:09:05.810
and other activities. And people, who come
to use it are willing to pay to use it. Of

00:09:05.810 --> 00:09:10.360
course, there is only one auditorium, so two
people cannot use it at the same time.

00:09:10.360 --> 00:09:15.700
Now, our earlier goal was to maximize the
number of bookings that we gave, but now,

00:09:15.700 --> 00:09:20.570
we have another criterion which is more immediate,
which is how much each person is willing to

00:09:20.570 --> 00:09:24.680
pay. So, even if give to only one person,
if that person is paying a lot more than everybody

00:09:24.680 --> 00:09:30.550
else, then that would be optimum for us. So,
now our aim is to maximize the total weight.

00:09:30.550 --> 00:09:37.720
So, we want to get as much revenue as possible
from our allocation not the number of bookings,

00:09:37.720 --> 00:09:39.940
but the total weight.

00:09:39.940 --> 00:09:47.700
So, recall the greedy strategy in the earlier
case, we wanted the earliest finish time.

00:09:47.700 --> 00:09:54.770
So, if we saw this particular selection of
three requests, then the earliest finish time

00:09:54.770 --> 00:10:01.770
would be this one. So, we would first take
this, that would rule out this and then because

00:10:01.770 --> 00:10:07.430
the third request starts after the first one
completes, so you will take this and so we

00:10:07.430 --> 00:10:12.870
will get two bookings. And this 2 out of 3
is the best we can do and that was find in

00:10:12.870 --> 00:10:20.650
the un weighted case.
But, now unfortunately, what we have is that

00:10:20.650 --> 00:10:29.020
we have a weight, so we have this weight associated
with this. So, we have to do something little

00:10:29.020 --> 00:10:32.690
more clever, because now if we choose the
first one and the third one, then the total

00:10:32.690 --> 00:10:35.060
weight is only 2.

00:10:35.060 --> 00:10:57.070
So, job, not job, but let us call it booking
1 plus 3 gives a weight of 2, whereas booking

00:10:57.070 --> 00:11:03.890
2 alone gives a weight of 3, because it has
a weight 3. So, ideally in this situation,

00:11:03.890 --> 00:11:10.070
we should recognize that the middle request
has enough weight to overcome the penalty

00:11:10.070 --> 00:11:13.620
of it being the only one that will be scheduled.
So, though we will one get out of 3 request

00:11:13.620 --> 00:11:18.320
schedule, we actually get a maximum benefit
from the cost prospect. So, therefore that

00:11:18.320 --> 00:11:22.720
what just means in other words is the greedy
strategy which we proved for the un weighted

00:11:22.720 --> 00:11:24.850
case is not valid any more unfortunately.

00:11:24.850 --> 00:11:32.000
So, what shall we do? so one strategy is to
see is there another greedy strategy, we can

00:11:32.000 --> 00:11:37.550
search for another greedy strategy and try
to argue that it works and argue that it works

00:11:37.550 --> 00:11:42.390
as we saw is rather it takes a little bit
of effort. Because, we have to use an exchange

00:11:42.390 --> 00:11:46.850
argument of some such thing to proof that
is better than any solution that you could

00:11:46.850 --> 00:11:51.140
get by any others strategy.
So, the other approach which is what we are

00:11:51.140 --> 00:11:57.050
going to look at in more detail in the next
few lectures is to try and look for an inductive

00:11:57.050 --> 00:12:05.530
solution which is obviously correct but which
can be evaluated efficiently. So, the goal

00:12:05.530 --> 00:12:12.240
is to find to save, so what we are going to
save is this effort in proving that by looking

00:12:12.240 --> 00:12:16.750
only at a few cases, we are actually producing
an optimal answer. We would in some sense

00:12:16.750 --> 00:12:22.460
look at every case, but we look at every case
in a clever way and that is what, we are going

00:12:22.460 --> 00:12:23.460
to do.

00:12:23.460 --> 00:12:26.860
So, how do we do this for this problem is
for this time, let us do something which is

00:12:26.860 --> 00:12:31.800
more direct, then what we did last time ones
for looking at the earliest finishing time,

00:12:31.800 --> 00:12:37.520
just look at the earliest starting time. So,
let us assume that or tasks or requests or

00:12:37.520 --> 00:12:42.800
call order is like this. So, we pick them
up in this order. So, we are begin with the

00:12:42.800 --> 00:12:48.130
first booking which you called b 1.
Now, observe that in the final answer, either

00:12:48.130 --> 00:12:58.340
b 1 is there, or b 1 is not there. So, we
will take two options. So, yes b 1 and no

00:12:58.340 --> 00:13:05.910
b 1, now if we eliminate b 1, then our sub
problem just consists of b 2 onwards. So,

00:13:05.910 --> 00:13:14.200
we just have a sub problem which says b2 to
b N. So, if we exclude b 1, then we just use

00:13:14.200 --> 00:13:19.160
b 2 to b N. So, exclude b 1 means just throw
it out and pretend you only had N minus 1

00:13:19.160 --> 00:13:22.990
jobs to begin with.
On the other hand, if we include b 1, then

00:13:22.990 --> 00:13:28.920
you have to be a little bit careful, because
now if I include b 1 in this particular thing,

00:13:28.920 --> 00:13:39.550
so if we include b 1, then we have to rule
out something which is in conflict. So, we

00:13:39.550 --> 00:13:43.330
eliminate all the conflicting requests as
we did in the greedy case and then we have

00:13:43.330 --> 00:13:47.890
another sub problem which is not necessarily
b 2 to b N, it will be some subset of b 2

00:13:47.890 --> 00:13:50.230
to b N.
But we have now taken both options, we have

00:13:50.230 --> 00:13:55.070
included b 1 and excluded b 1, so it is more
reasonable to expect that we have a either

00:13:55.070 --> 00:13:59.830
a solution with b 1 or without b 1, there
are no third option, the solution either has

00:13:59.830 --> 00:14:04.310
b 1 and does not have b 1, we are trying to
evaluate both and then we are trying to choose

00:14:04.310 --> 00:14:11.970
the best one. So, this is an inductive decomposition
of the problem with two sub cases with b 1

00:14:11.970 --> 00:14:17.870
without b 1, we are not making any predictions
about which is better, we evaluate both and

00:14:17.870 --> 00:14:20.180
take the better one.

00:14:20.180 --> 00:14:26.850
So, now let us argue that this kind of strategy
actually considers all the options. So, just

00:14:26.850 --> 00:14:32.900
like b 1 for any b j, the solution either
has b j or does not have b j, this is very

00:14:32.900 --> 00:14:38.970
clear. So, there are 2 to the N possible solutions,
I could either have b 1 or not b 1, have b

00:14:38.970 --> 00:14:43.200
2 or not have b 2. So, I can try every possible
subset that would be a group force argument,

00:14:43.200 --> 00:14:46.120
we want to avoid having to try every possible
subset.

00:14:46.120 --> 00:14:52.810
Now, for b 1 we have clearly checked both
cases explicitly, what about b 2, can we be

00:14:52.810 --> 00:14:59.331
sure that we are checking all cases are b
2 ? So let us look at b 2. Now, if b 2 and

00:14:59.331 --> 00:15:07.071
b 1 are not in conflict that is b 1 and b
2 or in disjoint intervals, then whether or

00:15:07.071 --> 00:15:11.780
not b 1 is chosen is independent or whether
not b 2 is chosen. This means that whether

00:15:11.780 --> 00:15:17.320
we choose b 1 or b 2 the resulting sub problem
would still allows to choose b 2.

00:15:17.320 --> 00:15:21.400
So, whether we choose b 1 or b not of that
b 1 or not b 1 at the beginning, it will be

00:15:21.400 --> 00:15:27.630
considered in both sub problem and when, we
solve that you will take the both choices.

00:15:27.630 --> 00:15:34.240
On the other hand, b 1 and b 2 do not or not
comparable, that is b 1 rules out b 2 or b,

00:15:34.240 --> 00:15:40.090
because they overlapped. Then, when b 1 is
chosen b 2 cannot be there, so b 1 can be

00:15:40.090 --> 00:15:42.860
there only if b 2 can be there only b 1 is
not there.

00:15:42.860 --> 00:15:47.650
So, when b 1 is chosen we will not considered
b 2, but b 1 is not chosen remember that we

00:15:47.650 --> 00:15:54.290
get the resulting sub problem b 2 to b N.
So, again b 2 will be chosen or given a chance,

00:15:54.290 --> 00:15:59.630
therefore b 2 we will consider all options
in the presence or absence are b 1. Likewise,

00:15:59.630 --> 00:16:03.970
we can argue that b 3 will be considered in
the presence or absence of b 1 and b 2 and

00:16:03.970 --> 00:16:08.030
what is happening as we are going along making
a more on more commitments, we are ruling

00:16:08.030 --> 00:16:12.100
out lot of incompatible combinations which
we would otherwise blindly consider, we get

00:16:12.100 --> 00:16:15.850
2 to the N.
Now, will shall have to evaluate the efficiently,

00:16:15.850 --> 00:16:21.540
but the at least that is not that difficult
to believe that we are actually trying out

00:16:21.540 --> 00:16:26.540
every possible option. We are not in advance
deciding that some local criteria like in

00:16:26.540 --> 00:16:32.810
a greedy strategy is enough to rule out certain
sub problems as being useless.

00:16:32.810 --> 00:16:41.390
So, the computational challenge comes from
the fact that the sub problems that we generate

00:16:41.390 --> 00:16:46.600
make appear again and again. So, let us look
at a simple case, you supposing we are the

00:16:46.600 --> 00:16:53.880
picture that is shown below. So, we have b
1 and b 2 which are in conflict, but notice

00:16:53.880 --> 00:16:59.970
that both b 1 and b 2 are compatible with
everything that comes after words. So, if

00:16:59.970 --> 00:17:05.470
we choose b 1, then we have to rule out b
2 and so the sub problem, we get is b 3, b

00:17:05.470 --> 00:17:08.089
4 and b N.
On the other hand, if you rule out b 1 as

00:17:08.089 --> 00:17:13.230
we said before you will try out everything
that remains namely b 2 to b N. Now, what

00:17:13.230 --> 00:17:20.379
happens you need to try b 2 to b N, so now,
when you come to b 2 to b N, you have to discard

00:17:20.379 --> 00:17:24.409
b 2 or you have to keep b 2. So, supposing
you discard b 2, then what happens when you

00:17:24.409 --> 00:17:30.000
discard b 2 from here, you precisely get the
remaining part which is b 3 to b N.

00:17:30.000 --> 00:17:36.330
So, you again generate a b 3 to b N problem
which we had already asked once in the context

00:17:36.330 --> 00:17:45.920
of choosing b 1. So, you now have that you
have choose b 1, say yes, no; if you choose

00:17:45.920 --> 00:17:52.529
b 1 I get this problem which is b 3 to b N.
Then, if I choose no, then I get a chance

00:17:52.529 --> 00:18:01.610
to choose b 2 again yes, no and now if I do
not choose b 2. Then, I discard b 2 again

00:18:01.610 --> 00:18:06.009
I get b 3 to b N, so I will be solving this
problem once here and once here, unless I

00:18:06.009 --> 00:18:07.950
do something clever.

00:18:07.950 --> 00:18:15.039
So, the whole problem with this approach is
that the inductive solution can give rise

00:18:15.039 --> 00:18:19.820
to the same problem at different stages. And
if we just use recursion as we said before

00:18:19.820 --> 00:18:24.600
one of the great benefits of having on inductive
definition is that you can just write a recursive

00:18:24.600 --> 00:18:29.669
solution which just mirrors the inductive
definition of the problem. But if you do it

00:18:29.669 --> 00:18:34.039
naively, every time you come to the function
to be done inductively, you recursively call

00:18:34.039 --> 00:18:38.730
that same function, even if you have done
it before and this can be very expensive as

00:18:38.730 --> 00:18:42.269
we shall see.
So, the goal of dynamic programming is to

00:18:42.269 --> 00:18:47.929
avoid this wastefulness. So, there are two
techniques that we will see, there is a technique

00:18:47.929 --> 00:18:52.679
called memoization, which is a way to build
in some cleverness into recursion. So, that

00:18:52.679 --> 00:18:58.250
you never call this same function twice recursively.
And dynamic programming will then be a way

00:18:58.250 --> 00:19:03.860
to avoid doing these recursive calls all together.
So, dynamic programming is a way to enumerate

00:19:03.860 --> 00:19:10.480
the sub problems directly and solve them,
knowing that the sub problems have some dependencies

00:19:10.480 --> 00:19:13.769
which you can predict.
So, we will look at these two techniques,

00:19:13.769 --> 00:19:18.399
the next couple of lectures and look at several
examples to get familiar with these notions

00:19:18.399 --> 00:19:23.720
of memoization and dynamic program, which
are essentially ways of making inductive definitions

00:19:23.720 --> 00:19:26.980
at the corresponding recursive implementations
efficient to solve.

