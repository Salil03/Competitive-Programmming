WEBVTT
Kind: captions
Language: en

00:00:00.610 --> 00:00:06.090
So, we have seen that graphs are very useful
mathematical structures for modeling problems.

00:00:06.090 --> 00:00:10.780
But, when we write an algorithm to solve a
graph theoretic problem, we need a way to

00:00:10.780 --> 00:00:14.650
represent and manipulate the graph in our
algorithm. So, we will look at that in this

00:00:14.650 --> 00:00:15.849
lecture.

00:00:15.849 --> 00:00:24.140
So, recall that a graph is a set of vertices
or nodes V connected by a set of edges E.

00:00:24.140 --> 00:00:29.820
We can have two types of edges, undirected
edges and directed edges. An undirected edge

00:00:29.820 --> 00:00:36.579
is drawn as just a line between two vertices
and it represents the fact that v and v prime

00:00:36.579 --> 00:00:40.340
are connected. It does not matter whether
we call this edge v comma v prime or v prime

00:00:40.340 --> 00:00:44.870
comma v, there is only one edge.
On the other hand in a directed graph, we

00:00:44.870 --> 00:00:50.750
actually associated a direction with an edge.
So, we could draw an edge from v to v prime

00:00:50.750 --> 00:00:55.440
and this we would write in our edge set as
a pair v comma v primes saying that the start

00:00:55.440 --> 00:01:00.329
vertex is v and the end of the edge is v prime.
And this is not the same as having an edge

00:01:00.329 --> 00:01:04.659
from v prime to v which will be written as
v prime comma v.

00:01:04.659 --> 00:01:11.050
So, in directed graphs the order of the vertices
when you mention the edge matters, then the

00:01:11.050 --> 00:01:15.030
undirected graph is just a pair of vertices,
it does not matter whether we think of it

00:01:15.030 --> 00:01:19.580
as v to v prime or v prime to v, it is just
a connection between these two pairs of vertices.

00:01:19.580 --> 00:01:25.060
So, we saw two typical problems involving
finding a route, which can be represented

00:01:25.060 --> 00:01:30.250
for both undirected and directed graphs. So,
in a directed graph, we were looking for path

00:01:30.250 --> 00:01:36.030
from v 0 to v 5, such that each pair v 0,
v 1; v 1, v2 etcetera, these are directed

00:01:36.030 --> 00:01:37.180
edges in our graph.

00:01:37.180 --> 00:01:41.840
At the same time, we can make the same graph
undirected and again we are looking for a

00:01:41.840 --> 00:01:48.210
path, where we start at v 0 and every adjacent
pair v 0 to v 1, v 1 to v 2 is an edge, such

00:01:48.210 --> 00:01:52.480
that we finally end up in the target vertex
v 5.

00:01:52.480 --> 00:01:58.079
So, the problem that we have abstractly, let
us stick to undirected graphs, is that we

00:01:58.079 --> 00:02:03.740
are given at this point an undirected graph
and we are given a source vertex v s and a

00:02:03.740 --> 00:02:09.190
target vertex v t and we asked, whether there
is a way to go from v s to v t in this graph.

00:02:09.190 --> 00:02:13.760
Now, what we did in the previous graph and
what we can do as a human beings is to take

00:02:13.760 --> 00:02:20.250
a look at the graph and see, if we can visually
identify such a path, just see v s and v t

00:02:20.250 --> 00:02:23.290
are connected.
But, when we write an algorithm to manipulate

00:02:23.290 --> 00:02:28.260
a graph, how do we get the algorithm to look
at the picture. So, for us a graph is a picture

00:02:28.260 --> 00:02:32.410
and we can easily look at the picture, if
the graph is not very complicated and try

00:02:32.410 --> 00:02:36.660
to understand the situation. But, how do we
make this picture available to an algorithm?

00:02:36.660 --> 00:02:43.030
We need a way to represent this picture that
gives the graph as input to our algorithm.

00:02:43.030 --> 00:02:49.629
So, let us make some assumptions, in any graph
that we consider, there will only be a finite

00:02:49.629 --> 00:02:55.410
set of vertices. So, if there are n vertices
to simplify life, let us just name these vertices

00:02:55.410 --> 00:03:02.010
1, 2 up to n. So, our vertices are always
going to be 1, 2, 3, 4 up to n. So, therefore

00:03:02.010 --> 00:03:10.099
now an edge is a pair of numbers i comma j.
So, the first representation we can have is

00:03:10.099 --> 00:03:16.010
to just record which pairs i and j are connected.
So, this is called an adjacency matrix, we

00:03:16.010 --> 00:03:21.690
say in this matrix A i j is 1, if and only
if i j is an edge.

00:03:21.690 --> 00:03:27.239
So, when we write such a matrix, then if we
take a graph like we had before, we would

00:03:27.239 --> 00:03:33.349
now rename the vertices 1 to 3 up to 10, because
there are actually 10 vertices in this graph

00:03:33.349 --> 00:03:36.790
and then we would write this matrix which
says for instant there is an edge from 1 to

00:03:36.790 --> 00:03:46.489
3 and therefore, the entry A 1 3 is 1. There
is no edge from 1 to 5 and therefore, the

00:03:46.489 --> 00:03:50.330
entry A 1 5 is 0.
So, in this way for every edge that we find

00:03:50.330 --> 00:03:55.010
in the graphs, say for example, A 4 5, we
will find an entry in the graph which says

00:03:55.010 --> 00:04:00.120
A 4 5 is 1. Now, remember that this is undirected.
So, if there is an edge 4 5, there is also

00:04:00.120 --> 00:04:05.709
an edge 5 4 and so we will see that actually
there is a matching edge 5 4. So, this graph

00:04:05.709 --> 00:04:11.129
is actually, this matrix will actually be
symmetric across this diagonal. So, if I see

00:04:11.129 --> 00:04:15.680
a 1 above the line, I will see a 1 below the
line, because 8 9 is as same as 9 8 as far

00:04:15.680 --> 00:04:20.299
as our undirected edges hold. So, this is
an adjacency matrix.

00:04:20.299 --> 00:04:26.189
So, now what can we do with the adjacency
matrix? Well, one thing we can do for example

00:04:26.189 --> 00:04:31.669
is find all the neighbors of a vertex. Suppose,
if we want the neighbors of a vertex i, then

00:04:31.669 --> 00:04:37.409
we want to look at the row i and look at all
the entries 1 in that row. For example, we

00:04:37.409 --> 00:04:42.370
want to look at the neighbors of vertex 4,
we look at the row 4, then 4, the entry 4

00:04:42.370 --> 00:04:47.839
comma 1 indicates whether or not 4 1 is an
edge. It is, so we get 1 as our vertex, then

00:04:47.839 --> 00:04:53.569
we walk furtherÉ And then the next 1 is at
4 comma 5, so 5 is a neighbor.

00:04:53.569 --> 00:04:59.039
And then, the next one is an 8, so 8 is a
neighbor, so in order to find the neighbors

00:04:59.039 --> 00:05:04.149
of a vertex i, we go to the row labeled i
and we scan the row from left to right and

00:05:04.149 --> 00:05:07.960
each 1 that we find, the corresponding column
is a neighbor.

00:05:07.960 --> 00:05:15.649
Now, how do we find a path? Well, we can now
look at neighbors and then neighbors of neighbors

00:05:15.649 --> 00:05:21.180
and so on. So, we start with the source vertex
in our problem, if you look at the numbering,

00:05:21.180 --> 00:05:27.249
that we gave, New Delhi corresponded to the
vertex labeled 1 and Trivandrum with the labeled,

00:05:27.249 --> 00:05:31.470
vertex labeled 10. And we wanted to know,
whether we can get from vertex 1 New Delhi

00:05:31.470 --> 00:05:35.729
to vertex 10 Trivandrum.
So, what we do is, we start at vertex 1 and

00:05:35.729 --> 00:05:40.009
we know how to find the neighbors of 1. So,
we will say that every vertex, any neighbor

00:05:40.009 --> 00:05:45.001
of 1 can be reached from 1 by one flight.
So, we start with the vertex 1 which we have

00:05:45.001 --> 00:05:50.129
already started, we can reach, because we
start there. Now, we scan its neighbors and

00:05:50.129 --> 00:05:55.669
then we find that there these three neighbors,
2, 3 and 4. So, therefore now we can conclude

00:05:55.669 --> 00:05:58.349
that if we start at 1, we can definitely reach
2, 3 and 4.

00:05:58.349 --> 00:06:03.929
So, let us color these rows also green, so
now we have indicated that in one step from

00:06:03.929 --> 00:06:08.740
1, we can reach 2, 3 and 4. Now, anything
that we can reach from 2, 3 and 4 can also

00:06:08.740 --> 00:06:13.319
be reached from 1. So, we now focus one by
one to the neighbors that we have already

00:06:13.319 --> 00:06:18.949
explored and look at their neighbors. So,
we move down to the neighbors of 2. So, 2

00:06:18.949 --> 00:06:26.629
has only 2 neighbors, 1 and 3 and it turns
out that both 1 and 3 have already been marked

00:06:26.629 --> 00:06:30.520
as being reachable from 1, we do nothing about
this.

00:06:30.520 --> 00:06:35.379
So, the cities reachable from 2 do not add
any information to our problem. So, we move

00:06:35.379 --> 00:06:42.289
on to 3, likewise 3 can reach 1 and 2, both
of which have already been listed as visited

00:06:42.289 --> 00:06:48.220
or which can be reached from 1. So, we can
again skip over to 4, because 3 has nothing

00:06:48.220 --> 00:06:52.550
new to tell us. Now, when we reach vertex
4, it has something new to tell us, because

00:06:52.550 --> 00:06:58.190
now from 4, it says you can reach 1 of course,
which we know, but we can also reach 5 and

00:06:58.190 --> 00:07:02.580
8.
So, now we will now, in our representation

00:07:02.580 --> 00:07:06.509
we will indicate that 5 and 8 are colored
green to indicate that these are also reachable

00:07:06.509 --> 00:07:12.349
from 1 by an indirect path, I can go from
1 to 4 and then from 4 to 5 and 8. So, I have

00:07:12.349 --> 00:07:17.459
already processed 1, 2, 3 and 4, so the next
I look at vertex 5 to see if 5 can give us

00:07:17.459 --> 00:07:24.750
any new neighbor. So, we look at 5 and now
5 has a neighbor we have already seen 4, but

00:07:24.750 --> 00:07:30.749
it has a new neighbor 6 and other new neighbor
7, so if I process 5, I get 6 and 7.

00:07:30.749 --> 00:07:39.300
Now, I can look at any of 6, 7 or 8, so let
us look at 8. So, 8 has neighbors 4, which

00:07:39.300 --> 00:07:43.369
I have already seen, 6 which I have already
seen, but it has new neighbor 9, which I have

00:07:43.369 --> 00:07:50.040
not seen. So, I add 9 to the list of neighbors
which can be reached eventually from 1. And

00:07:50.040 --> 00:07:59.089
now if I look at 6, I find that 6 can reach
5, 7, 8 and 9; all of which are already known

00:07:59.089 --> 00:08:04.529
to be neighbors or reachable from 1.
So, I do not have any new information, likewise

00:08:04.529 --> 00:08:10.369
when I go to 7, I can reach 5 and 6, which
I already know are reachable. So, there is

00:08:10.369 --> 00:08:15.490
no new information. And finally, the vertex
which are not yet examined is 9, so from 9

00:08:15.490 --> 00:08:21.139
I can reach 6 which I know, 8 which I know
and there is a new vertex 10, so I can reach

00:08:21.139 --> 00:08:25.949
10 from 9, so I mark 10 and once I marked
10, my problem is solved. I have found that

00:08:25.949 --> 00:08:31.080
there is a way to go from 1 to 10, by systematically
expanding the set of neighbors I can reach

00:08:31.080 --> 00:08:34.539
one level at a time.
So, this give us some algorithm, we will make

00:08:34.539 --> 00:08:38.800
this algorithm more precise as we go long,
but you can see that using this representation

00:08:38.800 --> 00:08:45.000
as an adjacency matrix, we can take this matrix
and use it to actually explore the problem

00:08:45.000 --> 00:08:50.290
that we have at hand and make it into kind
of a reasonable procedure which we can execute

00:08:50.290 --> 00:08:52.990
effectively.

00:08:52.990 --> 00:08:59.529
So, to make this algorithm more precise, we
need to make this algorithm more systematic,

00:08:59.529 --> 00:09:04.399
we have to keep track of the vertices which
have been visited, so that we do not keep

00:09:04.399 --> 00:09:09.190
exploring the same vertex again. So, we do
not want to keep going around in circles and

00:09:09.190 --> 00:09:12.990
doing the same problem again and again. So,
it will turn out that there are two fundamental

00:09:12.990 --> 00:09:16.610
strategies to solve this particular problem
which is one of the most basic problem in

00:09:16.610 --> 00:09:19.431
graphs, which is to find out, what is connected
to what.

00:09:19.431 --> 00:09:23.920
So, the strategy that we executed is what
is called breadth first, that is we first

00:09:23.920 --> 00:09:27.339
explore all the neighbors of the starting
vertex then all the neighbors of these things

00:09:27.339 --> 00:09:30.899
which are one step away, all the neighbors
of these things that are two steps away and

00:09:30.899 --> 00:09:34.660
so on. The other strategy is to go as far
as possible in one direction, so you pick

00:09:34.660 --> 00:09:37.730
one neighbor at starting vertex, then you
pick one neighbor of the new vertex, then

00:09:37.730 --> 00:09:41.819
you pick one neighbor of that new vertex and
so on until we cannot find any new vertices,

00:09:41.819 --> 00:09:45.839
then you go back and explore another neighbor
of a previous vertex and so on and this is

00:09:45.839 --> 00:09:51.120
called depth first. So, we will see these
algorithms in detail in a later lecture.

00:09:51.120 --> 00:09:57.769
So, one of the thing that you can observe
is that most of the entries in this matrix

00:09:57.769 --> 00:10:04.779
are actually 0. So, remember that if you have
n vertices, this matrixes size n square, because

00:10:04.779 --> 00:10:13.900
I have n rows and n columns. Now, if you count
the number of the edges in an undirected graph,

00:10:13.900 --> 00:10:17.819
then each pair of vertices can be an edge,
we normally disallows self loops, we normally

00:10:17.819 --> 00:10:26.129
do not consider edges from i to i for vertex
i. And the number of different pairs is n

00:10:26.129 --> 00:10:30.750
choose 2, these are how many ways you can
pick two vertices.

00:10:30.750 --> 00:10:36.690
So, you pick all the pairs, then it is n into
n minus 1 by 2, so this is a basic combinatorial

00:10:36.690 --> 00:10:44.329
fact. So, we could have about n square edges
no more and if you have about n square edges,

00:10:44.329 --> 00:10:49.370
then many of these entries in this matrix
would be 1, but in most situations the number

00:10:49.370 --> 00:10:53.580
of edges is much less than n square. So, this
is a wasteful representation in some sense,

00:10:53.580 --> 00:10:58.560
because we are recording a lot of 0Õs in
order to capture the positive information

00:10:58.560 --> 00:11:02.370
which is in the 1Õs.
And also remember that these 1Õs are symmetric,

00:11:02.370 --> 00:11:07.639
so for every 1 above the line I have, so if
I draw this diagonal, for every 1 above the

00:11:07.639 --> 00:11:12.069
diagonal, I have a symmetric 1 below the diagonal.
So, actually half of this matrix is useless,

00:11:12.069 --> 00:11:16.470
if I just know this top half it is enough
and in this top half I will have mostly 0Õs.

00:11:16.470 --> 00:11:21.200
So, we can think of another representation,
where we only keep the relevant information

00:11:21.200 --> 00:11:22.500
at hand.

00:11:22.500 --> 00:11:28.430
So, this is what is called an adjacency list,
so what we do in an adjacency list is that

00:11:28.430 --> 00:11:33.610
we explicitly maintain for every vertex, the
list of its neighbors. So, we see that one

00:11:33.610 --> 00:11:39.240
is connected to 2, 3 and 4. So, we say that
the list connected to the 1 is 2, 3, 4. Similarly,

00:11:39.240 --> 00:11:45.320
2 is connected 1 and 3, so we have the list
connected to 2 is 1 and 3, so this is the

00:11:45.320 --> 00:11:52.019
node and these are the neighbors.
So, now, in this representation, whenever

00:11:52.019 --> 00:11:55.160
I have a node, I just go to that entry for
that node and I look up the list and I can

00:11:55.160 --> 00:12:00.279
scan its neighbors and I can get it in time
proportional to the number of neighbors of

00:12:00.279 --> 00:12:03.430
that node. So, there is an advantage that
I do not have any useless information, because

00:12:03.430 --> 00:12:08.410
I am not storing all the 0Õs in the adjacency
matrix here, I am not keeping the non information

00:12:08.410 --> 00:12:11.230
which vertices are not connected.

00:12:11.230 --> 00:12:19.839
So, these two representation have their advantages
and disadvantages, in an adjacency matrix,

00:12:19.839 --> 00:12:24.980
we need much more space than an adjacency
list, but some questions are easier to answer

00:12:24.980 --> 00:12:30.269
in an adjacency matrix than in an adjacency
list. If we want to know, whether vertex j

00:12:30.269 --> 00:12:34.480
is a neighbor of vertex i, we just have to
probe one entry in the matrix, we just check

00:12:34.480 --> 00:12:38.810
if A i j is 1.
On the other hand in an adjacency list, if

00:12:38.810 --> 00:12:43.360
we want to find out if j is a neighbor of
i, we need to go to the entry for i and scan

00:12:43.360 --> 00:12:47.649
the entire list. So, this is similar to the
original discussion we had at the beginning

00:12:47.649 --> 00:12:52.350
of the sorting module on the difference between
matrices and this. So, here we can probe this

00:12:52.350 --> 00:12:57.350
entry A i j in unit time, whereas we need
time proportional to the number of neighbors

00:12:57.350 --> 00:13:02.260
of i, to find out whether j is a neighbor
of i in an adjacency list.

00:13:02.260 --> 00:13:07.199
On the other hand, if you want actually find
all the neighbors of i, then regardless of

00:13:07.199 --> 00:13:11.940
how many neighbors are needed, in an adjacency
matrix, we have to scan the entire row. So,

00:13:11.940 --> 00:13:16.730
there are n vertex in the graph, then even
if a node has only two or three neighbors

00:13:16.730 --> 00:13:21.310
we will have to look at all n entries in the
row to determine which of these n entries

00:13:21.310 --> 00:13:27.230
are the actual neighbors. On the other hand,
in an adjacency list as we have seen, we record

00:13:27.230 --> 00:13:31.560
exactly those vertices which are neighbors.
So, time to scan the neighbors is directly

00:13:31.560 --> 00:13:35.540
proportional to the neighbors. So, if each
vertex only a small number of neighbors, then

00:13:35.540 --> 00:13:39.779
the adjacency list will quickly give us those
neighbors, whereas adjacency matrix will require

00:13:39.779 --> 00:13:42.839
us to scan order n entries to find out that
small number.

