WEBVTT
Kind: captions
Language: en

00:00:01.030 --> 00:00:05.650
So, when we look at algorithms and weighted
graphs for shortest paths and for minimum

00:00:05.650 --> 00:00:11.360
cost spanning trees, we had to use some data
structures in order to make the updates efficient.

00:00:11.360 --> 00:00:15.440
So, at that time we assume that these data
structures were available and we went ahead

00:00:15.440 --> 00:00:20.400
and did an analysis of these algorithms. Now,
let us go back and look at these data structures.

00:00:20.400 --> 00:00:25.620
So, we begin with the Union Find Data Structure
which is used in Kruskal's algorithm for the

00:00:25.620 --> 00:00:27.630
minimum cost spanning tree.

00:00:27.630 --> 00:00:34.370
So, recall how Kruskal's algorithm works.
We arrange the edges in ascending order of

00:00:34.370 --> 00:00:40.100
the cost and we process the edges in this
order. So, each edge we pick up, if it does

00:00:40.100 --> 00:00:45.559
not create a cycle, we add it to the tree
and we observe that not creating a cycle is

00:00:45.559 --> 00:00:49.929
as same as keeping track of the components
that we have so far, and checking that the

00:00:49.929 --> 00:00:55.629
end points line different components. So,
the edge u v can be added if u and v currently

00:00:55.629 --> 00:01:00.839
are not connected. They are not in the same
component. Now, as the result of adding the

00:01:00.839 --> 00:01:05.570
edge, the two components do get connected.
So, we have to merge those two components.

00:01:05.570 --> 00:01:10.320
So, the bottle neck in implementing Kruskal's
algorithm efficiently is to keep track of

00:01:10.320 --> 00:01:16.050
this collection of components in order to
check which component a vertex belongs to,

00:01:16.050 --> 00:01:20.520
and to merge two components whenever we add
an edge connecting them.

00:01:20.520 --> 00:01:26.190
So, formally the problem that we have are
trying to solve is to maintain a partition

00:01:26.190 --> 00:01:31.659
of a set and update this partition, right.
So, by partition we mean that we have a set

00:01:31.659 --> 00:01:37.880
S and it is broken up into some disjoint subsets.
So, these subsets do not overlap, right and

00:01:37.880 --> 00:01:41.360
every element belongs to one of these things.
So, there may be some which have more than

00:01:41.360 --> 00:01:46.810
one element and each element is assigned to
exactly one partition, right and we call these

00:01:46.810 --> 00:01:51.970
partitions also components. So, in Kruskal's
algorithm and other applications, very often

00:01:51.970 --> 00:01:58.909
we start with a partition in which every element
is on, its own. So, we never have maybe two

00:01:58.909 --> 00:02:02.579
elements in a partition.
So, we will call this setting up as data structures.

00:02:02.579 --> 00:02:06.520
So, we will call it union find because the
two operations we actually support on this

00:02:06.520 --> 00:02:11.040
data structure are called find. So, this is
a query operation. It says, given an element

00:02:11.040 --> 00:02:17.230
s, right. Let me know which component it belongs
to currently. So, this is an update which

00:02:17.230 --> 00:02:20.330
it does not update the data structure. It
just queries the data structure and tells

00:02:20.330 --> 00:02:25.640
us in which of these partitions does s currently
lie, and then we have an update which allows

00:02:25.640 --> 00:02:30.060
us to take two partitions, right. So, may
be we take these two partitions and say now

00:02:30.060 --> 00:02:35.920
combine them into single partition. So, we
call this union, right. So, there is a union

00:02:35.920 --> 00:02:39.720
operation which merges partitions together
and there is a find operation which has to

00:02:39.720 --> 00:02:44.660
keep track of which partition a set belongs
to an element belongs to over time with partition.

00:02:44.660 --> 00:02:50.430
It originally would have got merged with other
partitions because of these two operations

00:02:50.430 --> 00:02:56.349
union and find. We call this a union find
data structure which supports these two operations

00:02:56.349 --> 00:03:01.500
efficiently, and the initialization of this
union find is an operation which takes a set

00:03:01.500 --> 00:03:08.670
and breaks up to it. It has n elements up
into n components each containing one element.

00:03:08.670 --> 00:03:15.791
So, the first issue that we have to deal with
is about the names of the components. What

00:03:15.791 --> 00:03:20.880
do we call these components? A simple solution
we will find is to just use the elements of

00:03:20.880 --> 00:03:26.050
the set itself as names, right. So, it does
not really matter of what names we give. We

00:03:26.050 --> 00:03:30.590
just need to be able to check periodically
whether s and t or u and v belong to the same

00:03:30.590 --> 00:03:35.030
component. So, we just need to know whether
find of u is equal to find of v, right. So,

00:03:35.030 --> 00:03:38.580
the exact choice of how we label find of u
and find of v does not matter. So, as long

00:03:38.580 --> 00:03:42.920
as we can check whether two labels are the
same or different, but rather than manufacturer

00:03:42.920 --> 00:03:49.440
set of labels out of them have, we will actually
choose the labels to be set elements themselves.

00:03:49.440 --> 00:03:54.900
So, initially we said every element lies in
a single partition. So, supposing I have a

00:03:54.900 --> 00:04:03.811
set consisting of s t u, then I would initially
have three partitions. One contains s, one

00:04:03.811 --> 00:04:07.200
containing t, and one containing u.
Well, the question is what do we call this

00:04:07.200 --> 00:04:11.299
partition? Well, we just call them the same
thing. We call this partition s, call this

00:04:11.299 --> 00:04:15.681
the partition t and call this the partition
u. So, sometimes the names of the element

00:04:15.681 --> 00:04:20.560
will refer to names of partitions. Sometimes
they will refer to names of the elements themselves.

00:04:20.560 --> 00:04:25.410
Now, what happens when we merge? For example,
supposing we merge these two partitions, right.

00:04:25.410 --> 00:04:30.270
Then, the label has to be the same. So, the
element does not change, but maybe we might

00:04:30.270 --> 00:04:37.130
take the set, the label u and make it t. So,
now, both element u and element t belong to

00:04:37.130 --> 00:04:42.440
the partition label t, right. So, we just
use as the set of labels, the names of the

00:04:42.440 --> 00:04:43.940
elements themselves.

00:04:43.940 --> 00:04:50.289
So, in particular if you are dealing with
graphs, the elements are the vertices typically

00:04:50.289 --> 00:04:54.250
and we already had convention that we have
n vertices in our set and we call them 1 to

00:04:54.250 --> 00:05:01.810
n. So, set of elements is 1 to n and so is
our set of components, right. So, what we

00:05:01.810 --> 00:05:08.060
will do now is the easiest way to keep track
of this is to setup an array, right. So, we

00:05:08.060 --> 00:05:19.419
have an array which we will call component
and what will this array say. Well, this will

00:05:19.419 --> 00:05:28.840
say that for each of the vertices or nodes
1 to n which component it belongs to, right.

00:05:28.840 --> 00:05:32.750
So, initially we said each component will
contain exactly one vertex. So, we can just

00:05:32.750 --> 00:05:39.020
have a vertex n a vertex i and component i
for every i. In general, after some time,

00:05:39.020 --> 00:05:41.889
these might change.
So, this might have gone to component 3 is

00:05:41.889 --> 00:05:46.130
might have gone to component 7 and so on,
right. So, over time the component that a

00:05:46.130 --> 00:05:51.400
node belongs to changes because of the union
operations, so then when we find you, just

00:05:51.400 --> 00:05:56.930
return the current value of component you
find and for union all we have to do is, we

00:05:56.930 --> 00:06:02.229
have to check and make all the components,
both components k and k prime have the same

00:06:02.229 --> 00:06:06.540
label. So, rather than invent a new label,
we will choose either k or k prime. In this

00:06:06.540 --> 00:06:10.630
case we choose k prime. So, what we will do
is, we will go through and wherever we see

00:06:10.630 --> 00:06:15.990
a k, we will replace by a k prime. So, we
will systematically replace every entry of

00:06:15.990 --> 00:06:21.100
the form k in this array to k prime. So, after
this all component values we choose to be

00:06:21.100 --> 00:06:25.220
k are now k prime, all which were k prime
remain k prime. So, effectively the two components

00:06:25.220 --> 00:06:31.470
have been merged. So, this is a very simple
implementation of union find. So, let us try

00:06:31.470 --> 00:06:35.740
and understand why this is not a very good
implementation from a complexity point of

00:06:35.740 --> 00:06:36.740
view.

00:06:36.740 --> 00:06:42.849
So, clearly in order to make the initial things,
we have to scan the array once, and then we

00:06:42.849 --> 00:06:47.509
just have to initialize component of I to
be the value I. So, this takes order n time.

00:06:47.509 --> 00:06:53.740
So, this is find. Similarly, finding an element
is efficient. We just have to look up the

00:06:53.740 --> 00:06:58.139
ith element in the array and remember that
in an array accessing any element takes constant

00:06:58.139 --> 00:07:04.370
time. So, this is an efficient operation.
It takes constant time. On the other hand,

00:07:04.370 --> 00:07:09.139
union is a problem because the way we have
described union, we have to go through every

00:07:09.139 --> 00:07:14.410
node, check if its component is k and if its
component is k, if component of i is k, we

00:07:14.410 --> 00:07:19.130
have to update it k prime, right. So, regardless
of what the components k and k prime currently

00:07:19.130 --> 00:07:24.300
look like, we will have to scan all the elements
and update those which are k to k prime. So,

00:07:24.300 --> 00:07:28.240
this will take order n time for just one union
operation which is independent of the size

00:07:28.240 --> 00:07:35.870
of k and k prime as current partition sets.
So, if we do a sequence of m such operations,

00:07:35.870 --> 00:07:41.720
then this will be order m times n, right and
if it is n such operations, it will be n square,

00:07:41.720 --> 00:07:46.270
right. So, a sequence m operation, each of
them will take order n time and we would like

00:07:46.270 --> 00:07:52.461
to improve on this. So, basically we want
to see if we can improve on the speed of the

00:07:52.461 --> 00:07:53.949
union operation.

00:07:53.949 --> 00:08:02.020
So, let us make a slightly more elaborate
representation. So, we keep this array component

00:08:02.020 --> 00:08:06.960
as before which tells us for each vertex I
which component it belongs to, and the components

00:08:06.960 --> 00:08:11.319
as before are initially labeled 1 to n. The
names are drawn from the same set. So, basically

00:08:11.319 --> 00:08:15.490
1 to n has the vertices 1 to n or also names
are components, and initially the component

00:08:15.490 --> 00:08:24.539
of i, the vertex. i is in component i. Now,
we have a separate array of list, right. So,

00:08:24.539 --> 00:08:28.860
for each component, that we currently have,
we keep a list. So, initially the list says

00:08:28.860 --> 00:08:33.980
that the component 1 consist of the vertex
1 component, 2 consist of the vertex 2 and

00:08:33.980 --> 00:08:38.121
so on, but over a period of time we could
have situation whether the component 4 consist

00:08:38.121 --> 00:08:43.540
of vertex 1, 2, 4 and 7, right. So, for each
component we have the list of vertices that

00:08:43.540 --> 00:08:48.920
it belongs to and we will also separately
keep track of the size. So, we will say that

00:08:48.920 --> 00:08:55.601
the size of this component is also 4 and the
size of this component is 1. So, we have two

00:08:55.601 --> 00:09:03.020
auxiliary things. We keep for each component
k the list of its members explicitly and we

00:09:03.020 --> 00:09:07.730
also keep the size of this list. So, we know
exactly how big each component is at any given

00:09:07.730 --> 00:09:10.350
time initially, of course the size is 1.

00:09:10.350 --> 00:09:16.250
So, when we need do make union find, we said
component I equal to I as before, then we

00:09:16.250 --> 00:09:22.920
initialize that the members of the list I
are component I adjust the list containing

00:09:22.920 --> 00:09:28.810
I itself in the size of each component is
1. Now, find is exactly the same as before.

00:09:28.810 --> 00:09:34.070
We just have to look at component and return
the value. The component I points to. Unions

00:09:34.070 --> 00:09:41.080
is also similar to before. So, what we need
do is, we need do set everything that is pointing

00:09:41.080 --> 00:09:46.690
to k to point to k prime inside. So, every
entry in component which k should be, k prime,

00:09:46.690 --> 00:09:51.190
but now we can do this by just looking at
members. So, we do not have to scan all the

00:09:51.190 --> 00:09:56.480
elements 1 to n. We can look up every element
that appears in members of k and update its

00:09:56.480 --> 00:10:02.010
value to k prime, right. So, this is one saving.
We no longer have to go through 1 to n. We

00:10:02.010 --> 00:10:06.880
have only looked exactly at the member which
belongs to the set k. Then, of course we need

00:10:06.880 --> 00:10:11.280
to update these new things.
So, members of k now become members of k primes.

00:10:11.280 --> 00:10:16.090
So, we will merge these two lists. Now, remember
that these two lists are in sorted order.

00:10:16.090 --> 00:10:19.800
We can assume that they are always kept in
ascending order of the names of the elements.

00:10:19.800 --> 00:10:23.600
So, merging two sorted lists as we did in
merge sort, takes time proportional to the

00:10:23.600 --> 00:10:26.960
length of the final list. So, this will be
a linear time thing in proportional to the

00:10:26.960 --> 00:10:32.970
size of the components k and k prime. Finally,
now we have one new component which subsumes

00:10:32.970 --> 00:10:37.660
earlier to. So, its size is exactly the sum
of the previous two of course. These are partitions.

00:10:37.660 --> 00:10:42.100
No element was repeated. So, every element
that joins the partition is a new one. So,

00:10:42.100 --> 00:10:47.630
size of k prime is exactly size of k plus
the old size of k prime.

00:10:47.630 --> 00:10:55.470
So, why do we get some benefit from this?
So, the first thing as we said is updating

00:10:55.470 --> 00:11:00.710
a component is now proportional to its size,
right. Up - updating component takes orders

00:11:00.710 --> 00:11:04.380
size of k steps. It does not take order n
steps. We do not have to go through every

00:11:04.380 --> 00:11:08.990
vertex 1 to n. We can explicitly look up those
elements mentioned in members of k and only

00:11:08.990 --> 00:11:16.250
update those values, but size of k actually
places in much more important role. What we

00:11:16.250 --> 00:11:21.150
can do now is we can determine whether to
re-label k as k prime or k prime as k. Remember

00:11:21.150 --> 00:11:25.540
we have a choice when we merge k and k prime.
All the elements are going to become part

00:11:25.540 --> 00:11:28.920
in the same component. So, the new component
will be either called k or it will be called

00:11:28.920 --> 00:11:31.880
k prime.
So, which one we should choose? So, the strategy

00:11:31.880 --> 00:11:37.580
that we are going to do is to keep the name
of the larger one. So, the size of k is smaller

00:11:37.580 --> 00:11:41.860
than the size of k prime. That means, k prime
currently has more members in k. Then, we

00:11:41.860 --> 00:11:47.110
will keep k prime as a name of the final set.
So, we will replace all ks as k prime and

00:11:47.110 --> 00:11:51.270
symmetrically size of k is bigger than size
of k prime. We will replace all the k primes

00:11:51.270 --> 00:11:59.190
as k, right. So, the smaller set changes its
name and the bigger set keeps its name.

00:11:59.190 --> 00:12:07.300
So, this does not give us any benefit in the
worst case of an individual union operation.

00:12:07.300 --> 00:12:13.980
Suppose we have size of k and size of k prime
roughly the size of half. So, if we are built-up

00:12:13.980 --> 00:12:19.230
two components which are roughly half the
size of the overall set, then whether we merge

00:12:19.230 --> 00:12:23.900
k or k prime into the other set, we have to
update about half the values. So, this is

00:12:23.900 --> 00:12:28.600
an order n operation, right. So, earlier we
have said that without doing anything fancy,

00:12:28.600 --> 00:12:34.640
we will scan all the vertices and worst case
in fact is every case of update will take

00:12:34.640 --> 00:12:39.190
as order n time. Now, it says that there is
a worst case where we cannot avoid taking

00:12:39.190 --> 00:12:46.060
order n time. So, n by 2 is order n. So, therefore
what have we gained? So, what we have gained

00:12:46.060 --> 00:12:51.430
cannot be really accounted for terms of individual
merge operations. We have to look at the cumulative

00:12:51.430 --> 00:12:55.770
effect of bunch of merges. So, we need to
do what is more careful accounting. Now, we

00:12:55.770 --> 00:12:59.660
have to account for the operations. So, remember
we did some careful accounting when we did

00:12:59.660 --> 00:13:04.980
things like you know when we used adjacency
list in breadth first search. We said across

00:13:04.980 --> 00:13:09.170
all the loops, we will see each edge exactly
twice. Therefore, across all the loops we

00:13:09.170 --> 00:13:14.040
take order m time. So, we need to do a similar
kind of careful accounting across, not one

00:13:14.040 --> 00:13:18.550
merge, but all the merges that they take place.

00:13:18.550 --> 00:13:24.740
So, the effect of merging the smaller set
into the bigger set is that if I look at an

00:13:24.740 --> 00:13:31.080
individual element, the component if it changes,
its labeled, right. If the component is currently

00:13:31.080 --> 00:13:37.200
k and it becomes k prime, then new set is
at least twice as big as the old set, right.

00:13:37.200 --> 00:13:48.510
So, supposing I had set k and an element s
in it and I had another set k prime, then

00:13:48.510 --> 00:13:56.510
I decide to merge these into two single set.
Now, by assumption if the new set continues

00:13:56.510 --> 00:14:02.820
to be called k prime, then that means that
k was less than k prime or you could even

00:14:02.820 --> 00:14:08.020
say less than equal to does not really matter.
So, since case smaller than k prime, what

00:14:08.020 --> 00:14:13.110
it means is that if I look at k plus k which
will be double the size of the old set, this

00:14:13.110 --> 00:14:21.870
will be less than or equal to k plus k prime
just by substituting. Therefore, this is the

00:14:21.870 --> 00:14:25.540
size of the new set, right. K plus k prime
is the size of the new set I construct and

00:14:25.540 --> 00:14:29.260
it is going to be at least twice the size
of the old size. Therefore, whenever the name

00:14:29.260 --> 00:14:35.740
of the set labeling component of an element
changes, the new set it belongs to at least

00:14:35.740 --> 00:14:42.260
double the size.
So, now let us look at some sequence of m

00:14:42.260 --> 00:14:46.980
union operations starting from the initial
condition when I have all elements in separate

00:14:46.980 --> 00:14:54.560
partitions. So, what can happen in each operation,
perhaps I combine two elements, right. Now,

00:14:54.560 --> 00:15:01.020
if the next time if I combine these two, then
totally in two operations I only affect three

00:15:01.020 --> 00:15:06.820
elements. So, in the worst case if I start
doing this separately, each time in one operation

00:15:06.820 --> 00:15:10.930
I accept it affects two and in other operations
it affects two more and so on. So, after a

00:15:10.930 --> 00:15:17.440
sequence of m operations at most 2 m elements
have had the status change from the initial

00:15:17.440 --> 00:15:23.290
condition, when they have a pointing two or
component consisting only themselves. So,

00:15:23.290 --> 00:15:28.390
that means, only 2 m elements have ever been
affected by my union operations. That means

00:15:28.390 --> 00:15:34.160
as component cannot have got larger than 2m,
because in order to get into a component,

00:15:34.160 --> 00:15:37.680
something must change. Only 2 m elements are
allowed to have any changes apply to them

00:15:37.680 --> 00:15:41.020
at all, right.
So, the size of any component after m union

00:15:41.020 --> 00:15:46.920
operation at most 2 m, but how does a size
grow? It goes 1, 2, 4 because it keeps doubling

00:15:46.920 --> 00:15:57.820
up to m, right. So, after log m steps if I
double 1 log m times, I will get m. So, therefore,

00:15:57.820 --> 00:16:04.050
a component s can be relabeled a fixed, sorry
a fixed element s can be relabeled at most

00:16:04.050 --> 00:16:12.750
log m times. So, because we have this doubling
the number of times that is set can be an

00:16:12.750 --> 00:16:17.820
element can move it to a new set. It is restricted
because each time it moves the size size of

00:16:17.820 --> 00:16:22.390
its component doubles, and there is a limit
on the largest component it will belong.

00:16:22.390 --> 00:16:28.670
So, therefore, if we look at some total of
m union operations, we know that 2 m. So,

00:16:28.670 --> 00:16:34.290
order m elements have had the component updated
and each has been updated at most log m times,

00:16:34.290 --> 00:16:38.690
right. Remember now that when we are updating
elements, we do not touch any element which

00:16:38.690 --> 00:16:43.530
is not updated. It is not the old setup, where
we have to scan all the nodes 1 to n in order

00:16:43.530 --> 00:16:48.560
to decide which one is not because we have
the list members. When we want to update the

00:16:48.560 --> 00:16:53.180
component k, we exactly update only those
components. So, we only touch the components

00:16:53.180 --> 00:17:01.250
we change. So, m elements changes log m times.
So, totally we have m log m steps of change,

00:17:01.250 --> 00:17:06.410
right. So, if we do m union operations, we
take m. It is not that each one takes m log

00:17:06.410 --> 00:17:12.040
m time directly, but the cumulative total
of m union operations is only m log m, right.

00:17:12.040 --> 00:17:17.459
So, this we can average out in a way you say
that therefore, since where m operations in

00:17:17.459 --> 00:17:22.190
the total is m log m, even though some small
some more big on an average, they take log

00:17:22.190 --> 00:17:26.819
m operations. So, this is a different kind
of analysis. It is not quite the analysis

00:17:26.819 --> 00:17:32.700
we did for. For example the adjacency list
in bfs, where we just added of everything

00:17:32.700 --> 00:17:36.990
across whole thing. Here also we are adding,
but we are also kind of pointing backwards

00:17:36.990 --> 00:17:41.520
and saying now there are totally so many operations
and the total time taken across all these

00:17:41.520 --> 00:17:46.920
operations so much. We divide and we give
each share of the total cost. So, though it

00:17:46.920 --> 00:17:52.480
is not the case that in every single operation
takes log m time, we can kind of believe that

00:17:52.480 --> 00:17:57.890
this gives us a log m implementation of the
union operation. So, this kind of analysis

00:17:57.890 --> 00:18:01.300
is called amortized complexity.
So, this is the term which actually comes

00:18:01.300 --> 00:18:06.440
from accounting from financial things, where
you have certain cost which for example you

00:18:06.440 --> 00:18:10.550
might have in order to run a business. You
might have to setup something, right. You

00:18:10.550 --> 00:18:15.230
may setup an office, and then all that now
if you cannot say that my cost in give one

00:18:15.230 --> 00:18:19.180
was a lot, because I have to do a lot of work
to setup the office. Therefore, day one with

00:18:19.180 --> 00:18:24.220
expansive what you have to do is look at the
total life time of your operation and say

00:18:24.220 --> 00:18:28.950
this course is divided across the entire things.
So, is it work, right that is called amortization,

00:18:28.950 --> 00:18:35.640
where you kind of take some fixed cost of
a, fixed piece of equipment or asset or work

00:18:35.640 --> 00:18:39.170
and divide it across the entire life span
when it is going to be used. So, in the same

00:18:39.170 --> 00:18:44.580
way here we are kind of doing amortized analysis.
We are counting across all the m union operations

00:18:44.580 --> 00:18:50.830
how much time we take, and then working out
that each one takes roughly log n time.

00:18:50.830 --> 00:18:56.700
So, how do we use this union find data structure
and Kruskal's algorithm? Remember Kruskal's

00:18:56.700 --> 00:19:01.470
algorithm we initially sort the edges. So,
we have e 1 to e m and ascending order of

00:19:01.470 --> 00:19:07.700
cost. Now, we begin with trivial partitions.
So, we do make union find of our set of vertices.

00:19:07.700 --> 00:19:14.640
So, each vertex j is label j. So, we have
exactly n partition. One containing each vertex

00:19:14.640 --> 00:19:20.460
and now we need to add the current edge we
are looking at, provided it does not create

00:19:20.460 --> 00:19:24.771
a cycle. This is the same as saying that send
point was being different components. This

00:19:24.771 --> 00:19:30.300
is the same as saying that if I do find of
u and find of v for an edge u v, right, find

00:19:30.300 --> 00:19:35.380
of u is not equal to find of v and if find
of u is not equal to find of v, then I need

00:19:35.380 --> 00:19:39.940
to do a merge. So, I need the union of these
two components. I can get their component

00:19:39.940 --> 00:19:46.630
names by using find u and find v. So, this
will be some k in general the uth component

00:19:46.630 --> 00:19:51.640
containing u. This will be k prime th component
containing v and I do a union of course, and

00:19:51.640 --> 00:19:56.970
I got in new component which contains both
u and v.

00:19:56.970 --> 00:20:04.190
So, since the tree has only n minus 1 edges,
we will only add n minus 1 edges out of the

00:20:04.190 --> 00:20:11.450
total set to find the spanning tree. So, therefore,
we have order n union operations to perform

00:20:11.450 --> 00:20:16.330
over all and we know, therefore, for any m
operations we said into will take m log m.

00:20:16.330 --> 00:20:23.200
So, for m operations we have an overall amortized
cost of n log n, right, so maintaining the

00:20:23.200 --> 00:20:28.520
partitions and adding them in all that takes
m, n log n. Now, initially we have to sort

00:20:28.520 --> 00:20:34.200
the edges. So, that takes m log m, but as
we discussed when we actually look at Kruskal

00:20:34.200 --> 00:20:42.810
in detail, since m is at most n square, we
know that log m is 2 log n at most. So, at

00:20:42.810 --> 00:20:47.290
the level of orders of magnitude log m and
log n at the same, so we can look at m log

00:20:47.290 --> 00:20:58.290
n m as same as m log n. So, the total cost
now comes out to m log m, sorry m m log n

00:20:58.290 --> 00:21:05.700
plus n log n. So, we get m plus n log n.
If you remember the complexity that we claimed

00:21:05.700 --> 00:21:09.770
for Prim's algorithm and also, actually for
Dijkstra’s algorithms which are similar

00:21:09.770 --> 00:21:15.760
to prim's in structure using heaps, we claim
that those were both of that type m plus n,

00:21:15.760 --> 00:21:21.510
if we use the heap to do the minimum distance
calculation. So, therefore, Kruskal's algorithm

00:21:21.510 --> 00:21:26.170
with the union find data structure essentially
has the same complexity as prim's algorithm

00:21:26.170 --> 00:21:28.650
using heaps.

00:21:28.650 --> 00:21:36.900
So, to summarize what we have seen is that
we can implement Union-Find using an array

00:21:36.900 --> 00:21:43.450
to components and array of list to name the
vertices in each components, and another array

00:21:43.450 --> 00:21:48.340
to keep track of the size of each component.
With this the initialization step of making

00:21:48.340 --> 00:21:54.370
the union find data structure of disjoint
individual element partitions is order n find

00:21:54.370 --> 00:22:00.940
takes constant time. Amortize complexity for
a sequence of m operations is m log n. So,

00:22:00.940 --> 00:22:06.500
we can think of each union operation is taking
log m time for a sequence of search m operations

00:22:06.500 --> 00:22:07.610
starting from the initial.

