WEBVTT
Kind: captions
Language: en

00:00:00.980 --> 00:00:04.920
So, welcome to the NPTEL MOOC on the design
and analysis of algorithms.

00:00:04.920 --> 00:00:10.280
So, here are some of the things that we would
be looking at in this course.

00:00:10.280 --> 00:00:15.420
When we study algorithms, the first thing
that we need to convince our selves is that

00:00:15.420 --> 00:00:19.470
the algorithm is correct and it is doing the
job that we expect it to do.

00:00:19.470 --> 00:00:24.090
So, we look at the strategies for proving
the correctness of algorithms.

00:00:24.090 --> 00:00:28.149
The other important aspect of algorithm is
of course its efficiency.

00:00:28.149 --> 00:00:31.570
How much time does the algorithms take on
inputs?

00:00:31.570 --> 00:00:35.610
Now, of course we have to factor in the size
of the input.

00:00:35.610 --> 00:00:41.050
And we need a notation or a way of comparing
two different algorithms, which operate on

00:00:41.050 --> 00:00:44.350
the same types of inputs and produce the same
types of outputs.

00:00:44.350 --> 00:00:49.390
So, this will be achieved through the concept
called asymptotic complexity, which measures

00:00:49.390 --> 00:00:53.720
the running time of an algorithm as inputs
grow larger and larger as the function of

00:00:53.720 --> 00:00:54.720
the inputs.

00:00:54.720 --> 00:01:01.030
And we will develop some notation, typically
the big O notation in order to smoothen out

00:01:01.030 --> 00:01:07.450
some idiosyncrasies of algorithms and group
them into large chunks, which are equivalent.

00:01:07.450 --> 00:01:12.740
An important part of problem solving in any
domain and in particular in algorithms is

00:01:12.740 --> 00:01:18.070
the art of modelling the problem at a suitable
level of detail.

00:01:18.070 --> 00:01:25.020
In most algorithms that we will see we need
to find a suitable mathematical model.

00:01:25.020 --> 00:01:26.940
One of these will be graphs.

00:01:26.940 --> 00:01:31.370
We need a way of representing the concepts
of these models in our algorithm.

00:01:31.370 --> 00:01:34.820
For this, we need appropriate data structures.

00:01:34.820 --> 00:01:40.780
And of course typically in order to solve
a problem we need to break it down into manageable

00:01:40.780 --> 00:01:41.850
sub problems.

00:01:41.850 --> 00:01:46.810
So, we will look at strategies to decompose
problems into smaller problems and see how

00:01:46.810 --> 00:01:49.799
to put them together to solve the problem
it had.

00:01:49.799 --> 00:01:56.520
Over the course of time, many generic techniques
have been developed to solve a large number

00:01:56.520 --> 00:01:57.950
of problems.

00:01:57.950 --> 00:02:03.540
And we will see examples of how these techniques
can be applied to very standard problems that

00:02:03.540 --> 00:02:05.590
we come across repeatedly.

00:02:05.590 --> 00:02:07.869
Among the techniques are divide and conquer.

00:02:07.869 --> 00:02:13.749
Where, we break up the problem into individual
components which do not overlap with each

00:02:13.749 --> 00:02:18.189
other and then combine these solutions in
order to get the solution for the overall

00:02:18.189 --> 00:02:19.709
problems.

00:02:19.709 --> 00:02:27.099
In some cases, we can identify a strategy
which looks at the local state of the problem

00:02:27.099 --> 00:02:31.969
and chooses an optimal path and arrives at
the final solution without having to look

00:02:31.969 --> 00:02:34.110
at all possibilities.

00:02:34.110 --> 00:02:35.810
These kind of greedy algorithms are rare.

00:02:35.810 --> 00:02:40.260
It is important to know how to prove such
an algorithm is correct.

00:02:40.260 --> 00:02:44.629
But if a greedy algorithms does exists, it
is typically much more efficient than other

00:02:44.629 --> 00:02:47.190
types of algorithms.

00:02:47.190 --> 00:02:51.559
When greedy does not work, we need a systematic
way of exploring all the possibilities and

00:02:51.559 --> 00:02:53.450
choosing the best one.

00:02:53.450 --> 00:02:58.349
In this process, sometimes we have to discard
overlapping problems and make sure that we

00:02:58.349 --> 00:03:00.889
do not wastefully recompute things.

00:03:00.889 --> 00:03:08.169
So, this is covered by the concept of dynamic
programming.

00:03:08.169 --> 00:03:11.969
Now along with the theory, in this course
we will have some programming assignments.

00:03:11.969 --> 00:03:17.779
So, we do expect that all of you have some
background in programming.

00:03:17.779 --> 00:03:20.040
This could be in C or C plus plus or java.

00:03:20.040 --> 00:03:24.809
We are flexible about the language you use,
but you should be able to write standard programs

00:03:24.809 --> 00:03:29.629
and implement some of the basic algorithms
that we are using in our course.

00:03:29.629 --> 00:03:33.499
In order to do this, we will of course cover
some new data structures in this course.

00:03:33.499 --> 00:03:38.609
But we do expect that in the language that
you use, you are familiar with basic concepts

00:03:38.609 --> 00:03:44.169
like arrays and lists and also things like
stacks and queues, which build up on these.

00:03:44.169 --> 00:03:48.150
Of course, when we come to stacks and queues
we will try to give some detail about how

00:03:48.150 --> 00:03:49.239
they are used.

00:03:49.239 --> 00:03:50.829
But we do expect that you have seen them before.

00:03:50.829 --> 00:03:54.430
So, this not the first time you are seeing
these concepts.

00:03:54.430 --> 00:04:00.980
Here is a kind of approximate list of the
topics we expect to cover in the course.

00:04:00.980 --> 00:04:07.589
So, after looking at a few examples we will
start with asymptotic complexity, which is

00:04:07.589 --> 00:04:12.559
the way of measuring the efficiency of an
algorithm and writing down this measure in

00:04:12.559 --> 00:04:14.909
a way that we can compare easily across algorithms.

00:04:14.909 --> 00:04:21.780
We will then move to the most basic problem
that we have for arrays, which is to search

00:04:21.780 --> 00:04:24.270
an array for an element.

00:04:24.270 --> 00:04:27.690
And in the process we will realize that it
is important to be able to sort the array

00:04:27.690 --> 00:04:31.900
efficiently in order to arrange the elements
in a way where we can search in an effective

00:04:31.900 --> 00:04:32.900
manner.

00:04:32.900 --> 00:04:34.000
So, we will look at searching and sorting.

00:04:34.000 --> 00:04:38.180
So, we will look at binary search and we will
look at different notions of sorting.

00:04:38.180 --> 00:04:42.290
Some of which are more elementary and intuitive
like insertion sort and selection sort.

00:04:42.290 --> 00:04:45.340
But are not the best in terms of efficiency.

00:04:45.340 --> 00:04:48.650
And then we will look at more efficient algorithms
like merge sort and quick sort; which are

00:04:48.650 --> 00:04:52.190
not obvious to begin with.

00:04:52.190 --> 00:04:56.000
Moving on from searching and sorting, we come
to graphs and graph algorithms.

00:04:56.000 --> 00:04:58.190
So, we will introduce graphs.

00:04:58.190 --> 00:05:02.440
We will see how we can use them to model certain
types of problems.

00:05:02.440 --> 00:05:04.350
We need to know how to represent a graph.

00:05:04.350 --> 00:05:05.400
How do you?

00:05:05.400 --> 00:05:09.440
Graph is essentially a picture, so how do
you translate this picture into something

00:05:09.440 --> 00:05:11.070
that an algorithm can manipulate?

00:05:11.070 --> 00:05:13.150
So, that is representation.

00:05:13.150 --> 00:05:17.360
We will look at standard problems in graphs;
reachability and connectedness.

00:05:17.360 --> 00:05:21.150
We will look at a special class of graphs
called directed acyclic graphs, which are

00:05:21.150 --> 00:05:24.610
very useful for modelling certain kinds of
problems.

00:05:24.610 --> 00:05:29.340
And then we will look at other canonical problems
on graphs including shortest paths and spanning

00:05:29.340 --> 00:05:33.530
trees.

00:05:33.530 --> 00:05:37.450
As we mentioned before, there are some basic
algorithmic design techniques; which are applied

00:05:37.450 --> 00:05:38.930
across a class of problems.

00:05:38.930 --> 00:05:46.500
So, we will look in particular divide and
conquer, greedy algorithms and dynamic programming.

00:05:46.500 --> 00:05:51.580
Among the data structures that we will encounter
in this course are priority queues, which

00:05:51.580 --> 00:05:53.520
are often implemented through heaps.

00:05:53.520 --> 00:05:58.920
We will look at binary search trees, which
are efficient ways of maintaining information

00:05:58.920 --> 00:06:03.550
in a sorted order dynamically as information
comes and goes.

00:06:03.550 --> 00:06:08.720
And we will look at a very useful data structure
to maintain a partition of a set into a disjoint

00:06:08.720 --> 00:06:13.150
collection of subsets; the so called union-find
algorithm.

00:06:13.150 --> 00:06:18.710
And finally, depending on how much time is
left we will look at some miscellaneous topics.

00:06:18.710 --> 00:06:24.590
It is important to realize that not every
algorithm admits an efficient solution.

00:06:24.590 --> 00:06:30.440
So, we will look at problem of intractability
and some provably hard problems and some other

00:06:30.440 --> 00:06:35.300
problems for which this status is unknown.

00:06:35.300 --> 00:06:37.140
This is an eight week course.

00:06:37.140 --> 00:06:43.020
The tentative schedule is as follows: in the
first week, we will do some motivating examples

00:06:43.020 --> 00:06:48.990
and we will look at some notations and work
out some problems involving asymptotic complexity.

00:06:48.990 --> 00:06:52.960
In the second week, we will move on to searching
and sorting.

00:06:52.960 --> 00:06:59.420
In the third week, we will introduce graphs
and look at basic graph algorithms.

00:06:59.420 --> 00:07:02.210
We will continue with more graph algorithms.

00:07:02.210 --> 00:07:08.590
And then in the process, introduce the disjoint
set data structure.

00:07:08.590 --> 00:07:12.310
We will then formally look at divide and conquer,
which you would have already seen along the

00:07:12.310 --> 00:07:13.310
way.

00:07:13.310 --> 00:07:14.420
But we will look at it again.

00:07:14.420 --> 00:07:16.240
And then we will introduce heaps.

00:07:16.240 --> 00:07:23.010
In the sixth week, we will do search trees
and some examples of greedy algorithms and

00:07:23.010 --> 00:07:24.010
their proofs.

00:07:24.010 --> 00:07:27.980
In the seventh week, we will be devoted to
dynamic programming.

00:07:27.980 --> 00:07:30.620
And then in the last week we will cover miscellaneous
topics.

00:07:30.620 --> 00:07:34.190
Now, you should remember that this is only
an approximate schedule and there will be

00:07:34.190 --> 00:07:35.190
some variations.

00:07:35.190 --> 00:07:39.660
But roughly this is the sequence and the speed
at which we plan to cover the material in

00:07:39.660 --> 00:07:40.660
the course.

00:07:40.660 --> 00:07:43.400
You can also see alongside the weeks.

00:07:43.400 --> 00:07:44.930
The calendar weeks that these correspond to.

00:07:44.930 --> 00:07:48.870
So, to the first week of the course is the
current week which is January fifth to ninth.

00:07:48.870 --> 00:07:54.260
And this course will go on till the last week
of February.

00:07:54.260 --> 00:07:57.360
Now as part of the evaluation for the course,
there will be continuous evaluations.

00:07:57.360 --> 00:07:58.460
Every week, there will be quizzes.

00:07:58.460 --> 00:08:03.810
There will also be programming assignments;
roughly six programming assignments across

00:08:03.810 --> 00:08:05.760
the eight weeks.

00:08:05.760 --> 00:08:11.200
After the course ends, there will be a certification
exam.

00:08:11.200 --> 00:08:15.540
In order to get a certificate that you have
successfully completed this course, you need

00:08:15.540 --> 00:08:20.480
to score 60 percent in the quizzes and in
the certification exam.

00:08:20.480 --> 00:08:24.900
You need to submit at least five or six; out
of the six assignments.

00:08:24.900 --> 00:08:32.080
And at least, four of them you must do something
non-trivial.

00:08:32.080 --> 00:08:34.060
We will be following two main text books.

00:08:34.060 --> 00:08:37.800
Although, I will not use the text books directly
in the course, but if you want to look up

00:08:37.800 --> 00:08:40.129
some materials you will find them in these
two books.

00:08:40.129 --> 00:08:44.509
The first book is called ÒAlgorithm designÓ
by Jon Kleinberg and Eva Tardos.

00:08:44.509 --> 00:08:50.120
And the second book is just called ÒAlgorithmsÓ
by Sanjay Dasgupta, Christos Papadimitriou

00:08:50.120 --> 00:08:51.709
and Umesh Vazirani.

00:08:51.709 --> 00:08:56.779
The book by Kleinberg and Tardos is more detailed
and it has a number of really nice examples

00:08:56.779 --> 00:09:00.839
to illustrate many of the concepts and quite
detailed proofs.

00:09:00.839 --> 00:09:04.050
The book by Dasgupta Papadimitriou and Vazirani
is a slimmer book.

00:09:04.050 --> 00:09:07.939
It is more easy and accessible to read on
your own.

00:09:07.939 --> 00:09:11.399
But on the other hand it does leave a lot
of details as exercises.

00:09:11.399 --> 00:09:15.839
So, in order to really understand the material,
you really need to spend more time working

00:09:15.839 --> 00:09:19.819
out the exercises and not just go by the material
that presented in the chapters.

