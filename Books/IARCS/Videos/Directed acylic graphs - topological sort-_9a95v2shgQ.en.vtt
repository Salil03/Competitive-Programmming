WEBVTT
Kind: captions
Language: en

00:00:01.339 --> 00:00:05.790
We now turn our attention to a very interesting
and important class of graphs called Directed

00:00:05.790 --> 00:00:09.059
Acyclic Graphs or DAGs.

00:00:09.059 --> 00:00:14.370
So, to motivate this class of graphs, let
us look at a problem where we have a bunch

00:00:14.370 --> 00:00:20.280
of tasks to perform with some constraints.
Suppose, we are going on a foreign trip, then

00:00:20.280 --> 00:00:25.960
of course, we need a passport, we need to
buy a ticket, we require a visa probably,

00:00:25.960 --> 00:00:32.040
we want to buy some travel insurance, we probably
need some foreign exchange as well and perhaps

00:00:32.040 --> 00:00:35.260
you want to buy some gifts for our hosts.

00:00:35.260 --> 00:00:41.190
Now, these tasks are dependent on each other
in certain ways, without a passport you cannot

00:00:41.190 --> 00:00:47.360
buy a ticket, not even buy any travel insurance.
For the visa, you need both the ticket and

00:00:47.360 --> 00:00:52.079
the insurance to be available and without
a visa, the bank will not give you foreign

00:00:52.079 --> 00:00:58.580
exchange. And finally, you would not like
to buy gifts for your hosts, unless the trip

00:00:58.580 --> 00:01:02.410
is confirmed. So, unless you have all these
things including the visa in hand, you do

00:01:02.410 --> 00:01:04.470
not want to invest in the gift.

00:01:04.470 --> 00:01:13.350
So, our goal is that given these constraints
in what sequence should we perform these six

00:01:13.350 --> 00:01:19.119
operations, getting a passport, buying a ticket,
getting insurance, getting a visa, buying

00:01:19.119 --> 00:01:24.700
foreign exchange and buying gifts for our
hosts. What sequence should we do it, so that

00:01:24.700 --> 00:01:33.750
whenever we want to approach a task, the constraints
that are required for the task are satisfied.

00:01:33.750 --> 00:01:40.630
So, as you would expect we will model this
using a graph. In this graph, the vertices

00:01:40.630 --> 00:01:49.639
will be the tasks and then you will have an
edge pointing from T 1 to T 2, if T 1 must

00:01:49.639 --> 00:01:55.149
come before T 2, in other words T 2 depends
on T 1 you cannot do T 2 unless T 1 has been

00:01:55.149 --> 00:02:00.299
completed. So, as an example getting a passport
must come before buying a ticket, so if T

00:02:00.299 --> 00:02:06.490
1 is getting a passport, T 2 could be getting
a ticket. Similarly, you must buy a, have

00:02:06.490 --> 00:02:11.269
a visa before you buy foreign exchange. So,
there will be an edge from getting a visa

00:02:11.269 --> 00:02:12.989
to buying foreign exchange.

00:02:12.989 --> 00:02:19.469
So, if we look at the constraints that we
wrote this is the graph that we had, so we

00:02:19.469 --> 00:02:23.480
had a constraints with says we need a passport
to buy a ticket, we need a passport to buy

00:02:23.480 --> 00:02:28.950
insurance, we need both a ticket and insurance
to get a visa. So, there are two constraints

00:02:28.950 --> 00:02:33.409
pointing to visa. Then, you need a visa to
buy foreign exchange and finally, we said

00:02:33.409 --> 00:02:38.470
we will buy a gift only if the trip is confirmed
and at some point at this stage when all these

00:02:38.470 --> 00:02:41.659
operations are done, we can assume that the
trip is confirmed, because nothing is blocking

00:02:41.659 --> 00:02:47.780
us getting on the plane.
So, this is a graph that we have and now our

00:02:47.780 --> 00:02:53.549
goal is to sequence these six operations,
in such a way that whenever we want to perform

00:02:53.549 --> 00:02:58.129
a task, whatever it depends on has already
been done. So, we can see that you need a

00:02:58.129 --> 00:03:02.871
passport to do anything, so we always need
to start with getting a password. Now, there

00:03:02.871 --> 00:03:07.200
is no dependency between buying a ticket and
buying insurance as per the constraints we

00:03:07.200 --> 00:03:12.370
have, so far. So, after password you can either
buy a ticket first and then buy insurance

00:03:12.370 --> 00:03:15.500
or you can buy insurance first and then buy
a ticket.

00:03:15.500 --> 00:03:20.069
So, there is a different ordering possible
which does not violate the constraints, on

00:03:20.069 --> 00:03:25.870
the other hand for a visa we need both. So,
visa must come after both ticket and insurance,

00:03:25.870 --> 00:03:31.269
but again having done the visa, then there
is no constraint between buying the foreign

00:03:31.269 --> 00:03:35.080
exchange and buying gifts. So, you could do
the foreign exchange before the gift or the

00:03:35.080 --> 00:03:39.499
gift before the foreign exchange, so there
are, in this particular example there are

00:03:39.499 --> 00:03:43.480
two possible ways of reordering the ticket
and the insurance and there are two possible

00:03:43.480 --> 00:03:47.569
ways of reordering the gifts and the foreign
exchange. So, overall there are four different

00:03:47.569 --> 00:03:51.920
sequences which are compatible with these
constraints.

00:03:51.920 --> 00:03:59.620
So, this class of graph is an important class
and it has two important features, one is

00:03:59.620 --> 00:04:03.660
of course, it is directed. Because, these
dependencies are from one task to another

00:04:03.660 --> 00:04:09.749
task, it is not a symmetric dependency and
there are no cycles. See, if you had a cycle

00:04:09.749 --> 00:04:13.829
it would been that group of tasks depend on
each other, so there is no way to start, because

00:04:13.829 --> 00:04:17.620
each task depends on something else in the
cycle. So, you have to break the cycle somewhere

00:04:17.620 --> 00:04:20.880
in order to get started, but you cannot break
it anywhere, because each task depends on

00:04:20.880 --> 00:04:26.030
something else in the cycle. So, this graph
will have directions on the edges and there

00:04:26.030 --> 00:04:28.440
cannot be any cycles in this graph.

00:04:28.440 --> 00:04:35.759
So, we call such a graph a directed acyclic
graph, so a directed acyclic graph is just

00:04:35.759 --> 00:04:40.860
a directed graph, in which there is no directed
path from any vertex back to itself. So, if

00:04:40.860 --> 00:04:45.740
I started any vertex V, it should not be the
case that I can follow a sequence of directed

00:04:45.740 --> 00:04:50.770
edges in the same direction and somehow come
back to v. So, this should not be there, so

00:04:50.770 --> 00:04:57.080
there should not be this cycle, we abbreviate
the name Directed Acyclic Graph as DAG.. So,

00:04:57.080 --> 00:05:01.960
very often for simplicity we will call these
graphs DAGs.

00:05:01.960 --> 00:05:09.770
So, the problem that we had adressed in our
example is that we are given a set of tasks

00:05:09.770 --> 00:05:14.900
and we want to write them out in a sequence
which respects the constraints, the constraints

00:05:14.900 --> 00:05:19.430
are nothing but, the edges. So, in general
we are given a set of vertices these are our

00:05:19.430 --> 00:05:25.750
tasks abstractly 1 to n and we want to write
out 1 to n in such a way that the constraints

00:05:25.750 --> 00:05:29.740
are respected. What this means is, that we
will write out a sequence of numbers which

00:05:29.740 --> 00:05:34.810
is a permutation of 1 to n. In such a way
that whenever there is a constraint of the

00:05:34.810 --> 00:05:40.180
form j k that is there is an edge j k, then
in the enumeration that we have performed

00:05:40.180 --> 00:05:45.750
j must come before k. So, it cannot be that
we have to do j before k according to our

00:05:45.750 --> 00:05:52.009
constraint, but in the sequence that we produce
k happens before j. So, the order of vertices

00:05:52.009 --> 00:05:58.150
in the final sequence must respect the constraints
given by the DAG, so for various reasons this

00:05:58.150 --> 00:06:02.890
is known as topologically sorting the DAG.

00:06:02.890 --> 00:06:10.849
So, the first observation is that if the directed
graph had a cycle, then you will not be able

00:06:10.849 --> 00:06:15.830
to topologically order it. Because, if it
had a cycle then for instance supposing j

00:06:15.830 --> 00:06:19.650
and k are vertices on the cycle, then you
will have a path from j to k and a path from

00:06:19.650 --> 00:06:25.759
k to j. Now, it is easy to see that the topological
ordering constraint extends to paths that

00:06:25.759 --> 00:06:32.000
is if I have j before k as an edge, I know
that j must appear before k in the final sequence,

00:06:32.000 --> 00:06:35.810
also if it has the path from j to k, then
there is a sequence of dependencies from j

00:06:35.810 --> 00:06:39.949
to k. So, j must appear before k.
Now, if I have a cycle it says that j must

00:06:39.949 --> 00:06:45.510
come before k and k must come before j. So,
there is no way to break this dichotomy, so

00:06:45.510 --> 00:06:51.010
we will end up with a situation where we cannot
order this set of tasks to respect the constraints.

00:06:51.010 --> 00:06:57.479
So, if the graph has cycles, then it is clear
that there is no topological ordering possible.

00:06:57.479 --> 00:07:05.030
So, what we claim; however, is that for DAGs
that is if there is no cycle, the graph is

00:07:05.030 --> 00:07:13.039
actually acyclic then we can always order
it topologically. So, the strategy is to order

00:07:13.039 --> 00:07:18.631
the vertices as follows, you first list all
the vertices which have no dependencies. In

00:07:18.631 --> 00:07:22.330
our earlier example, the vertex which had
no dependencies was getting a passport, we

00:07:22.330 --> 00:07:26.150
did not need to do anything before getting
a passport, so we can do that first.

00:07:26.150 --> 00:07:31.919
Now, once we have knocked off the dependency
you see any vertex from which all its dependencies

00:07:31.919 --> 00:07:37.319
are now satisfied and then we can enumerate
that. So, we can systematically list out vertices

00:07:37.319 --> 00:07:41.409
with no incoming edges, then vertices all
of whose incoming edges have already been

00:07:41.409 --> 00:07:44.600
accounted for in our enumeration and so on.

00:07:44.600 --> 00:07:52.360
So, to formalize this notion we introduce
some terminology, so recall that for an undirected

00:07:52.360 --> 00:07:58.150
graph, we use the term degree of v to refer
to the number of vertices connected to v.

00:07:58.150 --> 00:08:03.250
So, if v was connected by an edge to 4 vertices,
then we would say that the degree of v is

00:08:03.250 --> 00:08:08.030
4. Now, since we have a directed graph we
have directions on the edges, we have some

00:08:08.030 --> 00:08:12.669
edges which are coming in and some edges which
are going out. So, we separate out the degree

00:08:12.669 --> 00:08:17.509
in to the indegree and the outdegree. So,
the indegree is the number of edges pointing

00:08:17.509 --> 00:08:24.780
into v directed into v, the outdegree of v
is a number of edges pointing out of v.

00:08:24.780 --> 00:08:32.190
So, our first claim is that every DAG has
at least one vertex with indegree 0, in terms

00:08:32.190 --> 00:08:38.760
of our example a vertex with indegree 0 is
something which has no dependencies, nothing

00:08:38.760 --> 00:08:44.130
it does not depend on anything, there is nothing
pointing into it. Now, how do we prove this.

00:08:44.130 --> 00:08:50.320
Now supposing we start with any vertex v such
that it has indegree greater than 0, since

00:08:50.320 --> 00:08:56.840
it has something pointing into it, then it
must have some edge coming into it, so let

00:08:56.840 --> 00:08:59.820
us call that v 2.
Now, supposing this does not have indegree

00:08:59.820 --> 00:09:04.850
0, then it must also have something pointing
into it. So, then I get a third vertex, so

00:09:04.850 --> 00:09:09.580
in this way if I keep finding that the vertices
I am encountering have indegree greater than

00:09:09.580 --> 00:09:17.720
0, eventually I must enumerate all the vertices
in my graph. Now, if there is still not the

00:09:17.720 --> 00:09:22.330
case that the nth vertex, there are n vertices,
the nth vertex still does not have indegree

00:09:22.330 --> 00:09:26.330
0 then it must have an incoming edge, but
that cannot be from a new vertex. So, it must

00:09:26.330 --> 00:09:30.130
point from one of the existing vertices which
I have already seen before.

00:09:30.130 --> 00:09:37.100
So, therefore, if I have a continuous sequence
of vertices all of which are pointing to the

00:09:37.100 --> 00:09:41.710
previous one with indegree not equal to 0,
then I will end up with a cycle, but this

00:09:41.710 --> 00:09:47.060
is a contradiction, because we have an acyclic
graph. So, in any directed acyclic graph,

00:09:47.060 --> 00:09:53.760
there must be at least one vertex with indegree
0 which corresponds to a task with no dependencies

00:09:53.760 --> 00:09:59.420
from where we can start our enumeration of
the tasks.

00:09:59.420 --> 00:10:05.720
So, this is a more elaborate version of the
algorithm that we described earlier. So, we

00:10:05.720 --> 00:10:13.760
pick a vertex with indegree 0, we call that
such a vertex has no dependencies, now we

00:10:13.760 --> 00:10:18.630
enumerate it because it now has, it is available
for enumeration and then we delete it from

00:10:18.630 --> 00:10:25.940
the graph. So, when we delete a vertex with
indegree 0 from a graph so supposing we have

00:10:25.940 --> 00:10:31.370
a DAG like this. So, supposing we pick this
one and we delete it, then clearly what remains

00:10:31.370 --> 00:10:35.270
is a DAG.
Because, it is still directed and we have

00:10:35.270 --> 00:10:39.950
not introduced any cycle, so it was already
acyclic and by deleting an edge we cannot

00:10:39.950 --> 00:10:44.080
introduce a cycle. So, clearly it is a DAG,
so we can apply the same criterion, this new

00:10:44.080 --> 00:10:48.640
DAG must also have at least one degree with...
vertex with indegree 0. So, we can enumerate

00:10:48.640 --> 00:10:54.390
that and keep going, so we keep enumerating
vertices with indegree 0 untill the DAG becomes

00:10:54.390 --> 00:11:01.730
empty, each vertex we enumerate we will delete
from the DAG.

00:11:01.730 --> 00:11:10.500
So, let us apply the strategy to this DAG,
so we first begin by labelling every vertex

00:11:10.500 --> 00:11:15.790
by its in degree. So, in red we have indicated
the in degree of every vertex. So, for instance

00:11:15.790 --> 00:11:20.931
1 and 2 have no incoming edges. So, they have
indegree 0, vertex 3 has 2 edges coming in

00:11:20.931 --> 00:11:27.950
so it has indegree 2, vertex 8 has 4 edges
coming in so it has indegree 4 and so on,

00:11:27.950 --> 00:11:33.360
now we have to pick a vertex of indegree 0
enumerate it and eliminate it.

00:11:33.360 --> 00:11:38.990
So, we have a choice between 1 and 2, so let
us suppose we start with 1, so we start with

00:11:38.990 --> 00:11:43.470
1 we eliminate it and now when we eliminate
it we also eliminate the edges going out of

00:11:43.470 --> 00:11:49.820
it. So, the edges coming into 3, 4 and 5 will
reduce by 1, because the vertex 1 is gone,

00:11:49.820 --> 00:11:53.960
so the edges coming into them reduce by 1
their indegrees also reduce by 1.

00:11:53.960 --> 00:11:59.900
So, what happens when we eliminate 1 is that
we enumerate it and we reduce the indegrees

00:11:59.900 --> 00:12:03.200
of 3, 4 and 5 from 2, 1 1 to 1 0 0.

00:12:03.200 --> 00:12:08.170
So, recall that before that the indegrees
were 2 1 and 1, now these edges which are

00:12:08.170 --> 00:12:13.550
coming into them have been deleted. So, when
we delete this, we also delete the incoming

00:12:13.550 --> 00:12:14.550
edges.

00:12:14.550 --> 00:12:19.350
So, now we have 1 0 0, now we have three choices,
the original one which had indegree 0 and

00:12:19.350 --> 00:12:25.980
we have two new vertices 4 and 5 which correspond
to tasks if you want to call them, whose prerequisites

00:12:25.980 --> 00:12:32.430
have been completed. So, tasks 1 was the only
prerequisite for 4, task 1 was the only prerequisite

00:12:32.430 --> 00:12:36.430
for 5 it has been completed. So, 4 and 5 are
now available, so we can choose any of 2,

00:12:36.430 --> 00:12:42.010
4 and 5 it does not matter. So, let us suppose
we choose 4 then again these two edges will

00:12:42.010 --> 00:12:47.150
go. So, this will reduce to 1 and this will
reduce to 3.

00:12:47.150 --> 00:12:53.480
So, we can do that eliminate 4 and reduce
the indegree of 6 from 2 to 1 in degree of

00:12:53.480 --> 00:12:58.710
8 from 4 to 3, now perhaps we decide to eliminate
task 2.

00:12:58.710 --> 00:13:04.850
So, when you do task 2 then the indegree of
3 reduces and the indegree of 8 again reduces.

00:13:04.850 --> 00:13:11.130
So, notice that 8 still has two pending requirements
namely 5 and 7, so it cannot be done yet,

00:13:11.130 --> 00:13:13.060
but 3 and 5 are available.

00:13:13.060 --> 00:13:19.670
So, perhaps I do 5, so now 8 has 1 and now
have no choice, the only task with indegree

00:13:19.670 --> 00:13:24.180
0 is 3. So, then I do 3, so now I can see
that this is actually the way it is drawn

00:13:24.180 --> 00:13:29.700
is that is the sequence, I must do 3 before
6, 6 before 7, 7 before 8. So, I no choice

00:13:29.700 --> 00:13:32.300
at this point I must enumerate it as 3.

00:13:32.300 --> 00:13:33.580
Then, 6.

00:13:33.580 --> 00:13:34.860
Then, 7.

00:13:34.860 --> 00:13:36.200
Then finally, 8.

00:13:36.200 --> 00:13:40.970
At this point my graph is empty and I have
obtained a sequence of vertices which is a

00:13:40.970 --> 00:13:46.140
valid topological ordering, because every
pair of vertices which occur as an edge in

00:13:46.140 --> 00:13:52.140
my original graph is ordered, so that source
of the edge appears before the target of the

00:13:52.140 --> 00:13:53.140
edge.

00:13:53.140 --> 00:13:58.660
So, let us look at some pseudo code for the
algorithm which we just executed by hand.

00:13:58.660 --> 00:14:05.000
So, in this particular algorithm we first
start by computing the indegree, so in order

00:14:05.000 --> 00:14:10.410
to compute the indegree, we need to find out
how many for a vertex i we need to find out

00:14:10.410 --> 00:14:15.250
how many j satisfy the property that A j i
is equal to 1, because this corresponds to

00:14:15.250 --> 00:14:21.640
an edge from j to i. So, in an adjacency matrix
this corresponds to looking at the column

00:14:21.640 --> 00:14:25.010
containing i.
Because, in the column containing i, we will

00:14:25.010 --> 00:14:33.210
have entries of the form A 1 i, A 2 i and
so on. So, we will have these entries and

00:14:33.210 --> 00:14:37.260
we want to scan all of these and then add
up all the 1s. So, we start by setting indegree

00:14:37.260 --> 00:14:43.780
equal to 1, indegree i equal to 0 and then
for every row j we add A j i. So, it is either

00:14:43.780 --> 00:14:48.110
0 or 1 and so we therefore, collect all the
incoming edges which are pointing to i as

00:14:48.110 --> 00:14:54.150
the in degree of i, now we start enumerating.
So, we know this is a DAG, so we know there

00:14:54.150 --> 00:14:56.890
is at least one j with indegree 0 at every
point.

00:14:56.890 --> 00:15:03.080
So, we choose any such j, choose a j which
has indegree 0 enumerate it, now when we enumerate

00:15:03.080 --> 00:15:08.610
we want to eliminate it from the graph. Rather
than, going and actually modifying the graph

00:15:08.610 --> 00:15:13.710
itself, we will just work with indegree as
a kind of approximate version of the modified

00:15:13.710 --> 00:15:18.661
graph. So, we first set the indegree to minus
1 for this particular vertex. So, minus 1

00:15:18.661 --> 00:15:21.960
means it cannot be in the graph, because you
cannot have minus 1 edges pointing you can

00:15:21.960 --> 00:15:25.870
have at least 0 edges or more.
So, this effectively means that j is not going

00:15:25.870 --> 00:15:31.210
to be considered henceforth and now for every
outgoing edge from j. So, wherever we have

00:15:31.210 --> 00:15:36.090
j pointing to k we want to decrement this,
because we are going to eliminate this edge

00:15:36.090 --> 00:15:40.331
by eliminating j, we eliminate this edge.
So, for every k from 1 to n we scan all the

00:15:40.331 --> 00:15:46.030
outgoing neighbours of j and if j k is an
edge A j k is 1 we reduce the indegree of

00:15:46.030 --> 00:15:48.630
k by 1.

00:15:48.630 --> 00:15:55.000
So, what is the complexity of the algorithm
it is fairly easy to see that for this adjacency

00:15:55.000 --> 00:15:59.890
matrix representation it is n square, as we
saw initializing the indegree itself takes

00:15:59.890 --> 00:16:04.730
time n square, right. Because, we have an
outer loop from 1 to n and then for each outer

00:16:04.730 --> 00:16:10.051
loop we have an inner loop from 1 to n, so
this is an n squared loop. And then, when

00:16:10.051 --> 00:16:14.600
we enumerate the vertices again we have an
outer loop which will enumerate every vertex

00:16:14.600 --> 00:16:19.170
once.
And then for the inner loop, we have to enumerate

00:16:19.170 --> 00:16:23.970
check all it is neighbours and decrement.
So, we have 2 n square loops and therefore,

00:16:23.970 --> 00:16:28.430
this whole thing takes order n square.

00:16:28.430 --> 00:16:38.000
Now, we can as we saw with BFS and DFS, if
we use an adjacency list we can be a little

00:16:38.000 --> 00:16:43.980
more clever and we can bring down this time
to linear from n square we can bring it down

00:16:43.980 --> 00:16:49.700
to order n plus m. So, how do we do this?
Well, we be have this list, so we have list

00:16:49.700 --> 00:16:59.350
say 1, 2 and for each of these we have a list
of its neighbours. So, if you go through this

00:16:59.350 --> 00:17:03.890
as we said each edge in this, now this is
a directed graph. So, each edges is represented

00:17:03.890 --> 00:17:10.819
only once if there is an edge from i to j
it will appear as an entry j in the list for

00:17:10.819 --> 00:17:14.309
i.
So, if you scan these lists every time we

00:17:14.309 --> 00:17:18.549
see a j, we know there is an edge pointing
into j and we will increment. So, we start

00:17:18.549 --> 00:17:23.779
of by setting all the indegrees to 0, we scan
all the lists and every time we see an entry

00:17:23.779 --> 00:17:28.480
in a list, we increment its indegree. So,
in one scan of the list that is in time order

00:17:28.480 --> 00:17:35.379
m, we can find the indegrees. Now, we have
the list of indegrees, so we can put all the

00:17:35.379 --> 00:17:40.270
indegree vertices into a queue, this makes
it easy to find which vertex to enumerate

00:17:40.270 --> 00:17:43.881
next.
So, at the end of this scan we have done an

00:17:43.881 --> 00:17:49.629
order m scan to find all the indegrees, now
and in an order n scan we can put all the

00:17:49.629 --> 00:17:54.820
0 degree vertices in to a queue. Now, we can
do the rest pretty much as we did much before,

00:17:54.820 --> 00:17:59.799
we enumerate the first vertex in the queue
and then we go to its list which is now explicitly

00:17:59.799 --> 00:18:04.659
available to us in this adjacency list its
outgoing neighbours, decrement its indegree

00:18:04.659 --> 00:18:07.460
and if any of those indegrees become 0 we
can add it to the queue.

00:18:07.460 --> 00:18:13.730
So, we know it is to be processed now, so
this becomes overall it takes order m time

00:18:13.730 --> 00:18:19.129
to scan the list it takes order n time to
start the queue of and then this is a loop

00:18:19.129 --> 00:18:24.790
of order n where across all the updates we
will overall update indegrees order m times,

00:18:24.790 --> 00:18:26.409
so this is order n plus m.

00:18:26.409 --> 00:18:33.120
So, here is the corresponding pseudo code,
so the first step is to initialise the in

00:18:33.120 --> 00:18:41.370
degree to 0 for every vertex in our graph,
then we go through all the edges. So, we do

00:18:41.370 --> 00:18:46.799
this by looking at each adjacency list. For
each vertex we look at each neighbour i, j

00:18:46.799 --> 00:18:51.629
and the adjacency list and for each of these
we increment the indegree of j, because we

00:18:51.629 --> 00:18:56.240
are looking at edges pointing into j, not
pointing out of i. So, this pointing into

00:18:56.240 --> 00:18:59.409
j will come in different list.
But, as and when we encounter them for each

00:18:59.409 --> 00:19:03.590
of them we will account for them and add one
to it. Now, we go through the list one more

00:19:03.590 --> 00:19:09.779
time the list of vertices and every time will
see an indegree 0 we add i to the queue. And

00:19:09.779 --> 00:19:14.850
now we do this loop, till the queue becomes
empty we know there is at least one at every

00:19:14.850 --> 00:19:18.309
point remember as long as the graph the DAG
is not an empty, we know there is at least

00:19:18.309 --> 00:19:25.169
one indegree vertex with indegree 0. So, it
must be in the queue, because we adding them

00:19:25.169 --> 00:19:28.480
all initially to the queue and each one we
generate we will add to the queue.

00:19:28.480 --> 00:19:33.110
So, as long as the queue is not empty we take
of the first element of the queue, then we

00:19:33.110 --> 00:19:38.610
look at its adjacency list, decrement the
indegrees of all those vertices and if any

00:19:38.610 --> 00:19:44.159
of them happens to now become indegree 0,
we add it to the queue. So, this becomes now

00:19:44.159 --> 00:19:49.760
a linear implementation of topological sort,
using adjacency list and a queue to process

00:19:49.760 --> 00:19:55.360
the elements. Because, the reason why we need
this queue is that otherwise we have to scan

00:19:55.360 --> 00:20:00.150
all the vertices every time to determine whether
a vertex has become indegree 0, then that

00:20:00.150 --> 00:20:03.600
becomes an order n scan within this so it
becomes order n square again.

00:20:03.600 --> 00:20:08.460
So, we need the queue to make sure that we
do not spend time trying to identify the next

00:20:08.460 --> 00:20:13.250
vertex to enumerate. We do not have to go
through all the vertices and check the indegrees,

00:20:13.250 --> 00:20:16.960
when we see the indegree 0 we put it into
the queue. So, automatically it will come

00:20:16.960 --> 00:20:21.250
out without having to do any further check.
So, it gets observed in this order m work

00:20:21.250 --> 00:20:21.879
that we are doing here.

