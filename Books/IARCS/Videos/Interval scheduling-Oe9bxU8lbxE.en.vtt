WEBVTT
Kind: captions
Language: en

00:00:01.910 --> 00:00:05.430
Let us take another look at greedy algorithms.

00:00:05.430 --> 00:00:11.590
So, we are looking at algorithms where we
need to achieve a global optimum by making

00:00:11.590 --> 00:00:18.310
a sequence of choices. So, in a greedy strategy
what we do is we make the next choice based

00:00:18.310 --> 00:00:22.840
on some local criteria. So, there maybe a
number of choices we could make, but we just

00:00:22.840 --> 00:00:27.460
pick one of them based on something which
looks good at the moment and now we never

00:00:27.460 --> 00:00:32.870
go back and revise an earlier decision.
So, we deterministically search through this

00:00:32.870 --> 00:00:38.110
space of solutions by picking of good choice
at each step and this drastically reduces

00:00:38.110 --> 00:00:43.020
the space in which we have to search. So,
the tricky thing is that, this strategy very

00:00:43.020 --> 00:00:48.629
often does not work. So, if you have a greedy
strategy in mind, we need to go back and prove

00:00:48.629 --> 00:00:53.930
that the way we made our local choices actually
achieves the global optimum.

00:00:53.930 --> 00:01:00.649
So, we have seen three algorithms so far which
follow this greedy paradigm. The first was

00:01:00.649 --> 00:01:06.730
DijkstraÕs algorithm for the single source
shortest path problem. So, recall that in

00:01:06.730 --> 00:01:14.440
this algorithm we kept burning vertices and
at each stage we froze the distance to the

00:01:14.440 --> 00:01:19.690
nearest unburnt vertex and claim that this
would in fact be the shortest distance to

00:01:19.690 --> 00:01:24.920
that vertex from the source. So, globally
the optimum we achieved in this algorithm

00:01:24.920 --> 00:01:29.530
is that the distance assigned by this greedy
strategy happens to be the shortest distance

00:01:29.530 --> 00:01:31.290
from the source.

00:01:31.290 --> 00:01:39.970
A closely related algorithm is PrimÕs algorithm
for the minimum cost spanning tree. So, here

00:01:39.970 --> 00:01:46.060
we incrementally build up a tree and at each
stage we add to this spanning tree, the nearest

00:01:46.060 --> 00:01:52.000
vertex that is not yet in the tree. And here
the global optimum that we achieved is that

00:01:52.000 --> 00:01:59.180
we construct the spanning tree that is minimum
cost. Another algorithm for a minimum cost

00:01:59.180 --> 00:02:03.820
spanning tree is KruskalÕs algorithm.
Here, we do not build up a tree directly,

00:02:03.820 --> 00:02:09.280
but rather we keep collecting edges and form
a connected component overall which becomes

00:02:09.280 --> 00:02:16.400
a tree. So, here we keep adding to the current
set of edges in our set, the next smallest

00:02:16.400 --> 00:02:21.850
edge that does not form a cycle with those
at we have already choose and now the global

00:02:21.850 --> 00:02:30.320
optimum is that the edges that we collect
in this way form a minimum cost spanning tree.

00:02:30.320 --> 00:02:38.530
So, now let us look at a completely different
problem, a problem called interval scheduling.

00:02:38.530 --> 00:02:44.920
So, suppose we have a special video class
room, where we can deliver online lectures.

00:02:44.920 --> 00:02:50.810
Now, different teachers want to book the class
room to deliver classes and each instructor

00:02:50.810 --> 00:02:56.430
has a slot that he would like to deliver this
lecture in. So, instructor i has a slot, let

00:02:56.430 --> 00:03:03.650
us starts at a time s i and finishes it at
f i. So, you have a slot which starts at s

00:03:03.650 --> 00:03:10.880
i and finishes at f i, now two instructors
may have over lapping slot.

00:03:10.880 --> 00:03:16.480
So, the maybe somebody who wants the slot
like this, so the blue slot starts before

00:03:16.480 --> 00:03:21.570
the red slot ends, so obviously both these
slots cannot be in given bookings, because

00:03:21.570 --> 00:03:27.310
there were interfere with each other. So,
our task is to look at the set of bookings

00:03:27.310 --> 00:03:33.950
and chooses subset which is feasible that
is no two bookings that we choose interfere

00:03:33.950 --> 00:03:40.000
with each other. So, there we maximize a number
of teachers who get to use the room.

00:03:40.000 --> 00:03:48.180
So, broadly if we follow a greedy approach,
this is what we would do. Among all the bookings

00:03:48.180 --> 00:03:53.710
that are not yet allocated and which are still
available to allocate. We will pick one based

00:03:53.710 --> 00:03:59.140
on some local strategy, then we would remove
all conflicting bookings, bookings that overlapped

00:03:59.140 --> 00:04:04.599
with this booking that with the slot that
we just allocated and somehow we have to argue

00:04:04.599 --> 00:04:09.130
that this sequence of bookings that we are
choosing maximizes the number of teachers

00:04:09.130 --> 00:04:11.600
who get to use the room.

00:04:11.600 --> 00:04:19.230
So, let us look at some typical greedy strategies
that one might want. So, one strategy might

00:04:19.230 --> 00:04:24.850
be to choose the booking whose start time
is earliest, but it is not difficult to come

00:04:24.850 --> 00:04:32.690
up with the counter example. So, if you look
at this picture, there is one long green booking

00:04:32.690 --> 00:04:37.690
it start earliest and in fact ends after all
the other bookings are made.

00:04:37.690 --> 00:04:42.840
So, if we use this greedy strategy we would
allocate this very long booking and the entire

00:04:42.840 --> 00:04:47.710
period it will be allocated to just one teacher,
whereas if we choose the booking that start

00:04:47.710 --> 00:04:53.090
a little later, then we could actually satisfied
six teachers bookings and since our goal is

00:04:53.090 --> 00:04:57.580
to maximize the number of teachers, who can
use the room that could be a better strategy.

00:04:57.580 --> 00:05:01.530
So, this greedy strategy is clearly flawed.

00:05:01.530 --> 00:05:10.050
And other greedy strategy we might think of
is to choose a booking whose interval is shortest.

00:05:10.050 --> 00:05:15.660
Once again here is a counter example, the
interval in the middle is the shortest one,

00:05:15.660 --> 00:05:20.190
but if we choose this it is in conflict with
both the other bookings, so we have to rule

00:05:20.190 --> 00:05:26.160
both of them optimum. So, if we choose a shortest
interval then we can only allocate one teacher

00:05:26.160 --> 00:05:31.570
to the room, whereas if we know the strategy
and if we choose the too longer intervals,

00:05:31.570 --> 00:05:36.949
then we can actually use the room for two
teachers and get a better optimum for the

00:05:36.949 --> 00:05:40.790
problem that we have chosen.

00:05:40.790 --> 00:05:46.650
So, the previous example suggest that there
is something to do with conflicts, so maybe

00:05:46.650 --> 00:05:54.669
we might choose bookings in terms of how many
other bookings they rule out. So, one strategy

00:05:54.669 --> 00:05:59.710
now we might think of is to choose the booking
that overlaps with the minimum number of other

00:05:59.710 --> 00:06:04.300
bookings. In other words, by choosing this
booking we rule out as few other bookings

00:06:04.300 --> 00:06:11.050
is possible. So, let us look at this example,
here the center booking overlaps with only

00:06:11.050 --> 00:06:17.040
two, this one and this one, every other booking
overlaps with at least three.

00:06:17.040 --> 00:06:22.990
So, if we choose this booking, then we rule
out the bookings on either side of it and

00:06:22.990 --> 00:06:33.090
that means, there we also, we can do either
this one or one of these. So, if we take this

00:06:33.090 --> 00:06:38.900
center booking we can do at most three bookings
overall, we cannot do the two in either side

00:06:38.900 --> 00:06:46.199
of it. So, we can either do the two extreme
ones or we can do anyone of these and anyone

00:06:46.199 --> 00:06:52.510
of these. So, we can do a total of three,
we can allocate a total three bookings among

00:06:52.510 --> 00:07:01.030
these. However, if we do not do this, if we
choose a better strategy, a better strategy

00:07:01.030 --> 00:07:08.020
would be to clearly take the four on the top.
So, we can allocate four teachers in this

00:07:08.020 --> 00:07:12.639
room, if we do not use this strategy, then
we must pick the one with the minimum number

00:07:12.639 --> 00:07:16.400
of conflicts. So, this greedy strategy also
fails.

00:07:16.400 --> 00:07:24.310
So, here is a fourth strategy, instead of
choosing the one like we begin with whose

00:07:24.310 --> 00:07:29.901
start time is earliest, let us choose the
one whose finished time is earliest. So, can

00:07:29.901 --> 00:07:36.600
we come up with the counter example or should
we instead try to prove this is correct. So,

00:07:36.600 --> 00:07:43.639
in fact this strategy does work and let us
see how we can prove it.

00:07:43.639 --> 00:07:47.890
Before we prove it, let us formally write
down the algorithm a little more clearly.

00:07:47.890 --> 00:07:55.180
So, we start with the set of bookings B and
we want to construct from this set, a subset

00:07:55.180 --> 00:08:01.539
A of accepted bookings. So, initially we have
no accepted bookings, because we just starting

00:08:01.539 --> 00:08:07.450
to build this set and now we do the following.
So, as long as we have pending bookings which

00:08:07.450 --> 00:08:13.100
are still feasible, we pick that booking which
has the smallest finishing time among the

00:08:13.100 --> 00:08:19.520
set which is still with us and we add that
to b, that to A and now having added that

00:08:19.520 --> 00:08:24.910
to A, we cannot schedule any more bookings
which overlapped with this b.

00:08:24.910 --> 00:08:31.550
So, we remove from our set capital B, all
the bookings which overlapped with the booking

00:08:31.550 --> 00:08:37.189
b that we just choose. So, each time we pick
up the next booking which is still available

00:08:37.189 --> 00:08:44.999
with the smallest finishing time and we remove
everything which is in conflict to it.

00:08:44.999 --> 00:08:53.339
So, here is an example of how our algorithm
works. So, here we have nine bookings, the

00:08:53.339 --> 00:08:58.800
blue lines indicate the bookings and the numbers
of the bookings are given above it. So, in

00:08:58.800 --> 00:09:08.290
this, the one with theÉ So, initially our
set B has all these nine bookings and our

00:09:08.290 --> 00:09:13.759
set A is initially empty. So, now what we
look at, it is a smallest finishing time among

00:09:13.759 --> 00:09:22.269
nine bookings and that happens to be 1. So,
we select 1 and then having selected 1, we

00:09:22.269 --> 00:09:27.809
find all the bookings which overlap with it.
So, 2 overlaps with 1 and stored at 6, so

00:09:27.809 --> 00:09:33.959
we will move 2 from our set and we will remove
6 from our set, so now B has been thrown to

00:09:33.959 --> 00:09:48.889
3, 4, 5, 7, 8, 9 and A has the booking number
1. So, now among this feasible set 3, 4, 5,

00:09:48.889 --> 00:09:56.560
7, 8, 9 we pick the one that ends earliest
which is 3 and then since 4 is in conflict

00:09:56.560 --> 00:10:03.149
with 3, we remove 4. So, continuing in this
way we now pick 5, because 5 is earliest one

00:10:03.149 --> 00:10:08.430
to finish and then because 7 is in conflict
with 5, we remove 7.

00:10:08.430 --> 00:10:13.779
And now we have two left, 8 and 9, but 8 finishes
before 9, we could actually pick either one,

00:10:13.779 --> 00:10:19.079
but our algorithm will pick 8, because 8 has
the shortest finishing time. So, we pick 8

00:10:19.079 --> 00:10:23.960
and then we will say that 9 is not feasible,
so we do not pick it and now we have the B

00:10:23.960 --> 00:10:34.220
is empty and A is 1, 3, 5, 8 and since B is
empty, we have no more jobs to schedule, no

00:10:34.220 --> 00:10:41.879
more bookings to honor, so the algorithm ends.
So, we have found a feasible set of four bookings

00:10:41.879 --> 00:10:46.070
that can be accommodated with in this list.

00:10:46.070 --> 00:10:53.630
So, our goal is to show that the algorithm,
the solution A produce by our algorithm is

00:10:53.630 --> 00:11:00.600
actually correct. So, suppose there is an
optimal set of bookings O, now we cannot in

00:11:00.600 --> 00:11:06.170
general assume that our solution A is identical
to O, because there maybe multiple ways of

00:11:06.170 --> 00:11:11.720
producing solutions of the same size. Remember
that all we want is a solution which allocates

00:11:11.720 --> 00:11:17.629
as many teachers as possible to rooms. So,
there maybe two different ways to allocate

00:11:17.629 --> 00:11:22.240
the same number of teachers, so we cannot
argue that A and O are identical, but it is

00:11:22.240 --> 00:11:27.959
suffices to show that A and O are of the same
size. In other words, no matter of what optimal

00:11:27.959 --> 00:11:33.480
booking is produced by some other strategy,
our strategy our greedy strategy produces

00:11:33.480 --> 00:11:36.809
one which is of the same size.

00:11:36.809 --> 00:11:45.259
So, let A be the set of bookings that our
strategy chooses and this could be the order

00:11:45.259 --> 00:11:49.940
and which we chooses, so i 1 is chosen first
and then i 2 and so on, so when i 1 is chosen

00:11:49.940 --> 00:11:55.329
and i 2 is still feasible and since i 1 was
the earliest finishing time overall, we have

00:11:55.329 --> 00:12:00.190
that the finishing of i 1 is before the starting
time of i 2, the finishing time of i 2 is

00:12:00.190 --> 00:12:07.279
before the starting time of i 3 and so on.
So, these bookings in A are in sorted order,

00:12:07.279 --> 00:12:12.800
now let us assume that we have an optimum
solution with m bookings j 1 to j m again

00:12:12.800 --> 00:12:19.189
in sorted order. So, j 1 ends before j 2 starts,
j 2 ends before j 3 starts and so on. So,

00:12:19.189 --> 00:12:25.699
our goal is to show that k in fact is the
same as m, in other words the optimum solution

00:12:25.699 --> 00:12:30.730
is of the same size as the solution that the
greedy strategy produces.

00:12:30.730 --> 00:12:40.389
So, we will actually show that for each job
in the sequence i and j, the corresponding

00:12:40.389 --> 00:12:46.519
job in the A sequence finishes no later than
the corresponding job in the O sequence. So,

00:12:46.519 --> 00:12:55.679
for every r up to k, f of i r is earlier than
or equal to f of j r. So, in this sense we

00:12:55.679 --> 00:13:00.970
are trying to argue that the greedy solution
stays ahead of any optimum solution, we may

00:13:00.970 --> 00:13:06.040
produce by any other method.
So, the proof of this claim is by induction

00:13:06.040 --> 00:13:13.429
on r. So, when we look at the first job i
1, we know that i 1 is overall the earliest

00:13:13.429 --> 00:13:21.029
finish time among all the jobs, all the bookings
in our list, since i 1 has the earliest finish

00:13:21.029 --> 00:13:25.600
time over all the bookings, it must definitely
be less than or equal to f of j 1, because

00:13:25.600 --> 00:13:29.139
j 1 cannot be smaller than the overall finish
time.

00:13:29.139 --> 00:13:39.239
Now, let us assume that we have establish
by induction that up to r minus 1, the booking

00:13:39.239 --> 00:13:45.019
i minus, i of r minus 1 has a finish time
which is earlier than booking j of r minus

00:13:45.019 --> 00:13:54.220
1. Then, we claim it must be the case that
i r finishes before j r, because if we did

00:13:54.220 --> 00:14:00.490
not have this then we would have the picture
as below. So, we have that i r minus 1 finishes

00:14:00.490 --> 00:14:06.089
before j r minus 1.
Now, suppose we claim that j r actually ends

00:14:06.089 --> 00:14:13.749
before i r, then our algorithm would at this
stage find the j r is still feasible, because

00:14:13.749 --> 00:14:19.209
it does not overlap with i r minus 1 and among
the jobs which remain j r has an earlier finishing

00:14:19.209 --> 00:14:24.670
time than i r. So, our greedy strategy would
pick j r rather than i r, so therefore the

00:14:24.670 --> 00:14:29.380
fact that we have picked i r and not j r means
that we cannot have a picture like this. It

00:14:29.380 --> 00:14:34.850
cannot be that i r ends strictly after j r,
it must end before or at the same time as

00:14:34.850 --> 00:14:37.910
j r.

00:14:37.910 --> 00:14:46.259
So, now having shown that the greedy strategy
always stays ahead, we will now claim that

00:14:46.259 --> 00:14:52.439
actually our solution must be optimum. So,
suppose that m is actually strictly greater

00:14:52.439 --> 00:15:03.439
than k, then we know that when we reach i
k, it is before j k. Now, because we have

00:15:03.439 --> 00:15:10.459
a solution which is longer than k, there is
another job after this called j k plus 1,

00:15:10.459 --> 00:15:16.509
assuming that m is strictly, because this
goes up to job booking j m. So, since this

00:15:16.509 --> 00:15:23.000
happens there must be a sequence of job, sequence
of bookings after j k, so let us look at the

00:15:23.000 --> 00:15:27.249
sequence.
Now, the claim is that this particular booking

00:15:27.249 --> 00:15:33.309
at this point is not ruled out by anything
that is happened before, so if we look at

00:15:33.309 --> 00:15:39.769
i 1 up to i k, none of these overlap with
j k plus 1, because j k plus 1 is after j

00:15:39.769 --> 00:15:46.619
k. So, i k finishes before j k and j k finishes
before j k plus 1 starts. Therefore, i k is

00:15:46.619 --> 00:15:52.069
compatible with j k plus 1, this means at
this stage B is not empty.

00:15:52.069 --> 00:16:00.439
When we have to finish in our greedy algorithm
processing i 1 to i k B is not empty, but

00:16:00.439 --> 00:16:04.019
we claim that we start with i k and the only
reason our greedy algorithm will stops is

00:16:04.019 --> 00:16:10.759
because B is empty. So, if there is a job
or a booking j k plus 1, then it cannot be

00:16:10.759 --> 00:16:15.470
that our algorithm stopped at this point,
so there is a contradiction. So, therefore

00:16:15.470 --> 00:16:21.540
we cannot have any bookings in the optimum
solution which go beyond k and therefore,

00:16:21.540 --> 00:16:25.689
m must be equal to k.

00:16:25.689 --> 00:16:30.480
So, having shown that it is correct, let us
just quickly look at how we would implement

00:16:30.480 --> 00:16:37.259
this and estimate the upper bound of the complexity.
So, initially we sort the n bookings by finishing

00:16:37.259 --> 00:16:43.730
time, this takes time n log n for n bookings
and now let us assume if the bookings are

00:16:43.730 --> 00:16:50.019
renumbered 1, 2 up to n in this sorted order.
So, booking 1 has an earliest finishing time,

00:16:50.019 --> 00:16:52.919
booking 2 has a second earliest finishing
time and so on.

00:16:52.919 --> 00:17:02.819
Now, we set up in one order n scan, an array
ST such that ST of i contains the starting

00:17:02.819 --> 00:17:09.030
time of booking array. Now, we start with
booking 1 and each time we choose a booking

00:17:09.030 --> 00:17:17.030
j, we start from j plus 1 and keeps scanning
the start time of bookings till we find the

00:17:17.030 --> 00:17:23.870
earliest k whose starting time is beyond f
of j. In other words, we are lookingÉ So,

00:17:23.870 --> 00:17:27.840
so we know that these bookings are in order
of finishing time.

00:17:27.840 --> 00:17:33.420
So, we know that after j the booking that
ends next is j plus 1, but if its starting

00:17:33.420 --> 00:17:38.370
time is not beyond the finishing time of j,
it is overlapping, so it cannot be compatible.

00:17:38.370 --> 00:17:44.960
So, we just scan this array ST until we find
the smallest k which actually starts after

00:17:44.960 --> 00:17:51.510
f j ends. So, in this way one order n scan
we can go through all our bookings and pick

00:17:51.510 --> 00:18:00.150
up a greedy optimum set. So, this is an order
n scan sorting takes order n log in, so overall

00:18:00.150 --> 00:18:03.730
this greedy strategy is correct and it takes
time O n log n.

