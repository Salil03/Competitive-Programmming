WEBVTT
Kind: captions
Language: en

00:00:01.380 --> 00:00:06.240
So, our first example was to do with airlines,
scheduling, network and using a graph.

00:00:06.240 --> 00:00:08.690
Now, let us look at a different problem.

00:00:08.690 --> 00:00:16.779
So, suppose we have a photo copy shop, campus
Xerox inside the university campus.

00:00:16.779 --> 00:00:22.150
The deadline for projects is approaching and
a bunch of student want their projects copied

00:00:22.150 --> 00:00:23.150
urgently.

00:00:23.150 --> 00:00:27.390
So, they all go and submit their reports to
the photo copying shop, and say we want so

00:00:27.390 --> 00:00:30.119
many copies made within such a time.

00:00:30.119 --> 00:00:35.400
So, now the question for the shop is how best
to schedule these jobs.

00:00:35.400 --> 00:00:38.820
Now, there are many different ways in which
this problem can be phrased.

00:00:38.820 --> 00:00:42.410
So, let us look at one of them.

00:00:42.410 --> 00:00:48.520
So, suppose these students have submitted
their jobs and this shop campus Xerox is competing

00:00:48.520 --> 00:00:49.530
against some rivals.

00:00:49.530 --> 00:00:52.290
So, it is offering a special deal.

00:00:52.290 --> 00:00:59.240
So, it says that it will give each customer
a promised delivery time and if does not meet

00:00:59.240 --> 00:01:03.080
the schedule like a pizza shop, it will give
a discount.

00:01:03.080 --> 00:01:09.469
So, I will promise your report within 6 hours
and if you do not get within 6 hours, you

00:01:09.469 --> 00:01:10.469
pay less.

00:01:10.469 --> 00:01:15.280
Now, in this time frame there are of course
some bigger jobs and some smaller jobs.

00:01:15.280 --> 00:01:21.409
So, some photo copying jobs will be faster
to finish, some will take longer, but at the

00:01:21.409 --> 00:01:26.229
same time they all have to run on the same
machines that the Xerox shop has.

00:01:26.229 --> 00:01:28.420
So, now you can reorder things.

00:01:28.420 --> 00:01:32.889
So, you could take something which came later
and put it earlier on the machine and hope

00:01:32.889 --> 00:01:34.659
to finish it within its deadline.

00:01:34.659 --> 00:01:38.890
Therefore, not to have to give discount and
take something which is going to take longer

00:01:38.890 --> 00:01:42.829
and postpone it saying, anyway you are not
going to meet the dead line and give up the

00:01:42.829 --> 00:01:45.219
discount on that job, right.

00:01:45.219 --> 00:01:51.069
So, the job, the problem the Xerox shop has
is how to do this schedule, right.

00:01:51.069 --> 00:01:57.600
So, there is always at the background what
is called brute force approach.

00:01:57.600 --> 00:02:03.569
You can say now I have to allocate these photo
copying jobs to the machines in some order.

00:02:03.569 --> 00:02:08.349
So, let me try every possible order and choose
the one which gives me the best return.

00:02:08.349 --> 00:02:12.580
The problem with this is that it will take
a very large amount of time to do this because

00:02:12.580 --> 00:02:15.200
number of possibilities is exponential.

00:02:15.200 --> 00:02:19.900
Even if you have just 30 requests pending,
it could take several hours to find an optimal

00:02:19.900 --> 00:02:23.670
schedule, and in those several hours you might
as well have gone ahead and done some work,

00:02:23.670 --> 00:02:27.780
so that you got the jobs done and perhaps
not optimally at least got some money for

00:02:27.780 --> 00:02:29.110
it.

00:02:29.110 --> 00:02:34.580
So, here is where we come to the idea of decomposition,
right.

00:02:34.580 --> 00:02:40.100
So, can we solve this problem by reducing
it to a simpler problem.

00:02:40.100 --> 00:02:44.840
So, supposing we fix one job to run first.

00:02:44.840 --> 00:02:49.040
If we fix this job to run first, we are left
with the remaining jobs, now the remaining

00:02:49.040 --> 00:02:50.970
jobs are smaller in number.

00:02:50.970 --> 00:02:55.860
So, if there was a way to optimally solve
for n minus 1 jobs, then we can pick each

00:02:55.860 --> 00:03:00.670
of the first jobs, each of the jobs to be
the first job and for each of them determine

00:03:00.670 --> 00:03:05.180
how much time it takes efficiently if we can
to do the remaining n minus 1 and choose the

00:03:05.180 --> 00:03:06.220
best one.

00:03:06.220 --> 00:03:11.730
So, this would give us a kind of recursive
solution, pick one and solve the rest and

00:03:11.730 --> 00:03:16.110
then add the time for this.

00:03:16.110 --> 00:03:21.460
Another option is to just come up with a strategy.

00:03:21.460 --> 00:03:25.880
Looking at all the jobs which are yet to be
done, we find some criterion by which we choose

00:03:25.880 --> 00:03:27.500
one to do next.

00:03:27.500 --> 00:03:32.980
Now, we could have different criteria for
instance we could choose the one to do next

00:03:32.980 --> 00:03:38.380
which has the least number of pages that will
take the shortest time to process, or we could

00:03:38.380 --> 00:03:43.420
take the one to do next which is closest to
its dead line that is one for which we are

00:03:43.420 --> 00:03:48.910
most likely to miss finishing it in time and
having to give a discount.

00:03:48.910 --> 00:03:54.270
So, for each of these, we could have a strategy
which would tell us which job to do next without

00:03:54.270 --> 00:03:58.580
looking at all the possibilities of doing
the other jobs, but then we have to justify

00:03:58.580 --> 00:04:01.580
that the strategy that we have chosen is actually
optimal.

00:04:01.580 --> 00:04:06.010
Is it better to choose shortest processing
time, is it better to choose earliest deadline

00:04:06.010 --> 00:04:11.370
or is there yet another criterion, and how
do these criteria justify the choice.

00:04:11.370 --> 00:04:17.810
Will I always get the best possible return
on my machines by choosing this strategy.

00:04:17.810 --> 00:04:25.180
Now, as we saw with the airline network problem,
the basic problem has many different variations

00:04:25.180 --> 00:04:26.650
which are possible.

00:04:26.650 --> 00:04:31.260
For instance, if we assume that the shop has
many photo copiers, it is reasonable to assume

00:04:31.260 --> 00:04:33.500
that some are new and some are old.

00:04:33.500 --> 00:04:37.100
So, ones that are new one may work faster
than the ones that are old.

00:04:37.100 --> 00:04:43.860
Therefore, the time that it takes to finish
a job depends on which machine we put the

00:04:43.860 --> 00:04:44.860
job on.

00:04:44.860 --> 00:04:50.090
So, if we have this additional complication,
does the strategy that we chose for the type

00:04:50.090 --> 00:04:56.100
that all machines are uniform, still hold,
or do we have to look at a different strategy.

00:04:56.100 --> 00:05:00.720
The other factor is of course that the cost
of doing something varies across machines.

00:05:00.720 --> 00:05:08.850
So, if we use a machine; we use some resources,
we use some ink, use paper, we use electricity

00:05:08.850 --> 00:05:11.860
and this cost may vary from one machine to
another.

00:05:11.860 --> 00:05:16.380
So, now the question becomes related to the
first question, the previous question which

00:05:16.380 --> 00:05:21.240
is that now if I split my job across machines,
it might not only take more or less time,

00:05:21.240 --> 00:05:23.100
it also may cost the shop more or less.

00:05:23.100 --> 00:05:27.990
So, the actual revenue that the shop realizes
maybe more or less depending on which machine

00:05:27.990 --> 00:05:31.260
it chooses.

00:05:31.260 --> 00:05:35.250
The other thing that we might want to keep
in mind is that a machine cannot run indefinitely

00:05:35.250 --> 00:05:39.750
without having to be stopped for some time
for maybe some maintenance, for loading paper,

00:05:39.750 --> 00:05:40.750
for something.

00:05:40.750 --> 00:05:44.480
So, we cannot realistically assume that every
machine is continuously available.

00:05:44.480 --> 00:05:50.050
Now, under all these situations, is there
still a valid greedy strategy or do we have

00:05:50.050 --> 00:05:51.530
to do something else.

00:05:51.530 --> 00:05:52.541
So, you see the general idea.

00:05:52.541 --> 00:05:57.750
The general idea is that there is a basic
problem with some constraints which you want

00:05:57.750 --> 00:06:04.660
to solve, but that problem can be amplified
or made more realistic by adding several new

00:06:04.660 --> 00:06:05.660
features.

00:06:05.660 --> 00:06:08.800
And each time you add a new feature, you have
to see whether the solution that you have

00:06:08.800 --> 00:06:14.110
for the simpler problem still works or whether
the new feature demands a radically new approach

00:06:14.110 --> 00:06:15.830
and if so how you should get that.

