WEBVTT
Kind: captions
Language: en

00:00:01.069 --> 00:00:05.180
We have seen one algorithm for the minimum
cost spanning tree namely prim's algorithm.

00:00:05.180 --> 00:00:10.549
Now, let us look at the other strategy we
talked about namely Kruskal's algorithm.

00:00:10.549 --> 00:00:17.619
So, we are looking for a minimum cost spanning
tree, in a weighted undirected graph. So,

00:00:17.619 --> 00:00:22.550
prim's algorithm starts with some edge and
gradually expands the edge into a tree, whereas

00:00:22.550 --> 00:00:27.890
Kruskal's algorithm follows the other strategy,
which is to order all the edges in ascending

00:00:27.890 --> 00:00:33.100
order of weight. So, it keeps trying edges
from smallest to largest and for every edge

00:00:33.100 --> 00:00:36.590
if it can add the edge without violating a
tree property, it adds it.

00:00:36.590 --> 00:00:40.640
Now, in the process of adding the edge, it
may not actually construct a tree, all it

00:00:40.640 --> 00:00:45.450
make sure, it does not violate the tree property,
namely, it does not produce a cycle. So, if

00:00:45.450 --> 00:00:49.530
we keep adding edges, so long as we do not
produce a cycles and at the end the claim

00:00:49.530 --> 00:00:52.410
is we get a minimum cost spanning tree.

00:00:52.410 --> 00:00:59.079
So, here is a kind of high level view of the
algorithm, so let the edges be sorted in order

00:00:59.079 --> 00:01:05.479
e 1 to e m. So, we start with an empty tree,
so again we will keep the tree as the list

00:01:05.479 --> 00:01:11.740
of edges and now we are going to scan this
in order, 1 to m. So, let i be the index of

00:01:11.740 --> 00:01:16.720
the edge to be try next. So, long as we are
not yet added n minus 1 edges. Remember that

00:01:16.720 --> 00:01:21.773
if you add n minus 1 edges and we have a connected
graph, it must be a tree. This is one of the

00:01:21.773 --> 00:01:23.680
various characterization that we said about
trees.

00:01:23.680 --> 00:01:28.280
Trees are n minus 1 edges, but any connected
graph with n minus 1 must be it. So, once

00:01:28.280 --> 00:01:33.150
we have n minus 1 edges we can stop. So, so
long as length of the tree in terms of number

00:01:33.150 --> 00:01:37.930
of edges is not n minus 1, we have to add
some more edges. So, we look at the next e

00:01:37.930 --> 00:01:44.600
i, if e i does not form a cycle when added
to TE we append, then we look at i plus 1.

00:01:44.600 --> 00:01:48.840
If it does form a cycle, we just discarded
and go ahead, this is all Kruskal's algorithms

00:01:48.840 --> 00:01:52.950
is. Scanning through all the edges and until
we have found a tree, it is just keep looking

00:01:52.950 --> 00:01:57.409
at each edge in turn in ascending order of
the weight and every time if it can add it

00:01:57.409 --> 00:02:01.289
without forming a cycle it will add it, if
cannot add it without forming a cycle it will

00:02:01.289 --> 00:02:02.289
drop it.

00:02:02.289 --> 00:02:07.680
So, let us look at the same example that we
saw for prim's algorithms. So, here this smallest

00:02:07.680 --> 00:02:14.200
edge weights, so remember that we have sorted
it in edges. So, 5 is the smallest then 6,

00:02:14.200 --> 00:02:21.850
then we have 3 of weight 10, then we have
18, then we have 20 and then we have 70. So,

00:02:21.850 --> 00:02:28.280
now if we pick among these the smallest one,
we start with edge 5 we first add the edge

00:02:28.280 --> 00:02:29.460
5 to our tree.

00:02:29.460 --> 00:02:35.090
Now, the next one is 6, so we add 6 to our
tree. Now, we have to pick one of the edges

00:02:35.090 --> 00:02:40.220
labelled 10, we can pick any one, so let us
assume that we pick this one. Now, we want

00:02:40.220 --> 00:02:45.300
to pick another edge label 10, because the
next two edges are again label 10. So, supposing

00:02:45.300 --> 00:02:51.570
we pick this edge label 10, then this edge
label 10, form this cycle.

00:02:51.570 --> 00:02:55.870
So, we cannot do it, so we discarded it, we
discard it and go to the next one. So, now

00:02:55.870 --> 00:03:01.870
we pick this one, so we throw this away and
now we will go to this one.

00:03:01.870 --> 00:03:06.450
And now this one we can add, so now we have
finished the tens, so the next one is 18,

00:03:06.450 --> 00:03:09.380
but again adding 18, we going to form a cycle.

00:03:09.380 --> 00:03:16.130
So, we discard it and now we go to the next
one which 20.

00:03:16.130 --> 00:03:23.080
Now, having added 20, then we still are not
done, because we have added we have still

00:03:23.080 --> 00:03:29.550
to add enough edges we have 1, 2, 3, 4, 5
edges and we need 6, because we have 7 vertices

00:03:29.550 --> 00:03:34.480
quickly, we get n minus 1 edges. So, the only
edge left is this 70, so we have that any

00:03:34.480 --> 00:03:38.460
way. So, this is the spanning tree form of
Kruskal's algorithm, we actually scan through

00:03:38.460 --> 00:03:42.730
all the edges in this particular case and
on the way we dropped a couple.

00:03:42.730 --> 00:03:50.160
So, Kruskal's algorithms is, also a greedy
algorithm, in this case we do not make a...

00:03:50.160 --> 00:03:54.090
So, in prim's algorithms more as Dijkstra's
algorithms, we make incremental choices, local

00:03:54.090 --> 00:03:58.770
choices at every point, we will look at what
we do next, based on what we know now. Here,

00:03:58.770 --> 00:04:03.560
we make a choice well in advance, we say right
at the beginning let us sort all the edges

00:04:03.560 --> 00:04:07.930
and do it in that order. And again it is not
clear by doing it in this particular order

00:04:07.930 --> 00:04:13.370
which is decided right at the beginning gives
us overall an optimum solution.

00:04:13.370 --> 00:04:19.200
So, once again we will use the same result
that we used for prim's algorithm, this minimum

00:04:19.200 --> 00:04:25.160
separator lemma. So, recall what the lemma
said, it said if you take a set of vertices

00:04:25.160 --> 00:04:31.080
and separate out into two non empty groups
U and W and if we take the smallest edge,

00:04:31.080 --> 00:04:34.090
now the graph is connected. So, there must
be an edge connecting these tool, we take

00:04:34.090 --> 00:04:39.220
the smallest edges which connects the two
parts together, then this edge must be there

00:04:39.220 --> 00:04:45.340
at every spanning tree, every minimum cost
spanning tree, this is what the lemma said.

00:04:45.340 --> 00:04:53.360
So now, in Kruskal's algorithm, unlike in
Prim's algorithm, at intermediate stages,

00:04:53.360 --> 00:04:58.810
we don't have a tree, we just have a collection
of components, so we'll have in our overall

00:04:58.810 --> 00:05:03.430
graph , we will have some vertices which are
connected here, then maybe someother vertex

00:05:03.430 --> 00:05:07.830
there, and another part there, and so on.
Because as we add edges, it just connects

00:05:07.830 --> 00:05:12.930
them. Okay? So whenever we add an edge in
general, it will take two currently different

00:05:12.930 --> 00:05:17.490
components and connect them. We can't add
an edge within a component because each component

00:05:17.490 --> 00:05:22.560
is like a tree. So, adding an edge in a tree,
remember forms a cycle. So, this won't happen.

00:05:22.560 --> 00:05:31.170
So, what we will do, is we will add edges
across.

00:05:31.170 --> 00:05:37.550
Now, what we know is that whenever we add
an edge, its end points are in disjoint components.

00:05:37.550 --> 00:05:43.680
So, in terms we are using the lemma, let us
call capital U to be the component containing

00:05:43.680 --> 00:05:49.890
one end point of the edge and capital W to
be the rest, whatever is outside this, so

00:05:49.890 --> 00:05:55.920
this is whatever is outside component. So,
we have U and whatever it is connected to.

00:05:55.920 --> 00:06:04.230
So, this is my set U and then I have the rest
of the vertices, so U is connected at this

00:06:04.230 --> 00:06:08.230
point to something in a different component,
but that an all the other components is what

00:06:08.230 --> 00:06:12.960
I called that W.
So, now what we know this is the first time

00:06:12.960 --> 00:06:18.910
that we are trying to connect U to V, U to
V have not been connected, so far. But, we

00:06:18.910 --> 00:06:22.780
have been looking at edges an ascending order
of weight, so if you look at all the edges.

00:06:22.780 --> 00:06:28.530
So, this current edge we are called e j, so
if you look at all the edges e 1 to e j minus

00:06:28.530 --> 00:06:33.720
1 none of them connected U to V or the component
connecting U.

00:06:33.720 --> 00:06:39.010
Because, had it component containing U to
the component containing V then we wouldn’t

00:06:39.010 --> 00:06:43.290
be adding this edge, this edge forms a cycle.
So, this is the first edge that we can use

00:06:43.290 --> 00:06:48.120
connect these two, means that no edge we have
seen, so for a connects these too. So, putting

00:06:48.120 --> 00:06:53.610
all this to together, this is the smallest
edge which connects capital U to something

00:06:53.610 --> 00:06:57.770
outside capital V.
And since is this smallest edge, the lemma

00:06:57.770 --> 00:07:03.639
tells us this must be in the tree and therefore,
Kruskal's idea of including this in tree is

00:07:03.639 --> 00:07:07.700
sound, this is an edge it must be input tree.
So, every edge the Kruskal's algorithm adds

00:07:07.700 --> 00:07:12.940
is actually a valid edge justified by the
minimum separator.

00:07:12.940 --> 00:07:18.980
So, now we have to just decide how to keep
track of this property of forming a cycle.

00:07:18.980 --> 00:07:23.380
Remember that whenever we add an edge, you
must first check if it forms a cycle and if

00:07:23.380 --> 00:07:29.360
it does not form a cycle you must include.
So, the easiest way to check, that the edge

00:07:29.360 --> 00:07:35.410
does not form a cycle is to keep track of
the components, if the edge is inserted on

00:07:35.410 --> 00:07:39.180
two different components that is one end point
of the edges and one components and one end

00:07:39.180 --> 00:07:43.290
point of the edges in other component. Then,
inductively each component is a tree and therefore,

00:07:43.290 --> 00:07:47.120
these two trees are disjoint and therefore,
the new edge does not form a cycle. If the

00:07:47.120 --> 00:07:52.110
two end points are in the same component then
it will form a cycle. So, keeping track whether

00:07:52.110 --> 00:07:56.930
are not a new edge forms a cycle is equivalent
to keeping track of components. So, how do

00:07:56.930 --> 00:08:02.740
we keep track of components, well, we can
basically label the components by numbers

00:08:02.740 --> 00:08:09.080
and it since we have n vertices and initially
there all n independent vertices with no edges

00:08:09.080 --> 00:08:13.070
in the initial starting point of Kruskal's
algorithms, everything is disconnected.

00:08:13.070 --> 00:08:17.650
So, initially we are n vertices n components,
the most natural thing to do, is to say, that

00:08:17.650 --> 00:08:24.360
each vertex i belongs to a components part
i. Now, I can add an edge u, v if the component

00:08:24.360 --> 00:08:29.960
of u is different from the component of v.
And if the component u different from components

00:08:29.960 --> 00:08:33.820
of v what happens after this is the two components
become the same. So, add some on merge the

00:08:33.820 --> 00:08:37.150
two components, in other words, I have to
give them the same label.

00:08:37.150 --> 00:08:44.111
So, this is now detailed explanation of the
algorithm, so as before we let e 1 to e m

00:08:44.111 --> 00:08:50.680
being the edges sorted by weight, initially
we say let every vertex 1 to n is in its own

00:08:50.680 --> 00:08:53.080
components for every j among to n components
of j is j. So, 1 is the components 1 and 2

00:08:53.080 --> 00:09:05.180
is components 2 and so on, now we start off
with an empty set of edges and now we are

00:09:05.180 --> 00:09:09.750
going to run through as we said before these
edges in ascending order. So, we have the

00:09:09.750 --> 00:09:14.090
index pointing to the first edge in may sorted
array, so this is my index.

00:09:14.090 --> 00:09:20.110
So, so long as we are not add it n minus edges,
we look at the i th edge in this sorted order,

00:09:20.110 --> 00:09:25.961
it is of sum u to v. If the current component
of u is different in the current component

00:09:25.961 --> 00:09:32.260
of v, then we are sure that the edge v i add
does not form a cycle. So, we add it to our

00:09:32.260 --> 00:09:36.230
tree and now we have to do this merging of
components, now what is the component of the

00:09:36.230 --> 00:09:40.500
vertex is just a number.
So, for every j in our set now the problem

00:09:40.500 --> 00:09:43.750
is that these components could have been merged
earlier. So, components of u could contain

00:09:43.750 --> 00:09:48.100
other vertices component of v could other
vertices and all of them must now we given

00:09:48.100 --> 00:09:52.540
the same component number. So, that they are
all the same component, so I have no choice,

00:09:52.540 --> 00:09:58.220
but to scan every j in my set of vertices
and whenever such a j has the same components

00:09:58.220 --> 00:10:03.520
as v I reset which component to u.
So, after this everything which has the same

00:10:03.520 --> 00:10:07.920
component number as v as got the same components
numbers u. So, therefore, effectively the

00:10:07.920 --> 00:10:13.580
two components have been merged into one component
all label by the value components of u. So,

00:10:13.580 --> 00:10:19.120
this is Kruskal's algorithms, just says keep
considering edges and if they connect different

00:10:19.120 --> 00:10:22.540
components add them and merge the components,
if they do not connect different components

00:10:22.540 --> 00:10:26.240
it will form a loop, so just throw it away.

00:10:26.240 --> 00:10:31.750
So, what is the complexity well a first step
in Kruskal's algorithms requires us to sort

00:10:31.750 --> 00:10:38.020
edges. So, we know that we can sort m edges
in m log m time, but m is at most n square,

00:10:38.020 --> 00:10:47.180
so log n will be 2 times log n. So, order
of log n is the same as order of log m. So,

00:10:47.180 --> 00:10:54.730
I can also write this is m log n, so this
will be just another way of writing. So, this

00:10:54.730 --> 00:10:59.550
sorting takes m log m time.
Now, we have an outer loop, okay, so this

00:10:59.550 --> 00:11:04.460
loop which runs here, in general runs through
all the edges in this list. Because, it could

00:11:04.460 --> 00:11:08.980
very well be that for some reason I have go
all the way the last one forms a tree. Rather,

00:11:08.980 --> 00:11:12.490
even in the example we saw of the largest
edge has to be include in the tree, because

00:11:12.490 --> 00:11:15.550
it is the only one that connects us some particular
vertices.

00:11:15.550 --> 00:11:26.050
So, we have an outer loop which runs m times,
now among these m times we will update the

00:11:26.050 --> 00:11:31.240
components for each edge we add that will
happen only n minus 1 times. But, when we

00:11:31.240 --> 00:11:35.080
update the component, that is when we have
a problem, because we have to scan through

00:11:35.080 --> 00:11:40.690
all the vertices in order to change the components
number. So, each update of the component,

00:11:40.690 --> 00:11:45.790
each merging components that it is order n
time and this itself happens n minus 1 times.

00:11:45.790 --> 00:11:50.491
Because, we have to keep doing each time we
add an edge to our tree, there are going to

00:11:50.491 --> 00:11:58.630
be exactly n minus 1. So, we have to n minus
1 updates and each update takes order n times.

00:11:58.630 --> 00:12:04.790
So, we have an overall complexity of order
n square. Now, remember that prince algorithm

00:12:04.790 --> 00:12:08.350
n square was the worst case and then we said
with the better data structure we could bring

00:12:08.350 --> 00:12:10.399
it down to n plus m log n.

00:12:10.399 --> 00:12:16.440
So, what can we do here? So, let us look at
the problem, the problem is basically this

00:12:16.440 --> 00:12:22.630
labeling strategy. Now, when we label the
components and do this linear scan we are

00:12:22.630 --> 00:12:27.160
spending order n time in order to merge components.
So, we will find just like we can use the

00:12:27.160 --> 00:12:31.310
heap for Dijkstra's algorithms and Prim’s
algorithms to find them minimum vertex to

00:12:31.310 --> 00:12:36.250
be added quicker and to update the distances,
here we will find that what we need to do

00:12:36.250 --> 00:12:43.690
is maintain this component structure.
So, assume that we want to deal with a set

00:12:43.690 --> 00:12:51.220
v which is broken up into different components.
So, it has components at any given times say

00:12:51.220 --> 00:12:56.670
call a, b, c, d, e and then you have individual
elements which belong to this components.

00:12:56.670 --> 00:13:00.720
So, some of them have many, sum of them have
one and so on. So, one of the things you want

00:13:00.720 --> 00:13:05.130
to do is given the name of vertex v, you want
to ask which components does it belong to.

00:13:05.130 --> 00:13:10.149
So, this is called find, given the v, find
the component containing v. The other thing

00:13:10.149 --> 00:13:13.570
is given two vertices.
So, suppose I am given a u and v it will say

00:13:13.570 --> 00:13:19.089
merge these two, so take these two components
and give then the same name. So, either call

00:13:19.089 --> 00:13:24.620
them all c or call them all d, so this is
called union, union does not take the components

00:13:24.620 --> 00:13:27.950
it takes two representatives, one representative
one components and one representative from

00:13:27.950 --> 00:13:31.611
the other components and themselves merge
everything which is in the components of the

00:13:31.611 --> 00:13:35.440
u with everything in component v.
And these are the two operation; obviously,

00:13:35.440 --> 00:13:41.430
that we do is Kruskal's algorithms, find v
is what we if have an edge u, v to check if

00:13:41.430 --> 00:13:45.860
they are the same component we find the component
of u write the component of v if they are

00:13:45.860 --> 00:13:48.250
the same. That means, they are in the same
component. They are different, they are in

00:13:48.250 --> 00:13:51.590
different components and we can add this edge.
Now, if you add the edge then we have to do

00:13:51.590 --> 00:13:56.740
union u v, so these are precisely a two operations
and we will find that the there is this data

00:13:56.740 --> 00:14:00.400
structure which is called union find because
of these two operations, which can actually

00:14:00.400 --> 00:14:03.420
do this efficiently.
And efficiently means what, it means it can

00:14:03.420 --> 00:14:07.840
eliminate this n square thing and bring everything
down to the cost of m log n or remember this

00:14:07.840 --> 00:14:14.040
we need to sort. Our first step was a sort
the edges for Kruskal's algorithms starts

00:14:14.040 --> 00:14:18.900
by sorting in the edges. So, m log n is something
which we need to m equal to sort the edges.

00:14:18.900 --> 00:14:24.000
In addition, these essentially this updates
as in a heap, the updates the union find reverse

00:14:24.000 --> 00:14:28.200
is actually log n. And remember that there
are going to be a these updates are happening

00:14:28.200 --> 00:14:34.029
in this iterative loop. So, we actually get
something similar to this now Prim's algorithm

00:14:34.029 --> 00:14:34.660
complexity.

