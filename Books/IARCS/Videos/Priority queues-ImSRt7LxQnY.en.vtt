WEBVTT
Kind: captions
Language: en

00:00:00.900 --> 00:00:05.980
So, we have seen how the use of a clever data
structure, the union find data structure can

00:00:05.980 --> 00:00:08.840
make Kruskal's algorithm more efficient.

00:00:08.840 --> 00:00:12.879
The other two algorithms which we need to
make efficient or Dijkstra's algorithm for

00:00:12.879 --> 00:00:17.230
the single source shortest path, and Prim's
algorithm for the minimum cost spanning tree.

00:00:17.230 --> 00:00:23.090
Both of them it turns out require a data structure
that is usually called a priority queue.

00:00:23.090 --> 00:00:27.509
So, to understand priority queues, let us
look at the following scenario.

00:00:27.509 --> 00:00:31.480
So, supposing we would have a job scheduler
running on as operating system.

00:00:31.480 --> 00:00:36.410
So, when we run multiple tasks on an operating
system each of them runs for a little bit

00:00:36.410 --> 00:00:38.970
of time, and then is opt out.

00:00:38.970 --> 00:00:44.570
So, job scheduler maintains a list of all
jobs which are pending along with their priorities.

00:00:44.570 --> 00:00:50.170
Whenever the processor is free, the scheduler
picks out a job with a maximum priority in

00:00:50.170 --> 00:00:51.340
the list and schedules it.

00:00:51.340 --> 00:00:52.340
Now what happens?

00:00:52.340 --> 00:00:53.790
Of course is this dynamic.

00:00:53.790 --> 00:00:57.400
So, while some jobs are running, other new
jobs may arrive.

00:00:57.400 --> 00:01:01.731
So, each time when new jobs arrive they will
come with different priorities, and this is

00:01:01.731 --> 00:01:06.030
the job of the scheduler to make sure that
the new jobs with higher priority come ahead

00:01:06.030 --> 00:01:08.540
of older job with lower priority.

00:01:08.540 --> 00:01:14.040
So, from a data structure point of view, our
question is what is the best way for the scheduler

00:01:14.040 --> 00:01:17.180
to maintain the list of pending jobs with
their priorities?

00:01:17.180 --> 00:01:23.970
So, that this list can be updated dynamically
as this list gets updated, as new jobs arrive

00:01:23.970 --> 00:01:24.970
from.

00:01:24.970 --> 00:01:27.890
So, this is what we call a priority queue.

00:01:27.890 --> 00:01:33.850
So, we have two basic operations in a priority
queue; the first is to extract the next job

00:01:33.850 --> 00:01:38.470
which in this case means take the job with
the highest priority, and remove it from the

00:01:38.470 --> 00:01:39.470
queue.

00:01:39.470 --> 00:01:43.010
Now of course, we have the situation where
you have multiple jobs in the same priority.

00:01:43.010 --> 00:01:47.560
So, we do not assume the priorities are unique,
but if they are not, unique then we can assume

00:01:47.560 --> 00:01:51.100
either the there is some tie-breaking rule
or we do not care which one of the highest

00:01:51.100 --> 00:01:52.380
priority jobs we get right.

00:01:52.380 --> 00:01:58.700
So, the main operation is delete max; delete
the maximum priority item from the queue.

00:01:58.700 --> 00:01:59.799
And then there is an insert.

00:01:59.799 --> 00:02:03.390
So, a job will come it will be inserted, it
will come with a priority.

00:02:03.390 --> 00:02:04.830
So, we need to insert into the list.

00:02:04.830 --> 00:02:09.910
So, that subsequent delete max take this one
in to account.

00:02:09.910 --> 00:02:16.890
So, the first solution that one could think
of to keep such a data is to maintain a list,

00:02:16.890 --> 00:02:21.060
some kind of a linear structure and array
or a list, since it is growing dynamically

00:02:21.060 --> 00:02:23.599
a list is your obvious choice.

00:02:23.599 --> 00:02:29.930
Now if we keep an unsorted list, then it is
easy to add a job, which is up to appended

00:02:29.930 --> 00:02:30.930
to the list.

00:02:30.930 --> 00:02:36.599
So, insertion is a constant time operation
takes time O1), but as we have seen many times

00:02:36.599 --> 00:02:41.200
if we have an unsorted list, then we have
to scan the entire list to find the minimum

00:02:41.200 --> 00:02:42.279
or the maximum.

00:02:42.279 --> 00:02:47.489
So, in this case if we want to do a delete
max from an unsorted list, this operation

00:02:47.489 --> 00:02:51.700
is going to take as linear time proportional
to the size of the list or the number of jobs

00:02:51.700 --> 00:02:53.450
that are pending at the moment.

00:02:53.450 --> 00:02:59.919
So, the only useful thing one can do with
the list, otherwise is to should sort it.

00:02:59.919 --> 00:03:06.159
So, if we sorted we can try and maintain jobs
in decreasing order of priority, if we do

00:03:06.159 --> 00:03:10.769
it decreasing order of priority, then the
maximum priority job is always at the beginning

00:03:10.769 --> 00:03:11.769
of the list.

00:03:11.769 --> 00:03:14.099
So, we can instantly find it in constant time.

00:03:14.099 --> 00:03:20.049
So, delete max now becomes a constant time
operation, then what happens to insert?

00:03:20.049 --> 00:03:24.939
We need to insert a value in to the list,
and as we saw in insertion sort when we insert

00:03:24.939 --> 00:03:28.459
a value in to the sorted list we have to walk
down the list to find the correct place to

00:03:28.459 --> 00:03:29.459
put it in.

00:03:29.459 --> 00:03:31.230
So, that will now take order N time.

00:03:31.230 --> 00:03:36.809
So, between an unsorted list and in a sorted
list, we have a trade off in an unsorted list

00:03:36.809 --> 00:03:40.939
delete max takes linear time, in a sorted
list insert takes linear time.

00:03:40.939 --> 00:03:44.159
So, one all the other is a bottle neck.

00:03:44.159 --> 00:03:49.260
So, whether we use an unsorted list or a sorted
list over a sequence of N jobs, supposing

00:03:49.260 --> 00:03:51.939
N jobs arrive in the system will be process
them.

00:03:51.939 --> 00:03:55.290
Then we will be inserting them N times and
deleting max N times.

00:03:55.290 --> 00:03:59.669
So, which ever solution we use among these
two, we will end up spending order N square

00:03:59.669 --> 00:04:00.669
time.

00:04:00.669 --> 00:04:03.659
So, this suggest to us that a linear structure.

00:04:03.659 --> 00:04:09.989
One dimensional structure has a severe limitation
with respect to solving the representation

00:04:09.989 --> 00:04:13.950
of the priority queue in an efficient way.

00:04:13.950 --> 00:04:19.150
So, we have to go from a one dimensional structure
to a two dimensional structure.

00:04:19.150 --> 00:04:24.530
So, let us start with a very naive two dimensional
structure, just to show how we can get drastic

00:04:24.530 --> 00:04:27.990
improvements, just I moving from one dimension,
two dimensions.

00:04:27.990 --> 00:04:33.889
So, here we assume that we know an advance
somehow a bound in a number of total jobs

00:04:33.889 --> 00:04:34.889
we can have.

00:04:34.889 --> 00:04:37.770
So, we have assumed in this case say that
N is 25.

00:04:37.770 --> 00:04:43.639
So, now what we do is instead of maintaining
a one dimensional list of length 25 - maximum

00:04:43.639 --> 00:04:49.360
length 25, we reorganize this list as a square
array of 5 by 5.

00:04:49.360 --> 00:04:51.340
So, square root N by square root n.

00:04:51.340 --> 00:04:54.680
So, now you can see here an example of such
a thing.

00:04:54.680 --> 00:05:01.360
So, we have 25 minus 6 19 jobs currently with
different priorities in there.

00:05:01.360 --> 00:05:04.580
Sometimes two jobs may have the same priority
that does not matter.

00:05:04.580 --> 00:05:09.189
But the important thing is that we are not
necessarily maintaining it in a kind of sequential

00:05:09.189 --> 00:05:13.810
way through this two dimensional array, all
we are guarantying is that every row as we

00:05:13.810 --> 00:05:16.970
look at the row from left to right is an ascending
order.

00:05:16.970 --> 00:05:20.979
So, we have the first row is an ascending
order, second row in, but the rows themselves

00:05:20.979 --> 00:05:22.310
have nothing in common with each other.

00:05:22.310 --> 00:05:25.480
So, you could have bigger values in the second
row in the smaller row and vice versa.

00:05:25.480 --> 00:05:31.041
So, for example, 19 is bigger than 12, then
the 17 is bigger than 8 and so on.

00:05:31.041 --> 00:05:36.240
So, these are kind of five independent list
of jobs, which together makeup the total set

00:05:36.240 --> 00:05:40.010
of jobs at each list is sorted.

00:05:40.010 --> 00:05:45.421
So, now suppose you want to insert a new job
in to this list.

00:05:45.421 --> 00:05:48.729
So, strategy is very simple we want to insert
it in the correct place in the first row that

00:05:48.729 --> 00:05:51.020
has free space.

00:05:51.020 --> 00:05:54.560
Now to find out if one of the rows has free
space, we need to walk down this thing to

00:05:54.560 --> 00:05:56.220
find out how any elements are there.

00:05:56.220 --> 00:06:03.949
So, you will save that work by keeping this
extra information here, which is the size

00:06:03.949 --> 00:06:04.949
of each of the rows.

00:06:04.949 --> 00:06:09.449
So, let us assume that we have the size available
of insert the rows, now we row in this particular

00:06:09.449 --> 00:06:12.400
case that each row is a size five at most.

00:06:12.400 --> 00:06:21.500
So, if the size is 5, when we know that if
it try to insert 11 into this first row, the

00:06:21.500 --> 00:06:26.370
11 will not be able to fit there, because
there is no space basically.

00:06:26.370 --> 00:06:29.840
So, then we move to the next row, once again
we see that the size is 5.

00:06:29.840 --> 00:06:32.120
So, then we go to the third.

00:06:32.120 --> 00:06:35.760
Now we see that there is a space, because
there are only three elements in this row

00:06:35.760 --> 00:06:36.760
and it can take 5.

00:06:36.760 --> 00:06:41.090
So, now we walk down this list and find the
correct place to insert it, and insert it

00:06:41.090 --> 00:06:42.760
as we doing insertion sort.

00:06:42.760 --> 00:06:46.120
So, another question is how much time this
is take.

00:06:46.120 --> 00:06:49.550
Well, we know that it we have square root
of N rows.

00:06:49.550 --> 00:06:54.979
So, it take square root of N steps to find
the correct row to insert going from top to

00:06:54.979 --> 00:06:57.830
bottom, and then we have in each rows square
root of N entries.

00:06:57.830 --> 00:07:01.850
So, if we do a usual insertion it takes time
proportional to the length of the row, we

00:07:01.850 --> 00:07:02.949
are inserting into.

00:07:02.949 --> 00:07:07.270
So, we have a square root of N scan to find
the correct row, the square root of N scan

00:07:07.270 --> 00:07:09.199
to find the correct position within that row.

00:07:09.199 --> 00:07:17.240
So, overall it is time O order of square root
of n.

00:07:17.240 --> 00:07:19.240
So, what about deleting?

00:07:19.240 --> 00:07:22.639
So, we want to delete the maximum element
in this array.

00:07:22.639 --> 00:07:27.050
Now because each row is independent of other
row, we do not know in advance where this

00:07:27.050 --> 00:07:29.229
maximum element is.

00:07:29.229 --> 00:07:34.810
However, we do know that in every row the
maximum element is at the end, because each

00:07:34.810 --> 00:07:36.189
row is sorted.

00:07:36.189 --> 00:07:40.729
So, the first thing we do know is that every
possible maximum element is actually at the

00:07:40.729 --> 00:07:42.009
end of its row.

00:07:42.009 --> 00:07:45.490
So, we have these five rows, we have five
maximum elements.

00:07:45.490 --> 00:07:50.729
And now the overall maximum must be among
these five elements, it must be the largest

00:07:50.729 --> 00:07:51.729
one.

00:07:51.729 --> 00:07:53.259
So, we can just use the size information.

00:07:53.259 --> 00:07:56.499
So, we know it is the fifth element in the
first row, the fifth element in the second

00:07:56.499 --> 00:08:00.349
row, the fourth element in the third and fourth
row, and the second element the last row.

00:08:00.349 --> 00:08:05.509
So, using the size information, we can scan
through all of these and identify which is

00:08:05.509 --> 00:08:11.740
the biggest one in this case it is 43, to
be identify the 43 needs to be deleted.

00:08:11.740 --> 00:08:17.380
And then having deleted 43 then we remove
it, and then of course we have to also reduce

00:08:17.380 --> 00:08:19.880
the size back from 4 to 3.

00:08:19.880 --> 00:08:24.659
So, we can keep track of the size as and when
we manipulate in the previous example also

00:08:24.659 --> 00:08:28.810
when we had increased 11, we made this 3 into
4.

00:08:28.810 --> 00:08:31.069
So, again it is an order root N operation.

00:08:31.069 --> 00:08:37.460
So, we have now achieved a data structure,
which keeps track of elements in a priority

00:08:37.460 --> 00:08:43.160
queue where insert takes order root N time,
delete max takes order root N time, and therefore,

00:08:43.160 --> 00:08:47.320
now processing a sequence of N jobs takes
N root N time.

00:08:47.320 --> 00:08:50.120
Remember that previously it was order N square.

00:08:50.120 --> 00:08:55.730
So, we have reduce from order N square to
order N 3 by 2, if you want to write it this

00:08:55.730 --> 00:09:00.980
way So, this is just a sampler to explain
that a two dimensional structure can give

00:09:00.980 --> 00:09:03.590
you significant savings over a linear structure.

00:09:03.590 --> 00:09:07.210
So, of course we are not going to be happy
with this, others you would have just stop

00:09:07.210 --> 00:09:08.210
with this.

00:09:08.210 --> 00:09:11.630
So, we can actually do much better than N
to 3 by 2, and this is what we are going to

00:09:11.630 --> 00:09:13.790
discuss in a later lecture.

00:09:13.790 --> 00:09:18.982
To give you a preview, what we are going to
do is to maintain it not in a simple array

00:09:18.982 --> 00:09:24.120
or a square matrix like this, but in a special
kind of binary tree called a heap.

00:09:24.120 --> 00:09:26.270
So, this will be a binary tree.

00:09:26.270 --> 00:09:29.960
So, it will have structure like this, and
it will be balanced.

00:09:29.960 --> 00:09:34.230
So, basically all the paths will roughly have
the same length, and what this will mean is

00:09:34.230 --> 00:09:40.360
that the height of the tree will be logarithmic
in the size of the tree.

00:09:40.360 --> 00:09:45.120
And this will make both insert and delete
max take log N operations, and this will given

00:09:45.120 --> 00:09:50.380
overall bound for N operations of N log N.
The other thing is that we actually maintain

00:09:50.380 --> 00:09:54.680
it as a dynamic tree like this, we do not
have to make an assumption as we did not or

00:09:54.680 --> 00:09:58.200
simple solution that we just proposed, where
we upper bound N.

00:09:58.200 --> 00:10:01.200
We can have a solution where the tree can
grow as large as we want.

00:10:01.200 --> 00:10:04.820
So, long as we make sure that we grow it in
a systematic way to keep it balanced.

00:10:04.820 --> 00:10:08.020
So, this is what we will look at next, we
will look at this data structure called a

00:10:08.020 --> 00:10:12.570
heap which implements a priority queue by
maintaining a set type of binary tree.

