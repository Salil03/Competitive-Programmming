WEBVTT
Kind: captions
Language: en

00:00:00.690 --> 00:00:05.980
Let us now turn our attention to the All-pairs
Shortest Paths problems, where we try to find

00:00:05.980 --> 00:00:10.759
the paths, shortest paths between every pair
of vertices in a graph.

00:00:10.759 --> 00:00:16.379
So, recall that we are working with weighted
graphs, we allow negative edge weights, but

00:00:16.379 --> 00:00:21.310
not negative cycles, because with negative
cycles our shortest path is not well defined,

00:00:21.310 --> 00:00:26.450
with negative weights, it is well defined.
We saw that the Bellman-Ford algorithm allows

00:00:26.450 --> 00:00:31.280
us to generalize Dijsktra's algorithm and
compute single source shortest paths in weighted

00:00:31.280 --> 00:00:33.780
graphs with negative weight, but without negative
cycles.

00:00:33.780 --> 00:00:38.429
So, now, we want to further generalize this
and compute not just the shortest paths from

00:00:38.429 --> 00:00:42.699
a single source, but the shortest path between
every pair of vertices. So, as we explained

00:00:42.699 --> 00:00:47.089
at the beginning an example would be, if you
trying to run a travel website or an airline

00:00:47.089 --> 00:00:52.620
website and somebody wants to find the minimum
cost or the minimum time flight or train between

00:00:52.620 --> 00:00:55.890
any pair of sides.

00:00:55.890 --> 00:01:01.430
So, you made the following observation of
shortest paths that the shortest path even

00:01:01.430 --> 00:01:06.360
in the presence of negative weights will never
loop, because we can always remove the loop

00:01:06.360 --> 00:01:11.000
without increasing the length of the path.
So, therefore a shortest path never visits

00:01:11.000 --> 00:01:17.410
the same vertex twice and has length at most
n minus 1. So, we exploited this algorithm

00:01:17.410 --> 00:01:23.110
in one way for Bellman-Ford and we will find
that we can use it now for an inductive algorithm

00:01:23.110 --> 00:01:28.320
for all pairs shortest path. So, we will come
up with an inductive solution of how to build

00:01:28.320 --> 00:01:29.660
up the shortest paths.

00:01:29.660 --> 00:01:38.230
So, we are basically going to build up shortest
path in terms of vaguely their length, but

00:01:38.230 --> 00:01:43.860
most specifically what vertices we allowed
in between. So, the simplest shortest path

00:01:43.860 --> 00:01:49.610
you can imagine in a pair of vertices it is
just a single edge. So, we have single edge

00:01:49.610 --> 00:01:53.490
and this happens to be the shortest path,
then you are in good shape. But, in general

00:01:53.490 --> 00:01:57.350
this may not be the shortest path, because
even if there is such an edge, there may be

00:01:57.350 --> 00:02:01.220
a way, because of negative, because of edge
way, even because of negative edge ways are

00:02:01.220 --> 00:02:07.520
reaching from i to j by our longer path of
edges, but with a shorter overall cost.

00:02:07.520 --> 00:02:12.480
But, what we do know, because of the characterization
of shortest path is that this path from i

00:02:12.480 --> 00:02:16.500
to j goes through some intermediate vertices
all of which are different from each other,

00:02:16.500 --> 00:02:21.310
no vertex is visited twice. And secondly,
none of these vertices either i or j, there

00:02:21.310 --> 00:02:25.520
is no point in coming back to i and then going
to j, so there is no loop anywhere in this

00:02:25.520 --> 00:02:31.900
path. So, what we will do for this inductive
thing is to restrict, what can happen in between

00:02:31.900 --> 00:02:37.260
i and j, what are the vertices that are allowed
and we will gradually increase the set. If

00:02:37.260 --> 00:02:42.160
we allow any vertices, then of course, we
will get arbitrary shortest paths.

00:02:42.160 --> 00:02:50.569
So, recall that vertices are numbered 1 to
n, so we will compute a quantity W k of i

00:02:50.569 --> 00:02:55.930
j to be the weight of the shortest path from
i to j, where we restrict the vertices that

00:02:55.930 --> 00:03:00.770
can be used go from i to j to be between 1
and k. In other words, we have this set of

00:03:00.770 --> 00:03:07.660
vertices V, so we cut it off saying we have
1 to k and we have k plus 1 to n, we say that

00:03:07.660 --> 00:03:14.010
only these vertices can be used in the path.
Now, the end points themselves may not be,

00:03:14.010 --> 00:03:18.819
need not be, but at the point is that in the
end point is outside, then it can still, so

00:03:18.819 --> 00:03:24.849
I could have a 1 vertex here and then it could
have a path which go like this and then come

00:03:24.849 --> 00:03:28.800
back. So, only says is that the intermediate
vertices, so when I start with i and go to

00:03:28.800 --> 00:03:36.450
j, what happens in between lies in this set
1 to k. So, in particular if k is 0, because

00:03:36.450 --> 00:03:45.560
our numbering is 1 to n, it says that the
vertices that can appear cannot be include

00:03:45.560 --> 00:03:48.880
1.
So, in other words, if I have W 0, then it

00:03:48.880 --> 00:03:53.060
says all of the vertices 1 to n cannot appear
on the paths, so the only way that we can

00:03:53.060 --> 00:03:58.150
have such a shortest paths is to the direct
edge. So, W 0, the base case of this inductive

00:03:58.150 --> 00:04:03.690
definition says that the shortest paths between
i and j which exclude all vertices from 1

00:04:03.690 --> 00:04:08.390
to n are of the form edges between i and j.

00:04:08.390 --> 00:04:12.500
So, now since this is an inductive definition,
what we have to say is, supposing we know

00:04:12.500 --> 00:04:17.250
the shortest paths which use 1 to k minus
1, then how do I compute the shortest paths

00:04:17.250 --> 00:04:23.671
that use 1 to k. So, we know among all the
paths which use at most 1 to k minus 1, what

00:04:23.671 --> 00:04:29.340
is the shortest path from i to j, how do we
now compute, if we allow vertex k also to

00:04:29.340 --> 00:04:32.980
be used, how do you compute, what would be
the shortest path from i to j.

00:04:32.980 --> 00:04:38.150
So, there are two cases, the first case is
this is an extra vertex k not useful, the

00:04:38.150 --> 00:04:44.180
shortest path even if I include k does not
use vertex k, it is enough to use 1 to k minus

00:04:44.180 --> 00:04:50.490
1. In this case the shortest distance from
W i to j using 1 to k is the same as the shortest

00:04:50.490 --> 00:04:55.530
distance from i to j using k minus 1. So,
I can say W k of i j is the same as W k minus

00:04:55.530 --> 00:05:02.030
1 i j. On the other hand, it could be that
using k does give us some non trivial improvement.

00:05:02.030 --> 00:05:08.030
So, we have now some path which goes from
i to j and on the way it visits k. So, if

00:05:08.030 --> 00:05:14.380
it visits k on the way, then we can break
it up as a path from i to k and a path from

00:05:14.380 --> 00:05:19.880
k to j. But, notice that we have already said
that this vertex k or any vertex for that

00:05:19.880 --> 00:05:25.130
matter which appears in this path, if it is
the shortest path appears only once. So, if

00:05:25.130 --> 00:05:31.919
cut k appears here, there is no k between
i and k and there is no k between k and j.

00:05:31.919 --> 00:05:36.820
This means that I have a path from i to k
already which goes through 1 to k minus 1

00:05:36.820 --> 00:05:42.150
and I have a path from k to j already which
goes 1 to k minus 1 and I am combining these

00:05:42.150 --> 00:05:43.880
two.
So, I can break up the path, as a path from

00:05:43.880 --> 00:05:48.820
i to k and the path k to j, each of which
uses only 1 to k minus 1. And what is the

00:05:48.820 --> 00:05:53.919
cost of that path, well, we inductively know
that we have the cost of the best path from

00:05:53.919 --> 00:05:55.490
i to k using only 1 to k minus 1 inductive
k minus 1, you also have the best path from

00:05:55.490 --> 00:06:33.280
k to j in our matrix W k minus 1. So, if I
add these two, this must be the path best

00:06:33.280 --> 00:06:36.150
way of going i or k.
So, combing the cases, we say that either

00:06:36.150 --> 00:06:38.639
we do not use k in which case, we take the
value of the old matrix or you do use k and

00:06:38.639 --> 00:06:39.639
which case we combine two entries going via
k in the old matrix, we will take the smaller

00:06:39.639 --> 00:06:40.639
of these two. So, which one of these smaller
will be the correct value of the shortest

00:06:40.639 --> 00:06:41.639
distance from i to j going through 1 to k.

00:06:41.639 --> 00:06:42.639
So, this gives us an immediate algorithm which
is called the Floyd-Warshall algorithm. So,

00:06:42.639 --> 00:06:43.639
we start off with matrix representing the
function W 0. So, W 0 has entries which are

00:06:43.639 --> 00:06:46.270
exactly the edge weight, so there is an edge
from i to j, the W 0 i to j says that direct

00:06:46.270 --> 00:06:50.610
path of that weight. Because, remember that
W 0 cannot go through any intermediate paths

00:06:50.610 --> 00:06:55.110
and if there is no edge, since I cannot go
through any intermediate vertex, W 0 i j must

00:06:55.110 --> 00:07:01.639
be infinity.
Now, for k in 1 to n, I basically repeat this

00:07:01.639 --> 00:07:06.130
n times, I first allow 1 to be use. So, I
compute W 1 and W 0. And how do I do that,

00:07:06.130 --> 00:07:10.270
I use the update to insert earlier that will
take the minimum of what you already have

00:07:10.270 --> 00:07:14.410
plus the possibility going through the newly
introduced vertex, then I will allow 1 and

00:07:14.410 --> 00:07:19.240
2, then I will allow 1, 2 and 3. And obviously,
if I allow 1, 2, 3 up to n I allow all the

00:07:19.240 --> 00:07:23.880
vertices to appear in between, W n will now
have the shortest paths with no constraints.

00:07:23.880 --> 00:07:30.370
So, I need to do these update exactly n times,
so that after n times I capture the shortest

00:07:30.370 --> 00:07:36.070
way paths which include any arbitrary combination
of vertices on the path.

00:07:36.070 --> 00:07:43.440
So, the actual code is again like Bellman-Ford
extremely straight forward. You just have

00:07:43.440 --> 00:07:48.650
first initialization which sets every way
to infinity and then updates the non trivial

00:07:48.650 --> 00:07:54.110
weights for those edges which are in the graphs.
So, we have keeping track of this function

00:07:54.110 --> 00:08:03.030
W 0 of i j by a three dimensional matrix,
so i and j represent the two vertices and

00:08:03.030 --> 00:08:10.150
the 0 represents the iteration number.
So, initially W 0 of i j is either the weight

00:08:10.150 --> 00:08:16.460
of i j, if there is an edge or it is infinity
and that is what these first two steps are

00:08:16.460 --> 00:08:21.580
doing. And now, we do this ends n times, we
do this iteration, that is we update all the

00:08:21.580 --> 00:08:29.990
W i j's at level k to be the minimum of the
W i j's at level k minus 1 or the sum of the

00:08:29.990 --> 00:08:38.729
root. So, implicitly here should have been
for . So, this is for i n, for i equal to

00:08:38.729 --> 00:08:45.800
1 to n, for j equal to 1 to n.
So, we have this update rule and we do these

00:08:45.800 --> 00:08:51.950
blindly n times and n we claim that the matrix
W in the entry k has got the correct shortest

00:08:51.950 --> 00:08:54.220
paths for all pairs of vertices.

00:08:54.220 --> 00:09:02.860
So, let us look at the same example that we
saw for Bellman-Ford. So, initially we assign

00:09:02.860 --> 00:09:08.410
to each, so W 0 has the edge weight. So, we
have an adjacency matrix like representation

00:09:08.410 --> 00:09:12.430
in which for instance, we say 1 to 2 there
is an edge of weight 10, 7 to 6, there is

00:09:12.430 --> 00:09:20.070
an edge of weight minus 1 and so on. So, we
just duplicate all of these edges in the matrix

00:09:20.070 --> 00:09:26.130
and everything else is left at infinity.
Now, from W 0, we go to W 1 by considering

00:09:26.130 --> 00:09:30.750
all new paths that we can find by going from
1, but now notice that this nothing that is

00:09:30.750 --> 00:09:34.960
coming into 1. So, this is signified to in
fact, that the column 1 has infinity, no edge

00:09:34.960 --> 00:09:40.520
goes into 1. So, no other vertex can use the
fact that 1 is connected to 2 and 8. So, if

00:09:40.520 --> 00:09:45.560
you update using update rule, you find that
the W 1 is actually equal to W 0 nothing changes,

00:09:45.560 --> 00:09:49.060
because allowing 1 to be use in between two
vertices does not help us.

00:09:49.060 --> 00:09:53.410
It is not in between any two vertices, I cannot
go from anywhere to 1 and then from 1 to that

00:09:53.410 --> 00:10:00.380
vertex. On the other hand, if I can now include
2, then I can do interesting things, I can

00:10:00.380 --> 00:10:06.520
go for example, from 1 to 2 to 6 and I can
go from 7 to 1 to 6. So, align 2 and 1 as

00:10:06.520 --> 00:10:10.540
an intermediate vertex, so 1 does not help
right now, but allowing 2 gives me something.

00:10:10.540 --> 00:10:16.680
So, if I now look at W 1, I do not need W
0 anymore, whenever W 1, then I will whether

00:10:16.680 --> 00:10:21.560
said be able to explore paths through 2. So,
in particular 2 goes to 6, anything pointing

00:10:21.560 --> 00:10:29.140
into 2, so 7 to 2 to 6, 3 to 2 to 6 and 1
to 2 to 6, these three entries will get updated.

00:10:29.140 --> 00:10:34.840
So, 1 to 2 to 6, so I get a new entry 12,
3 to 2 to 6, so I get new entry 3 and 7 to

00:10:34.840 --> 00:10:42.240
2 to 6, I get minus 4 plus 2 minus 3. Now
from W 2, likewise I will compute W 3, again

00:10:42.240 --> 00:10:46.886
compute W 3 will come back to this later,
I do not need W 1, I only need W 2. So, I

00:10:46.886 --> 00:10:53.769
can throw way W 1 from now, I am just look
at W 2. So, now I am allowing myself to use

00:10:53.769 --> 00:10:57.020
1, 2, 3, so I will look for things at go throw
3.

00:10:57.020 --> 00:11:04.029
So, for instance now through 3, I can go from
6 to 4, for example, so I will get entries

00:11:04.029 --> 00:11:11.070
of that form. So, I can go from 6 to 4 with
new thing, I can also go from 6 to 2. So,

00:11:11.070 --> 00:11:18.290
now, I have a new way are going from 6 to
2, so that also get separated. And interestingly,

00:11:18.290 --> 00:11:25.040
I also discovered that, there is now our path
from 6 to 6, because earlier I did not know

00:11:25.040 --> 00:11:29.350
that, but now that, I am allow to go throw
both 2 and 3, I can go from 6 to 6, I have

00:11:29.350 --> 00:11:30.870
discovered this loop, which has a positive
weight.

00:11:30.870 --> 00:11:35.070
If did not have a positive weight viewer in
trouble, because this is did not have a well

00:11:35.070 --> 00:11:39.170
defined solution and so on. So, you can just
keep on doing this, we will not update up

00:11:39.170 --> 00:11:44.200
to W, if you now go all the way and do up
to W 8, then after you allow everything from

00:11:44.200 --> 00:11:49.640
1 to 8 to be an intermediate thing, this matrix
will actually compute all pair shortest path

00:11:49.640 --> 00:11:53.089
between any i j.

00:11:53.089 --> 00:11:57.940
So, this algorithm it is very easy to see
that the complexity is order n cube, because

00:11:57.940 --> 00:12:01.630
you have n iteration and an each iteration
we are updating the entire matrix which has

00:12:01.630 --> 00:12:05.700
n square entries. This is not much you can
do to improve this, because it is an adjacency

00:12:05.700 --> 00:12:10.360
matrix base algorithm, we cannot move to list,
we do not have to compute any minimum maximum.

00:12:10.360 --> 00:12:16.350
So, nothing much you can do it is, it is n
cube algorithm, notice that, it is sort of

00:12:16.350 --> 00:12:21.940
solves, as it trivial case, the Bellman-Ford,
because once you computed all pairs, so this

00:12:21.940 --> 00:12:30.450
generalizes as the solution Bellman-Ford.
Because, in particular, if you now want all

00:12:30.450 --> 00:12:35.290
the shortest path from a given s, everything
you just have to look up that particular row

00:12:35.290 --> 00:12:39.680
in the Floyd Warshall matrix.
You look at the row s and all the entries

00:12:39.680 --> 00:12:45.150
with say the shortest path from s, but remember
that in that particular case, if I only wanted

00:12:45.150 --> 00:12:50.590
from s Bellman-Ford with clever adjacency
list representation would take order m n,

00:12:50.590 --> 00:12:55.910
but it is here this will require order n cube.
So, this is the generalize Bellman-Ford instance,

00:12:55.910 --> 00:12:58.740
you get same answer that you would have call
from Bellman-Ford and more.

00:12:58.740 --> 00:13:02.101
But, you are always spending n cube time,
there is if you had very few edges in your

00:13:02.101 --> 00:13:06.769
graph which is typically the case Bellman-Ford
in more efficient. So, if you are using, if

00:13:06.769 --> 00:13:11.170
you only want to do single source shortest
path, you should not typically jump directly

00:13:11.170 --> 00:13:17.450
to Floyd Warshall, you should probably do
Bellman-Ford instant. About space complexity,

00:13:17.450 --> 00:13:22.550
so we said that we are going to represent
each W 0, W 1 etcetera is one coordinate.

00:13:22.550 --> 00:13:28.500
So, we have basically have n times, n times
n, because we have n times n is the actual

00:13:28.500 --> 00:13:33.990
matrix, we have n of these matrixes, because
we have level 0, level 1 upto level k - level

00:13:33.990 --> 00:13:39.649
n. But, we saw that in our work out example,
that when you need to compute the level 1,

00:13:39.649 --> 00:13:43.550
we only need level 0, then we can throw a
level 0. When, we need to compute level 2,

00:13:43.550 --> 00:13:46.339
you need only level 1.
So, in some sense, you can keep only 2 copies

00:13:46.339 --> 00:13:51.960
and keep switching back and fold, you over
write the zeroth level as second level, you

00:13:51.960 --> 00:13:55.770
over write the first level as third level
and so on. So, we need only 2 slices of l,

00:13:55.770 --> 00:14:00.089
call it of this three dimensional matrix at
a time. So, you can just keep oscillating

00:14:00.089 --> 00:14:05.149
between these 2 slices overall here 2 n squared
space. So, we known normally worry about space.

00:14:05.149 --> 00:14:09.180
But, just an observation that in this particular
thing, you do not really need to have the

00:14:09.180 --> 00:14:14.880
n cubed array, you can have 2 n squared array
or a n squared array with that two indices.

00:14:14.880 --> 00:14:18.149
And keep oscillating between the 2 and get
the same effect, because you only need one

00:14:18.149 --> 00:14:24.970
copy to compute the other copy.

00:14:24.970 --> 00:14:27.901
So, let us conclude this discussion in some
historical remarks. So, Floyd Warshall as

00:14:27.901 --> 00:14:31.240
you can see from the hyphenation, as the hybrid
name for this algorithm and actually there

00:14:31.240 --> 00:14:37.339
are two distinct algorithms which comprise
it, which have a very similar structure. So,

00:14:37.339 --> 00:14:41.390
the original algorithm which are proposed
by Warshall is for what is called transitive

00:14:41.390 --> 00:14:46.980
closure. So, transitive closure is exactly
the same as computing the path from edge relation.

00:14:46.980 --> 00:14:51.170
So, supposing you have a relationship like
friend, so you know among a group of people,

00:14:51.170 --> 00:14:59.950
who is a direct friend of whom, then you might
want to ask, who knows indirectly. So, I know

00:14:59.950 --> 00:15:04.530
somebody indirectly, if I have a friend, who
knows that person or if I have a friend who

00:15:04.530 --> 00:15:09.100
as the friend knows that person and so on.
So, knowing somebody indirectly is that transitive

00:15:09.100 --> 00:15:13.420
closure of the friend relation. In the same
way in a general, I mean, so in every graph,

00:15:13.420 --> 00:15:16.040
if you put the friend, whatever relation,
we want as the edge relation, the transitive

00:15:16.040 --> 00:15:22.779
closure is the path relation.
So, you have an adjacency matrix which represents

00:15:22.779 --> 00:15:27.861
the edges, you want to compute a path matrix
which represents the paths, which are the

00:15:27.861 --> 00:15:33.500
pairs of vertices computed by which are connected
by paths. And so, Warshall describe the similar

00:15:33.500 --> 00:15:37.540
algorithm, what we wrote now and we will just
do it in a little detail in the next couple

00:15:37.540 --> 00:15:43.050
of slides to do this compute P from A and
what Floyd is observed was you can adapted

00:15:43.050 --> 00:15:47.959
as same algorithm. So, if Warshall's algorithm,
we only checking is there of path and Floyds

00:15:47.959 --> 00:15:51.920
algorithm says that, you can actually adapt
it to compute shortest paths.

00:15:51.920 --> 00:15:56.480
So, the idea is very similar to what you have
seen for let us go through it quickly. So,

00:15:56.480 --> 00:16:01.980
we have an adjacency matrix A, which tells
as the edges A i j is 1, if there is an edge

00:16:01.980 --> 00:16:08.019
and we want a path matrix P i j is a 1, there
is a path from i to j. So, we will again compute

00:16:08.019 --> 00:16:13.519
iteratively this quantity P k i j, it says
that there is the path and this path uses

00:16:13.519 --> 00:16:20.279
only the vertices 1 to k.
So, k plus 1 to n cannot appear in the path

00:16:20.279 --> 00:16:24.750
and again the end points are not included.
So, i and j are arbitrary, it is what is a

00:16:24.750 --> 00:16:30.290
between i and j which is restricted by this
super script k. So, between i and j, you can

00:16:30.290 --> 00:16:36.190
only seen things from 1 to k. So, as before
if you do P 0, it says nothing can appear,

00:16:36.190 --> 00:16:41.070
because you could have everything from 1 to
n, therefore, P 0 is just the adjacency matrix.

00:16:41.070 --> 00:16:48.660
So, now we have a very similar update rule,
so if I know the paths which can be discovered

00:16:48.660 --> 00:16:54.139
using 1 to k minus 1, what are the paths I
can discover using 1 to k. So, if there is

00:16:54.139 --> 00:16:58.920
a path already without using k, then I can
just keep that path. So, we could either have

00:16:58.920 --> 00:17:03.389
that P k, I so remember now is there a path
is not the path. So, this is like an adjacency

00:17:03.389 --> 00:17:07.629
matrix, there is no weight, it was the 0,
1 matrix or a true false matrix.

00:17:07.629 --> 00:17:11.759
So, initially the adjacency matrix has 1 or
true, whenever there is an edge, false whenever

00:17:11.759 --> 00:17:16.600
there is no edge. So, if I already got an
entry true with k minus 1, then I can keep

00:17:16.600 --> 00:17:21.199
it. The other hand, maybe I do not have an
entry true, after go via k, but once again

00:17:21.199 --> 00:17:25.400
that needs there is a path from i to k and
there is a path from k to j and here I use

00:17:25.400 --> 00:17:34.109
only k minus 1 and here I use only k minus
1, because k needs to appear only once.

00:17:34.109 --> 00:17:36.139
Just like in a shortest path, if I am just
looking for some connectivity, then I do not

00:17:36.139 --> 00:17:39.850
gain anything by going back from k to k, because
I can this remove that i and j will remain

00:17:39.850 --> 00:17:45.039
connected. So, I need to only look for paths
which have one copy of every vertex along

00:17:45.039 --> 00:17:49.700
them. So, therefore, I can assume there is
a path from i to k, which does not use anything

00:17:49.700 --> 00:17:52.570
outside 1 to k minus 1, likewise from k to
j.

00:17:52.570 --> 00:17:58.929
So, here now instead of min and plus operations,
now become or and and, either I want to path

00:17:58.929 --> 00:18:03.549
from i to k and path from k to j or I want
to existing path from i to j, which never

00:18:03.549 --> 00:18:09.190
use k at all. So, I have this AND operation
for combining these two existing paths should

00:18:09.190 --> 00:18:19.629
P and then, I have an OR operation which combines
a case 1. So, earlier we had W k minus 1,

00:18:19.629 --> 00:18:31.350
i j and then, we add this W k minus 1, i k
plus W k minus 1, k j and we took the min

00:18:31.350 --> 00:18:36.080
on this.
So, here instead of this plus, we are using

00:18:36.080 --> 00:18:40.999
AND and instead of using min, we are using
OR, you can see that the algorithm is not

00:18:40.999 --> 00:18:45.659
exactly the same. But, it is very similar,
so this was the algorithm proposed by Warshall.

00:18:45.659 --> 00:18:50.000
So, you initialize everything to false and
then, again you should P for i is equal to

00:18:50.000 --> 00:18:58.739
1 to n for j is equal to 1 to n. So, you initialize
all the paths to false, then you set explicitly

00:18:58.739 --> 00:19:02.570
that is the zeroth level path at true, if
there is an edge. And then, you keep updating

00:19:02.570 --> 00:19:06.869
the kth level path by either saying that there
was already k minus 1 level path or I can

00:19:06.869 --> 00:19:11.730
find 2 k minus 1 level path via an intermediate
level k in intermediate vertex k.

00:19:11.730 --> 00:19:15.749
So, it is a very similar thing, we just have
just these operations of OR and AND, instead

00:19:15.749 --> 00:19:21.919
of min and plus. And then, Warshall's algorithm
for use transitive closure and Floyd generalized

00:19:21.919 --> 00:19:26.700
it would shortest paths and these work in
the presence of negative edges, it does not

00:19:26.700 --> 00:19:30.450
matter, Floyds algorithm does not care with
the edges are negative or positive. So, long

00:19:30.450 --> 00:19:31.899
as there are no negative cycles.

