WEBVTT
Kind: captions
Language: en

00:00:01.150 --> 00:00:07.910
Now, let us look at shortest paths in graphs
where we allow Negative Edge weights. In particular

00:00:07.910 --> 00:00:09.889
let us look at the Bellman-Ford Algorithm.

00:00:09.889 --> 00:00:17.210
So, recall that the correctness for Dijsktra's
algorithm relied on an invariant property

00:00:17.210 --> 00:00:23.310
that every vertex that we burn automatically
has the shortest path computed at the time

00:00:23.310 --> 00:00:24.880
when we burn it.

00:00:24.880 --> 00:00:29.880
However, as we saw this argument does not
work if we can have negative edge weights,

00:00:29.880 --> 00:00:34.500
because we may find later a path via vertex
which we have not burnt yet which becomes

00:00:34.500 --> 00:00:39.000
a shorter path to a vertex we have burnt earlier.

00:00:39.000 --> 00:00:43.820
We also said that allowing negative edge weights
is one thing, but allowing negative cycles

00:00:43.820 --> 00:00:47.890
is not a good idea. Because, once you have
a negative cycle, you can go round and around

00:00:47.890 --> 00:00:53.780
cycle as many times as you want, it arbitrarily
reduces the length of the path, so the shortest

00:00:53.780 --> 00:00:58.250
path is not even a well defined quantity.
So, long as we have negative edges, but not

00:00:58.250 --> 00:01:03.760
negative cycles, shortest paths do exits and
we can hope to compute them.

00:01:03.760 --> 00:01:09.840
So, let us first look at two basic properties
about shortest paths which hold regardless

00:01:09.840 --> 00:01:16.060
of whether the edges can be negative or not,
provided we do not have negative cycles. So,

00:01:16.060 --> 00:01:20.620
the first property is fairly obvious, that
is a shortest path will never go through a

00:01:20.620 --> 00:01:26.780
loop. So, supposing I want to go from s to
t and suppose along the way I actually go

00:01:26.780 --> 00:01:34.350
through the same vertex twice and then I continue.
Now, what we know is that this is a loop and

00:01:34.350 --> 00:01:40.180
since it is a loop, the weight is greater
than or equal to 0, it cannot be negative,

00:01:40.180 --> 00:01:45.140
because we have ruled out negative loops.
So, therefore, if I take this path and I just

00:01:45.140 --> 00:01:50.290
cutout this loop, then I have a direct path
from s to t. And if I look at the cost of

00:01:50.290 --> 00:01:55.090
direct path from s to t, it cannot be any
bigger than this one, because at best this

00:01:55.090 --> 00:02:01.280
loop has 0 and decrease nothing but, in the
general case the loop has some positive cost

00:02:01.280 --> 00:02:06.049
and actually reduce the cost.
So, shortest path never loops, so it will

00:02:06.049 --> 00:02:10.999
never does not sent vertex twice, this means
that I at most have at most n minus 1 edges.

00:02:10.999 --> 00:02:18.230
Because I can only allow, so I totally have
n vertices, so if I do not allow any vertex

00:02:18.230 --> 00:02:22.530
to repeat anywhere along the way then; obviously,
I can only have n minus 1 vertices, n minus

00:02:22.530 --> 00:02:28.209
1 edges. So, there is a bound on the length
of the shortest path, the other property is

00:02:28.209 --> 00:02:34.499
that regardless of how the shortest path looks,
along the way every path that makes up the

00:02:34.499 --> 00:02:38.769
shortest path is itself the shortest path.
So, for instance I have a path like this from

00:02:38.769 --> 00:02:44.230
s to t which goes through some intermediate
vertices v 1, v 2 up to v m. Then, if I look

00:02:44.230 --> 00:02:52.950
at the path only up to v m, then this is our
shortest path from s to v m. There cannot

00:02:52.950 --> 00:02:56.879
be any shorter path, supposing there was another
shorted path. Suppose, the shorter way to

00:02:56.879 --> 00:03:01.739
get from s to v m, then I can take this and
this and the red path now will be shorter

00:03:01.739 --> 00:03:04.739
than the green path.
So, therefore, the fact that I am going to

00:03:04.739 --> 00:03:10.459
t via v m and this is a shortest path means
that there must also we only this much of

00:03:10.459 --> 00:03:13.519
our short path from s to v m and this whole
that we have point. So, again what happen

00:03:13.519 --> 00:03:17.419
s to v 2 this must be the shortest path, because
otherwise if there were a shortest path then

00:03:17.419 --> 00:03:20.920
I will take that shorter path and then I will
add on this path which I already have and

00:03:20.920 --> 00:03:25.650
I will get a shortest path to everything from
v 3 onwards. So, every prefix of a shortest

00:03:25.650 --> 00:03:30.269
path is itself a shortest path. So, these
two properties are enough for us to arrive

00:03:30.269 --> 00:03:36.439
at the Bellman-Ford algorithm for shortest
path in the presence of negative edge weights.

00:03:36.439 --> 00:03:41.639
So, to get to the Bellman-Ford algorithm we
have to analyze a little bit more about what

00:03:41.639 --> 00:03:45.549
is happening in Dijsktra's algorithm. So,
in Dijsktra's algorithm whenever we burn a

00:03:45.549 --> 00:03:52.629
vertices, whenever we visit it, we updates
all it is neighbors. So, we update the distance

00:03:52.629 --> 00:03:59.359
of a when we burn a vertices j, we update
for every edge j k, we update the distance

00:03:59.359 --> 00:04:05.849
to k to be what distance we already know for
k together with a distance to j an edge from

00:04:05.849 --> 00:04:08.639
j to k.
So, we have a newly discovered distance through

00:04:08.639 --> 00:04:12.150
j perhaps and we compare it to the distance
we already know and we keep the smaller of

00:04:12.150 --> 00:04:16.400
the Dijsktra's algorithm. So, let us call
this operation an update, it updating k from

00:04:16.400 --> 00:04:22.909
j. So, in Dijsktra's algorithm we only do
this update when we burn j and the correctness

00:04:22.909 --> 00:04:27.800
of Dijsktra's algorithm says that when we
burnt j, the distance to j is the correct

00:04:27.800 --> 00:04:31.490
distance to j.
So, what we have seen is that in negative

00:04:31.490 --> 00:04:35.780
edge weight case, what if we uses the strategy
of Dijsktra's algorithm this may not be it,

00:04:35.780 --> 00:04:42.490
if we will burn a vertices just because it
is shortest expected distance among the unburnt

00:04:42.490 --> 00:04:46.729
vertices does not guarantee that this is correct
distances we might find later on a smaller

00:04:46.729 --> 00:04:51.860
distance. But, in spite of this, this update
operation has some useful properties which

00:04:51.860 --> 00:04:52.860
we can exploit.

00:04:52.860 --> 00:04:59.259
So, the crucial thing is that we update gives
us some upper bound that the distance to k,

00:04:59.259 --> 00:05:04.010
we already have... So, at any point the invariant
that we have is that the value that we have

00:05:04.010 --> 00:05:08.860
as distances to k is greater than or equal
to the actual shortest distance from the source

00:05:08.860 --> 00:05:13.000
to k, initially we may assume it is infinity.
So, that is surely greater than the actual

00:05:13.000 --> 00:05:19.090
shorter distances. At any point when we reduce
it, we reduce it because we have found a concrete

00:05:19.090 --> 00:05:24.520
path which gives us a shorter distance.
So, when we do this after this update we know

00:05:24.520 --> 00:05:29.199
that the distance to k is no more than the
distance we have just discovered through j.

00:05:29.199 --> 00:05:33.220
Because, if it was already less and we keep
it that way, because we found it through previous

00:05:33.220 --> 00:05:38.520
j prime or we have found it now in which case
we have updated it on this update operation.

00:05:38.520 --> 00:05:43.200
This also means because of our previous observation
about shortest paths that if actually on Dijsktra's

00:05:43.200 --> 00:05:47.949
algorithm also, that if distance j is actually
correct and the shortest path now consists

00:05:47.949 --> 00:05:53.729
of just adding this edge. We are not claiming
it is, if it is the shortest path, then the

00:05:53.729 --> 00:05:59.219
distance to k will be correctly computed.
So, in a nutshell, this update operation is

00:05:59.219 --> 00:06:03.500
a safe operation, because it will never bring
distance of k below the actual value. So,

00:06:03.500 --> 00:06:08.069
it will always be adopt the value that we
want. So, we can keep doing spurious updates,

00:06:08.069 --> 00:06:13.159
so unnecessary updates and it does not hurt
us. So, redundant updates cannot accept this

00:06:13.159 --> 00:06:17.460
calculation, it just may not make progress,
but may not it will not send us to a situation

00:06:17.460 --> 00:06:22.729
from which we cannot recover the minimum cost.
Because, we always be at or adopt the minimum

00:06:22.729 --> 00:06:27.099
cost, so whenever we do a min, we will always
be coming down, but not processing below the

00:06:27.099 --> 00:06:30.289
actual value we want to find.

00:06:30.289 --> 00:06:37.830
So, if you look at Dijsktra's algorithm then
what it does is a particular sequence of greedy

00:06:37.830 --> 00:06:44.780
updates, it chooses the smallest distance
vertex which is not burnt and it burns it

00:06:44.780 --> 00:06:49.960
and the proof breaks down, because this sequence
does not match, necessarily give us a shortest

00:06:49.960 --> 00:06:56.389
path, if the ways can be negative. So, a natural
question to ask is what sequence of updates

00:06:56.389 --> 00:07:03.889
should I do in order to actually get the shortest
path? Is there a better way of computing the

00:07:03.889 --> 00:07:10.669
sequence of updates, rather than going via
the greedy heuristics of Dijsktra's algorithm?

00:07:10.669 --> 00:07:16.490
So, suppose we have two vertices s and t,
we want to find the shortest path from s to

00:07:16.490 --> 00:07:23.360
t and suppose that is the shortest path which
goes via v 1 to v m we have seen before. Now,

00:07:23.360 --> 00:07:29.690
if we do the updates in this order that is
we first compute the update from s to v 1

00:07:29.690 --> 00:07:34.719
then we compute v 1 to v 2, then we compute
v 2 to v 3 in between we can do a other things,

00:07:34.719 --> 00:07:39.969
it is only that these updates happen in this
sequence then v 3 to v 4 and so on and finally,

00:07:39.969 --> 00:07:44.939
we do v m to t.
Then, what do you know where we knew earlier

00:07:44.939 --> 00:07:49.970
that if you have correctly computed the distance
up to s, then this update will correctly compute

00:07:49.970 --> 00:07:54.939
the distance of v 1, because this is the second
last node on this. So, if distance of j is

00:07:54.939 --> 00:07:58.900
correct and j is a second last node of the
shortest path to k, distance of k is correct

00:07:58.900 --> 00:08:03.770
after the update, so because distance of s
was 0 and it was correct, when we do update

00:08:03.770 --> 00:08:07.500
s to v 1 this distance becomes correct.
Now, we might do also correct whether updates

00:08:07.500 --> 00:08:12.129
will do not bother us, but now when we come
to v 2 we will be updating v 2 from v 1 and

00:08:12.129 --> 00:08:17.290
v 1 is a second last path on this shortest
path. Therefore, this also becomes a correct

00:08:17.290 --> 00:08:23.009
value, then this also become the correct value.
So, in the middle of all these updates if

00:08:23.009 --> 00:08:27.889
we identify this particular sub sequence of
updates s to v 1 then v 1 to v 2 then v 2

00:08:27.889 --> 00:08:33.460
to v 3 then we have got the distance. So,
now the question is how do we make sure that

00:08:33.460 --> 00:08:39.020
we have this sequence of updates for s and
t.

00:08:39.020 --> 00:08:45.700
So, Bellman-Ford algorithm basically says
do not try to find the particular sequence,

00:08:45.700 --> 00:08:51.370
just generally compute all possible sequence
have updates. So, at a high level this is

00:08:51.370 --> 00:08:57.340
the algorithm. It is says initially assigned
the distance of s to be 0 and the distance

00:08:57.340 --> 00:09:04.020
of u to be infinity for every other vertex.
Now, we just blindly do every updates n minus

00:09:04.020 --> 00:09:11.250
1 times, so what you do is initially you update
for every edge given the fact that s has distances

00:09:11.250 --> 00:09:14.140
0 and u is infinity otherwise, then we update
everything.

00:09:14.140 --> 00:09:18.950
So, all are these updates where s is the source
vertex and v is the target vertex, these will

00:09:18.950 --> 00:09:23.070
give us now some finite values for these vs,
where as these will just remain infinity.

00:09:23.070 --> 00:09:28.220
So, this will become finite and these will
become infinity, now you done one full sequence

00:09:28.220 --> 00:09:33.280
of updates in which other then s all the neighbors
are wish now some finite values, now you do

00:09:33.280 --> 00:09:38.280
this whole thing again.
So, you update every edge again and then you

00:09:38.280 --> 00:09:44.780
update every edge again, now we know that
a shortest path between any two vertices as

00:09:44.780 --> 00:09:52.030
at most n minus 1 edges. Therefore, if we
do this thing n minus 1 time, the claim is

00:09:52.030 --> 00:09:56.190
that if I want any sequence of updates I might
find the sequence of updates should was like

00:09:56.190 --> 00:10:00.460
this or a might find that any sequence of
n minus 1 updates which is a legal path will

00:10:00.460 --> 00:10:06.060
be represented in this case.
So, this is a very clever matrix which has

00:10:06.060 --> 00:10:09.380
all the updates after one iterations, all
the updates after two iterations or for want

00:10:09.380 --> 00:10:13.640
a particular sequence toward update e 1, then
update e 2, then update then I will find it

00:10:13.640 --> 00:10:18.560
e 1 here, then I will look for e 2 here, then
I will find e 3 here and then so on. So, every

00:10:18.560 --> 00:10:24.120
possible path is represented in particular
given our example here by s goes from the

00:10:24.120 --> 00:10:26.710
path goes from s to v 1, v 1 to v 2 and so
on.

00:10:26.710 --> 00:10:30.910
Then, we find that the first updates comes
in iteration 1, then after have been updated

00:10:30.910 --> 00:10:35.620
v 1 the next iteration v 1, v 2 is was a correct
distance to v 2, iteration 3 will give as

00:10:35.620 --> 00:10:40.540
v 2 to v 3 and so on. And finally, iteration
n minus 1 actual it may not be n minus 1 is

00:10:40.540 --> 00:10:44.680
depends on the length of this path. So, when
if this path actually as n minus 1 steps in

00:10:44.680 --> 00:10:48.510
the last one will give us the update from
v m to t and the correct distance about t,

00:10:48.510 --> 00:10:52.560
but this could actually will be even less
then n minus 1 it will path is of less lesser

00:10:52.560 --> 00:10:54.320
length.

00:10:54.320 --> 00:11:01.380
So, the algorithm is actually remarkably simple,
so you start from a source vertex s. So, initially

00:11:01.380 --> 00:11:05.620
you assign the distance to be infinity for
every vertex and you initialize the distance

00:11:05.620 --> 00:11:12.040
of s to be 0. Now, n minus 1 times you blindly
repeat the following operation for every edge

00:11:12.040 --> 00:11:18.120
in your graph apply the distance updates.
So, you take the distance of the target of

00:11:18.120 --> 00:11:23.420
that edge to be the minimum of the current
distance of that target or the distance to

00:11:23.420 --> 00:11:25.330
the source of the edge plus the weight of
the edge.

00:11:25.330 --> 00:11:29.940
So, you just blindly to this n minus 1 times
and it because of this property that you will

00:11:29.940 --> 00:11:34.920
find for every valid shortest path, you will
find the sequence of updates which matches

00:11:34.920 --> 00:11:39.930
that path in this sequence that you are to
computing here, you will always get the shortest

00:11:39.930 --> 00:11:42.850
path to every other vertex starting from s.

00:11:42.850 --> 00:11:49.360
So, let us look at an example and see how
the Bellman Ford algorithm actually works.

00:11:49.360 --> 00:11:53.210
So, here is a graph it has some cycles and
it has an some negative weights, but there

00:11:53.210 --> 00:11:57.890
are no negative cycles, for instance we will
see that here we have a cycles who weight

00:11:57.890 --> 00:12:04.160
is minus 2 plus 1 is minus 1 plus 2 is plus
1. Similarly, here we have a cycle whose weight

00:12:04.160 --> 00:12:10.420
is if you go around from 6 to 3 to 4 to 5
we have minus 2 plus 1 is minus 1 plus 3 is

00:12:10.420 --> 00:12:15.040
plus 2 minus 1 is plus 1, so this is again
cycle or plus 1.

00:12:15.040 --> 00:12:20.490
So, there are negative weights, but no negative
cycles and now in this we want to compute

00:12:20.490 --> 00:12:26.450
shortest paths from 1 to every other vertices.
So, one is that source vertices, so we set

00:12:26.450 --> 00:12:32.560
up this iterations, so in the initial step
we set the distance of vertix 1 to 0 and everything

00:12:32.560 --> 00:12:37.910
else as infinity. Now, we will, in the first
step, try to update all neighbors of things

00:12:37.910 --> 00:12:42.380
that were here, now all values which are infinity
do not update the neighbors, but the value

00:12:42.380 --> 00:12:49.250
1 will it has 2 neighbors 2 and 8.
So, these two things now become finite values

00:12:49.250 --> 00:12:55.610
10 and 8 respectively, now we have a these
three vertices which are finite values. So,

00:12:55.610 --> 00:13:01.250
you would expect that the neighbors namely
7 and 2 has a neighbors 6. So, the only out

00:13:01.250 --> 00:13:05.970
going is from 2 is 6 the only out going edge
from 8 to 7, so you would expect 7 and 6 to

00:13:05.970 --> 00:13:12.230
get updated and indeed the next step you find
the 6 and 7 get values which are updated from

00:13:12.230 --> 00:13:16.670
those values. So, 8 plus 1 is 9 ,10 plus 2
is 12.

00:13:16.670 --> 00:13:26.360
Now, having got this you will find that we
have now updated 1, 2, 8, 7 and 6, now notice

00:13:26.360 --> 00:13:32.510
that I now have another path not this path
from 1 to 2 will have a path which goes this

00:13:32.510 --> 00:13:40.610
way from 1 to 2 via 7 and this becomes a smaller
path, because of this minus 4. So, in this

00:13:40.610 --> 00:13:45.560
iteration I will actually find the first non-trivial
update which could not, which you violate

00:13:45.560 --> 00:13:49.690
the Dijsktra's assumptions that all burnt
vertices or invariant.

00:13:49.690 --> 00:13:54.760
So, the distances two which was already computed
to 10 will actually shift, in addition to

00:13:54.760 --> 00:13:59.440
that of course, because we have new neighbors
of 6 was 6 will now give us a new value for

00:13:59.440 --> 00:14:06.000
3 and so on. So, in this iteration I find
as I said, that the value of 2 reduces the

00:14:06.000 --> 00:14:11.940
value of three becomes something finite. Notice
the value of 6 itself changes, why because

00:14:11.940 --> 00:14:16.370
earlier we were looking at a path like this
and now we have discovered that this is actually

00:14:16.370 --> 00:14:21.310
a better path like this, which has also a
negative edge to add to the benefit.

00:14:21.310 --> 00:14:27.420
So, we come down from 12 to 8 plus 1 minus
is 8, so we continual like this at the next

00:14:27.420 --> 00:14:34.750
step that path to 3 shrink further and that’s
because now having get a better path for 6.

00:14:34.750 --> 00:14:42.550
So, in the previous path we said Oh, the path
for 6 plus 12 and 12 minus 2 was 10, now we

00:14:42.550 --> 00:14:48.070
said, Oh, it is not 12 it is 8. So, 8 minus
2 is actually 6. So, you got a better path

00:14:48.070 --> 00:14:54.400
to 3 we are discovered in new path, because
we had a path to 3 from 10 plus 1 is a 11

00:14:54.400 --> 00:14:57.710
and so on.
So, we continue one more step and then because

00:14:57.710 --> 00:15:04.490
now we know that 4 was reachable and 11 steps
4 plus 3 is 14. So, 5 is reachable, but 4

00:15:04.490 --> 00:15:10.590
itself now because the value of 3 got updated.
So, in this iteration the value of 3 gets

00:15:10.590 --> 00:15:15.860
updated from 11 to 7, this will get propagated
that after one more iteration. So, now this

00:15:15.860 --> 00:15:23.480
value comes down from 14 to 7 plus 3, but
in this process what has happened is in the

00:15:23.480 --> 00:15:29.330
value of 3 has itself gone down one more time.
So, its value again reduces the value of 4

00:15:29.330 --> 00:15:34.920
and then finally, after the n minus 1 iteration
we get a stables set of values. So, this now

00:15:34.920 --> 00:15:41.240
turn out to be the shortest paths to all the
vertices from this start vertex 1.

00:15:41.240 --> 00:15:46.450
So, what is that complexity of this algorithm,
will where this outer loop, so we just run

00:15:46.450 --> 00:15:52.450
this update n minus 1 times. So, it should
runs order n times and now an each loop we

00:15:52.450 --> 00:15:57.330
basically blindly update every edge, so we
have an adjacency matrix, we have to identify

00:15:57.330 --> 00:16:02.040
the edges the only based look at every entire
wherever we see an entry we take that j k

00:16:02.040 --> 00:16:07.410
and we have been updated, but in an adjacency
list we have exactly the edges that we want.

00:16:07.410 --> 00:16:12.200
So, we have 1, 2 up to n and we have exactly
the edges, so we can do this update and order

00:16:12.200 --> 00:16:15.010
n time.
So, if we using adjacency matrix just identifying

00:16:15.010 --> 00:16:19.470
which are the edges takes of the order n square
time. Because, we have to probe every entry

00:16:19.470 --> 00:16:23.230
the adjacency matrix, adjacency list we can
do order m times. So, therefore if use an

00:16:23.230 --> 00:16:27.860
adjacency matrix representation overall the
ford algorithm takes n cube time whereas,

00:16:27.860 --> 00:16:32.720
in the adjacency list representation we can
reduce that to m n. And so of therefore, the

00:16:32.720 --> 00:16:36.029
number of edges is small this is going to
be a much better solution than n cube.

