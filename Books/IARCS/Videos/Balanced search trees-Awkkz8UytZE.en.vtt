WEBVTT
Kind: captions
Language: en

00:00:02.800 --> 00:00:06.779
In the previous lecture, we looked at operations
on search trees. We claim that these were

00:00:06.779 --> 00:00:10.800
efficient that we could maintain balance.
So, let us see how we can keep search tress

00:00:10.800 --> 00:00:11.800
balanced.

00:00:11.800 --> 00:00:18.310
So, recall that we are looking at these 7
operations, we want to able to search for

00:00:18.310 --> 00:00:23.099
a value, we want be able to insert and delete
values, we also want to be able to compute

00:00:23.099 --> 00:00:27.489
the minimum and the maximum value in a tree
and also find the predecessors and successor

00:00:27.489 --> 00:00:33.430
of the given value and all of these we claimed
would be order log n provided the tree is

00:00:33.430 --> 00:00:34.430
balanced.

00:00:34.430 --> 00:00:39.710
So, thus because all of the operations as
we implemented them, we will walk up and down

00:00:39.710 --> 00:00:43.660
a single path and so the worst case would
be the height of the tree and in our balanced

00:00:43.660 --> 00:00:48.350
tree the height will always be logarithmic
in the size of the tree. So, todayâ€™s this

00:00:48.350 --> 00:00:54.770
lecture the goal is to explain, how to maintain
the balance as the tree grows and shrinks.

00:00:54.770 --> 00:01:01.219
So, trees there are many different notions
of balance in a tree, so essentially a balance

00:01:01.219 --> 00:01:07.710
we should think of it is like a physical balance.
So, if you go to an old style vegetable seller,

00:01:07.710 --> 00:01:12.830
when they will have this kind of a balance
and then you want at any point if you hold

00:01:12.830 --> 00:01:18.610
up a tree by it is root, the two side should
be balanced, they should be equal. So, the

00:01:18.610 --> 00:01:23.660
most direct notion of balance is that the
two are exactly that is the number of nodes

00:01:23.660 --> 00:01:27.100
at the left is equal to the number of nodes
in a right for every node.

00:01:27.100 --> 00:01:30.460
Then, it is easy to see that you when you
get a complete binary trees, so example you

00:01:30.460 --> 00:01:35.740
could have a tree which has this structure
or if you extend it one more level, then for

00:01:35.740 --> 00:01:38.580
every node in the left you must extended on
the right, but then these must also be balanced,

00:01:38.580 --> 00:01:43.000
so you must definitely complete this. So,
you can have a tree up to 3 levels which is

00:01:43.000 --> 00:01:48.630
completely filled or up to 4 levels and so
on. So, if you want this exact size balance,

00:01:48.630 --> 00:01:53.490
then it is very restricted.
So, you might have a little bit more flexibility,

00:01:53.490 --> 00:01:58.930
you might say there we do not want to be exactly
equal, we may be wanted it to be at most one

00:01:58.930 --> 00:02:04.610
off, then you could have structures for instants
like this, where you have only a left or you

00:02:04.610 --> 00:02:09.319
have at this point a left and right but you
have only array. These standards structures,

00:02:09.319 --> 00:02:14.620
now which are not complete binary trees become
balanced in this notion. So, this allows us

00:02:14.620 --> 00:02:19.170
more flexibility and we can get more trees
this way, but it is difficult to maintain

00:02:19.170 --> 00:02:24.310
this property incrementally as we do inserts
and deletes. So, we will go for different

00:02:24.310 --> 00:02:27.060
notion of balance.

00:02:27.060 --> 00:02:32.130
Notion of balance that we will use is not
with respect to size, but with respect to

00:02:32.130 --> 00:02:38.820
height. So, we will say that the height is
a number of nodes from the root to a leaf.

00:02:38.820 --> 00:02:48.290
For example, if I have a tree which looks
like this, then here the height is 1, 2, 3,

00:02:48.290 --> 00:02:55.680
4 because on this path we have 4 nodes. So,
the heights become 4 it is a length of the

00:02:55.680 --> 00:02:59.490
longest path measured in terms of nodes, the
reason we measured in terms of nodes is, then

00:02:59.490 --> 00:03:04.400
we can distinguish easily, the empty tree
from the tree with only a root.

00:03:04.400 --> 00:03:08.220
If you measured in terms of edges, the tree
with only a root will have height 0, because

00:03:08.220 --> 00:03:11.700
there are no edges and so would be the empty
tree. Whereas, if we measure it in terms of

00:03:11.700 --> 00:03:16.959
nodes, then the empty tree has height 0 and
the tree with only the root has height 1.

00:03:16.959 --> 00:03:22.350
So, we can distinguish these two. And now
in keeping with our earlier relaxation of

00:03:22.350 --> 00:03:27.000
the size condition, the height balance tree
will be one where the height of the left and

00:03:27.000 --> 00:03:28.910
the height of the right differ the at most
1.

00:03:28.910 --> 00:03:38.910
Now, this is more relaxed in the previous
thing. For example, now of course, I could

00:03:38.910 --> 00:03:51.560
start with a height balance tree like this.
And then, I could now connect this to form

00:03:51.560 --> 00:04:01.319
a height balance tree like this and now this
which is a height 3 tree I can connect with

00:04:01.319 --> 00:04:08.520
a height 2 tree and form a height balance
tree which looks like this. So, the height

00:04:08.520 --> 00:04:13.650
of the left sub tree is 3, height of the right
sub tree is 2 in this recursively the height

00:04:13.650 --> 00:04:16.920
of left sub tree is 2, the height of the right
is sub tree is 1 and so on.

00:04:16.920 --> 00:04:21.409
So, we could have things which look quit difference,
so size here for instant size is 4 and size

00:04:21.409 --> 00:04:30.360
is 2. But, nevertheless you can kind of compute
that the size even in this case will be exponential

00:04:30.360 --> 00:04:34.809
in the height or rather the height will be
logarithmic in the size. So, these trees are

00:04:34.809 --> 00:04:40.029
called AVL trees the named after the two people
who independently invented them one person

00:04:40.029 --> 00:04:45.819
called Adelson-Velsky and independently Landis.
So, an AVL tree is a height balanced tree

00:04:45.819 --> 00:04:49.439
which says that at every node the height of
the left and height of the right sub trees

00:04:49.439 --> 00:04:53.080
differ by at most 1.

00:04:53.080 --> 00:04:59.729
So, let us refer to the difference between
the height as just the slope, so we have a

00:04:59.729 --> 00:05:04.501
intuitively in our pictures. So, if it is
unbalance then thing is treated, so we could

00:05:04.501 --> 00:05:09.389
have tilt this way or tilt this way, so we
call this the slope. So, we let us say this

00:05:09.389 --> 00:05:12.939
slope is height of the left minus height,
so the height of the left is less than the

00:05:12.939 --> 00:05:16.680
height of the right, then you have a positive
slope. If the height of the left is bigger

00:05:16.680 --> 00:05:21.189
than the height of the right, then you have
right, left is smaller than right you have

00:05:21.189 --> 00:05:24.830
negative slope, left is bigger than right
you are positive slope.

00:05:24.830 --> 00:05:29.710
So, in a balanced tree since the height difference
absolute value must be 1, you can only have

00:05:29.710 --> 00:05:34.330
three possible slopes throughout the tree,
either there is no slope they are exactly

00:05:34.330 --> 00:05:41.199
the same or it is minus 1 or plus 1. Now,
if you can argue very easily that if the current

00:05:41.199 --> 00:05:46.930
value is of the slope some minus 1 plus 1,
when you delete a node, you can reduce one

00:05:46.930 --> 00:05:51.849
of the heights by 1. So, the height difference
can go from 1 to 2 or when you increase you

00:05:51.849 --> 00:05:54.219
can make the height difference, again go from
1 to 2.

00:05:54.219 --> 00:05:58.939
So, the new slope after a single insert or
a single delete can be at most minus 1 or

00:05:58.939 --> 00:06:04.930
plus 2, minus 2 or plus 2. So, what we will
end up to do what we will try to do is that

00:06:04.930 --> 00:06:09.539
whenever we do an insert or a delete we will
immediately try to rebalance the tree. So,

00:06:09.539 --> 00:06:16.199
we would have a single disturbance from minus
2 or plus 2 it will never become very badly

00:06:16.199 --> 00:06:20.430
unbalance and we will immediately restore
the balance to within minus 1 to plus 1.

00:06:20.430 --> 00:06:25.680
So, you will do this rebalancing we will also
do this rebalancing bottom up, so what happens

00:06:25.680 --> 00:06:30.879
we will be do an insert, if you remember is
that we go down and we find a place to insert.

00:06:30.879 --> 00:06:36.169
So, this point we add a new node, so therefore
now at this point there could be some imbalance,

00:06:36.169 --> 00:06:40.610
so we fix it, then we will go back to the
up this path and we will go there and we will

00:06:40.610 --> 00:06:46.330
fix the path here, but at this point you will
assume that the tree below has been balanced.

00:06:46.330 --> 00:06:51.620
So, whenever we rebalance the slope which
is outside the range, you will assume that

00:06:51.620 --> 00:06:57.139
the sub trees below that are already balanced,
because this balancing as we will see is going

00:06:57.139 --> 00:06:58.930
to be done bottom up.

00:06:58.930 --> 00:07:07.020
So, here is a typical situation that we would
reach after a single operation which removes

00:07:07.020 --> 00:07:12.569
the balance. So, we might have a node which
has slope plus 2 or minus 2, so let us look

00:07:12.569 --> 00:07:18.389
at plus 2 minus 2 turn out be symmetric. So,
we have a node which we call x which has slope

00:07:18.389 --> 00:07:22.570
plus 2 and what it means is, it has a left
tree and right tree. Such that, the height

00:07:22.570 --> 00:07:26.430
of the left tree is 2 more than the height
of the right tree, remember this slope is

00:07:26.430 --> 00:07:30.789
height or left minus height of left, so h
plus 2 minus h will be 2.

00:07:30.789 --> 00:07:39.370
Now, recursively we are going to assume that
all the slopes here and here are at most plus

00:07:39.370 --> 00:07:45.069
1 or minus 1. So, we are assuming that everything
below this has been fixed and the only in

00:07:45.069 --> 00:07:49.539
balance in this sub tree at x is x itself.

00:07:49.539 --> 00:07:57.949
So, now since the left has height h plus 2,
it has height at least 2, h can be at most

00:07:57.949 --> 00:08:02.779
at least smallest h can be 0, so it has height
at least 2, so there at least 1 node here.

00:08:02.779 --> 00:08:06.770
I mean 2 means that there are at least 2 nodes
here, so we have at least 1 node in particular.

00:08:06.770 --> 00:08:14.319
So, we will expand this by exposing it is
root and the root will have in general 2 sub

00:08:14.319 --> 00:08:20.900
trees, so now this whole thing as height h
plus 2.

00:08:20.900 --> 00:08:31.149
So, we will now look at this new node that
we have expected. So, its slope is minus 1

00:08:31.149 --> 00:08:35.550
0 or plus 1 and we are going to do some bottom
up rebalancing, we are assuming everything

00:08:35.550 --> 00:08:39.709
below it is case. So, I have going to do some
case analysis based on what is the slope of

00:08:39.709 --> 00:08:41.490
y.

00:08:41.490 --> 00:08:48.190
So, let us first look at the situation where
the slope of y is either 0 or plus 1, so if

00:08:48.190 --> 00:08:53.670
it is 0 or plus 1 it means that so remember
this whole thing was h plus 2 of which 1 node

00:08:53.670 --> 00:08:59.000
is here, so it is left child must be at least
h plus 1 and because it is slope is 0 or plus

00:08:59.000 --> 00:09:03.620
1, the right child is either h plus 1 in case
slope is 0 or it is h incase the slope is

00:09:03.620 --> 00:09:13.740
plus 1. So, now this is the current situation
as we have it with an unbalanced node x everything

00:09:13.740 --> 00:09:17.550
below is balanced. But we have just come to
a situation where we try to analyze what is

00:09:17.550 --> 00:09:21.120
the situation below.
So, x is got a balanced unbalance of plus

00:09:21.120 --> 00:09:25.990
2 and below it we have why which whereas assuming
is either 0 or plus 1. So, now we do this

00:09:25.990 --> 00:09:31.420
rotation, so we take this tree and we kind
of hang it out by y and we reattach things.

00:09:31.420 --> 00:09:36.710
So, in this rotation when you hang it out
by y, x comes down and now we look at this

00:09:36.710 --> 00:09:44.870
sub trees, so we have the 3 sub trees, we
have TLL, TLR and TR. So, TR is to the right

00:09:44.870 --> 00:09:51.970
of x and it is also to the right of y, so
it is the right of both, TLR is to the left

00:09:51.970 --> 00:09:55.490
of x to the right of y, TLL is to left of
y, left of x.

00:09:55.490 --> 00:10:01.579
So, if you go there we find that TR is to
the right of both, TLR is to the left of x

00:10:01.579 --> 00:10:06.360
right of y and TLL is to the left of both.
So, we hang up these trees, so now all the

00:10:06.360 --> 00:10:11.940
values we can verify will be currently organized
as a search tree should. But, now if you look

00:10:11.940 --> 00:10:15.490
at the slopes, we have just inherited this
slope some what we knew that the slope of

00:10:15.490 --> 00:10:20.940
TLL of h plus 1, TLR is h plus 1 or h and
TR is h.

00:10:20.940 --> 00:10:26.200
So, this means that if I look at this over
all height at this point, it is either h plus

00:10:26.200 --> 00:10:32.170
1 or at most h plus 2, so this is h plus 2
or h plus 1. If it is h plus 2, then the height

00:10:32.170 --> 00:10:37.449
slope at y is minus 1, if it h plus 1 then
both sides at h plus 1 slope at y is 0 and

00:10:37.449 --> 00:10:42.110
if you look at x, here we have h plus 1 and
here we have h, so the difference is either

00:10:42.110 --> 00:10:48.279
0 or plus 1. So, x is now balanced, y is balanced
and by assumption inductively all the grey

00:10:48.279 --> 00:10:55.379
sub trees are balanced. So, by one right rotation,
we have rebalanced the tree.

00:10:55.379 --> 00:11:04.380
So, the third situation is that it is not
0 or plus 1, but the slope at y is minus 1.

00:11:04.380 --> 00:11:10.750
So, we have already dealt with the case where
0 or plus 1 is the possibility. So, if it

00:11:10.750 --> 00:11:15.700
is minus 1 this means that the right sub tree
must be strictly taller than the next left

00:11:15.700 --> 00:11:20.519
sub tree. So, with the whole thing remember
again is h plus 2 the high assumption, because

00:11:20.519 --> 00:11:24.380
the whole thing has plus 2, so this whole
thing is h plus 2 and this thing is h.

00:11:24.380 --> 00:11:30.079
Now, this h plus 2 it now beings split of
y and the rest therefore h plus 1 must be

00:11:30.079 --> 00:11:33.540
coming in the right and h 1 the left we got
the slope by assumption we are assuming slope

00:11:33.540 --> 00:11:39.300
is minus 1. So, now we are going to expand
out this node now it is a h plus 1, so there

00:11:39.300 --> 00:11:45.720
is at least 1 node here even a way which is
0 it has at least a root node. So, we will

00:11:45.720 --> 00:11:47.879
expose a root node as we exposed y earlier.

00:11:47.879 --> 00:11:56.889
So, now we are kind of expend it this TLR
as z with 2 sub trees TLRL. So, this supposed

00:11:56.889 --> 00:12:01.170
to indicate let us started their original
tree go and left go right and go left, so

00:12:01.170 --> 00:12:08.009
TLRL go left, go right, go right. So, it is
TLRR, so that is notation for the sub trees,

00:12:08.009 --> 00:12:14.829
so this whole thing was h plus 1. So, therefore,
this h plus 1 can come either sides, so either

00:12:14.829 --> 00:12:20.980
this is h or h minus 1 or this is h or h minus
1 at least is one of then must be h.

00:12:20.980 --> 00:12:25.259
Because, we are both are h minus 1 then the
whole thing cannot be h plus 1. So, at least

00:12:25.259 --> 00:12:29.620
1 is h and it is balanced, so I do not know
which way it is, but at least one of these

00:12:29.620 --> 00:12:33.500
trees as h I will h the other one could have
h or h minus 1 and it terms out it will not

00:12:33.500 --> 00:12:39.790
matter which one. So, now I have a two-step
procedure what I will do is, now I will do

00:12:39.790 --> 00:12:47.970
is similar rotation, but to the left involving
these two nodes. So, I will hang up these

00:12:47.970 --> 00:12:50.029
sub trees here by z.

00:12:50.029 --> 00:12:56.899
So, if I hang up these sub trees then what
happens is that these 3 trees below have to

00:12:56.899 --> 00:13:05.949
be a reattached and we reattach some in the
correct with TLL is bit to the left of both

00:13:05.949 --> 00:13:12.060
y and z TLRR is to the right of both y and
z and TLRL is to the left of z and to the

00:13:12.060 --> 00:13:17.850
right of 1. And now, if you go back and check
all the heights, then you find that at y I

00:13:17.850 --> 00:13:28.720
either have height 0 or I have height plus
1. Now, if I look at z then the left hand

00:13:28.720 --> 00:13:36.680
side is now h plus 1 and the right hand side
is h or h minus 1.

00:13:36.680 --> 00:13:42.699
So, if is h plus 1 and this is the h then
I get plus 1, if it is h plus 1 this h minus

00:13:42.699 --> 00:13:48.310
1 I get plus 2. So, in the process now not
only did I have x which was unbalanced and

00:13:48.310 --> 00:13:52.949
temporarily created is z which potentially
is unbalance. So, I cannot say for sure it

00:13:52.949 --> 00:13:56.290
is unbalance, but it could to a unbalance,
because I do not know which is h and which

00:13:56.290 --> 00:14:00.209
is h minus h 1, but this is only in intermediate
steps, so now what I did, so earlier what

00:14:00.209 --> 00:14:05.439
we did, we will did on left rotation here.
So, I am going to follow this a by a right

00:14:05.439 --> 00:14:06.439
rotation at x.

00:14:06.439 --> 00:14:13.410
So, we rotate write a text z goes up x goes
down and now again we hang of the 4 trees

00:14:13.410 --> 00:14:16.990
and there is only one way to hang of you can
verify it will go back and check out their

00:14:16.990 --> 00:14:22.790
hanging. So, TRR must be bigger than z and
x, TLL must be smaller than y and z and so

00:14:22.790 --> 00:14:26.610
on. And now we have a very happy situation
which is that if you look at the slope of

00:14:26.610 --> 00:14:31.389
y, then it is the either 0 or it could be
plus 1 because this could be h minus 1.

00:14:31.389 --> 00:14:37.389
If you look at x it could be minus 1, because
this could be h minus 1 this definitely h

00:14:37.389 --> 00:14:42.690
or we could be 0. But, this whole thing is
definitely h plus 1 because I do have at least

00:14:42.690 --> 00:14:46.870
1 sub tree of size h, this whole thing is
again h plus 1, because I have at least 1

00:14:46.870 --> 00:14:52.560
sub tree of size h and therefore, the slope
at 0 at z is 0. So, both all three nodes x,

00:14:52.560 --> 00:14:58.939
y and z have slopes in the correct range and
therefore, I again I will stored the balance.

00:14:58.939 --> 00:15:06.920
So, to summarize this what we have said is
that if we have plus 2, then we look at the

00:15:06.920 --> 00:15:15.029
left child of x call it y, if the slope of
y is 0 or 1 we rotate at right at x, if the

00:15:15.029 --> 00:15:20.269
slope at y is minus 1 be first rotate this
and then we rotate y. Either case we rotate

00:15:20.269 --> 00:15:26.730
at x, but first we rotated y in cases show
to minus 1. Now, it will turn out that if

00:15:26.730 --> 00:15:30.529
you have the other side case, the other extreme
where the slope at x is minus 2, then will

00:15:30.529 --> 00:15:34.660
have a symmetric picture, so we will have
to expose the right child I will call it y.

00:15:34.660 --> 00:15:40.269
So, then the basic basics operation is that
if y has slope minus 1 or 0 its symmetric

00:15:40.269 --> 00:15:45.550
remember, then we will do a single left rotation
x. Otherwise, we will first do a right rotation

00:15:45.550 --> 00:15:50.990
at y, in case is slope at y is plus 1 and
then we will do a left rotation at x. So,

00:15:50.990 --> 00:15:55.680
we one not look at their minus 2 cases in
detail, but it is easy to see that it is symmetric

00:15:55.680 --> 00:15:57.209
to the plus 2 case.

00:15:57.209 --> 00:16:03.300
So, how do you do these rotations, where will
you can just draw this pictures and figure

00:16:03.300 --> 00:16:07.509
at outs. So, you just give names to everything,
so we say that we want to rotate this x down

00:16:07.509 --> 00:16:13.939
in the y up, now we have are original t pointing
here remember. So, it is we cannot change

00:16:13.939 --> 00:16:18.540
in the node that t is pointing 2, so we remember
the value at t we remember the value here.

00:16:18.540 --> 00:16:23.529
So, we need this names x and y to the contents
and then we have this counters pointing to

00:16:23.529 --> 00:16:28.259
these three trees TLL, TLR and TR and then
we reconnect that.

00:16:28.259 --> 00:16:41.970
So, what we do is we first replace this value
by y, then what we do is we make this node

00:16:41.970 --> 00:16:51.570
come to the right and we reset it is value
to x. So, we put an x here and we have moved

00:16:51.570 --> 00:16:57.180
it there and then we have hang off below that
top node on the left we put TLL and below

00:16:57.180 --> 00:17:01.190
this right new right node on the left if put
TLR on the right would TR. So, you just do

00:17:01.190 --> 00:17:05.650
this kind of reconnection is like a you know
un hooking and re hooking trees and just we

00:17:05.650 --> 00:17:09.220
just keep track of the all the names. So,
that everything is un hook and re hook correctly.

00:17:09.220 --> 00:17:14.750
So, it is a very simple, so you notice that
this the kind of constant set of operation

00:17:14.750 --> 00:17:18.670
involving of few of these left and right pointers.
So, it will be regardless of the size of the

00:17:18.670 --> 00:17:25.120
tree, it is a very local operation. So, we
can treat this as one constant unit operation.

00:17:25.120 --> 00:17:29.600
And a similar thing for the left, we give
names and just we do this updating exactly

00:17:29.600 --> 00:17:34.450
has we had done before. So, again these are
constant set of operations which implements

00:17:34.450 --> 00:17:35.450
rotate left.

00:17:35.450 --> 00:17:41.810
So, now that we have that two rotations, then
what does rebalancing say, rebalancing says

00:17:41.810 --> 00:17:49.290
that if I have node which has plus 2, then
I will expose its left child and I will check

00:17:49.290 --> 00:17:55.870
it slope, if it is slope is minus 1 then first
I will do a left rotation there and then regardless

00:17:55.870 --> 00:18:01.350
I will do a right rotation at the top. And
the symmetric cases, if I have a slope just

00:18:01.350 --> 00:18:08.410
minus 2 at the top, then it will have a right
child and then if this as plus 1 when I will

00:18:08.410 --> 00:18:14.222
first to a right rotation here and then regardless
I will do a left rotation of the top. So,

00:18:14.222 --> 00:18:20.020
rebalancing is these two steps and rotation
this is set up other steps, so basically rebalancing

00:18:20.020 --> 00:18:24.220
at a given node is a constant number operations
at that node.

00:18:24.220 --> 00:18:30.360
So, now what we do is every time we make a
change in our tree which could affect the

00:18:30.360 --> 00:18:36.290
balance of the slope of a node, we do a balance.
So, when we in our earlier code for insert,

00:18:36.290 --> 00:18:41.961
when we did a recursive insert in the left
of a tree we rebalance it, similarly we insert

00:18:41.961 --> 00:18:45.190
in the right of the tree we rebalance it,
we just introduce this rebalance code and

00:18:45.190 --> 00:18:49.790
note is that this a constant operations for
this node. So, you will do this all the way

00:18:49.790 --> 00:18:53.650
along the paths. So, this will do a log n
times in constant number operations, so this

00:18:53.650 --> 00:18:58.570
would not affect anything in terms of the
asymptotic complexity of our operation it

00:18:58.570 --> 00:19:06.000
will be a logarithmic number of constant time
operations for each node.

00:19:06.000 --> 00:19:09.700
The same with the delete, where above we do
a recursive delete we rebalance.

00:19:09.700 --> 00:19:13.840
And then there was a case where we deleted
the maximum value or the predecessor, so again

00:19:13.840 --> 00:19:18.770
we do a rebalance. So, where ever we had are
insert and delete affecting the structure

00:19:18.770 --> 00:19:22.780
of the tree we just make sure that we rebalanced
the tree the tree at that point.

00:19:22.780 --> 00:19:30.320
So, there is one point we have to be bit careful
about in this thing, so we said that we have

00:19:30.320 --> 00:19:35.450
to do all these rebalancing. So, if you go
back to rebalancing, so rebalancing requires

00:19:35.450 --> 00:19:41.620
to compute the slope and slope we said was
define to the height of the left minus height

00:19:41.620 --> 00:19:46.570
of the right. Now, it is possible to compute
the height on the fly, the height of the tree

00:19:46.570 --> 00:19:51.930
is recursively computed, if it is nil it has
height 0; otherwise, you recursively compute

00:19:51.930 --> 00:19:56.270
the height of the left in the right and then
accounting for this node you add one to that.

00:19:56.270 --> 00:20:01.920
So, you take the maximum of the two sub trees
and add one, but this unfortunately involves

00:20:01.920 --> 00:20:07.340
examining every node in the tree. So, this
will be propositional to order of the size

00:20:07.340 --> 00:20:12.550
of the tree. So, this will be exponential
operation in some sense depend I mean compare

00:20:12.550 --> 00:20:17.960
to the path, so we are try to do log n operation,
this will be a order n operation. So, this

00:20:17.960 --> 00:20:22.920
will be killing all our attempts to do something
efficiently, because in order to compute the

00:20:22.920 --> 00:20:27.320
height we actually have to see the entire
tree which is not we want to do.

00:20:27.320 --> 00:20:32.140
But, we can get around this by just keeping
the current value of the height and updating

00:20:32.140 --> 00:20:39.960
it each then. So, we have additional thing,
so we have in our tree node, we currently

00:20:39.960 --> 00:20:52.780
had the value, parent, left and right. So,
now we just add one more field called height,

00:20:52.780 --> 00:20:58.810
so now whenever we do any rebalancing, then
the height of this tree may change the current

00:20:58.810 --> 00:21:03.100
node. So, we just look inductively we assume
that below has the height got set correctly.

00:21:03.100 --> 00:21:07.202
So, we look at the two heights which are locally
there add want to the maximum of the two.

00:21:07.202 --> 00:21:11.620
Now, this is just looking up one value and
are two neighbors below to two children. So,

00:21:11.620 --> 00:21:15.040
this now becomes a constant time operations,
it does not require us to traverse entire

00:21:15.040 --> 00:21:19.370
trees. So, as we are rebalancing we readjust
the heights and every time you want to check

00:21:19.370 --> 00:21:26.790
to slope we just have to check the value of
the two tree is below us and check that difference

00:21:26.790 --> 00:21:29.990
of their heights. Because, that will be given
locally by this height field in the node.

00:21:29.990 --> 00:21:35.560
So, we have to be careful not to compute height
recursively, but to store the height as part

00:21:35.560 --> 00:21:40.700
of the tree and also update that with every
update.

00:21:40.700 --> 00:21:47.190
So, to summarize you can use rotations to
maintain height balanced binary search trees

00:21:47.190 --> 00:21:53.440
and then height balance search tree we have
claimed that the height is going to be logarithmic

00:21:53.440 --> 00:21:58.491
in the size. And since all our operations
or propositional to the height, because they

00:21:58.491 --> 00:22:05.930
all go along and one path, all these operation
namely find, insert, delete, minimum, maximum,

00:22:05.930 --> 00:22:09.540
predecessor and successor can all be done
in logarithmic time.

