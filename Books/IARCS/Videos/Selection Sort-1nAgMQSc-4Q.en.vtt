WEBVTT
Kind: captions
Language: en

00:00:00.909 --> 00:00:06.020
So, having seen how to search for an element
in an array, now let us turn to sorting.

00:00:06.020 --> 00:00:11.550
So, the most basic motivation for sorting
comes from searching. As we have seen, if

00:00:11.550 --> 00:00:15.820
you have an unsorted array, you have to search
for it by scanning the entire array from beginning

00:00:15.820 --> 00:00:20.670
to end. So, you spend linear time searching
for the element, whereas if you had sorted

00:00:20.670 --> 00:00:25.150
array, you can probe it at the midpoint and
use binary search and achieve the same result

00:00:25.150 --> 00:00:29.820
in logarithmic time, and logarithmic time
is considerably faster than linear time.

00:00:29.820 --> 00:00:35.180
Now, there are other advantages to having
the elements sorted. For instance, if you

00:00:35.180 --> 00:00:39.379
want to find the median, the value for which
half the elements are bigger, half the elements

00:00:39.379 --> 00:00:44.110
are smaller. Well, the median in a sorted
array is clearly the midpoint of the array.

00:00:44.110 --> 00:00:48.260
If you want to do some other kind of statistical
things, such as building a frequency table

00:00:48.260 --> 00:00:53.370
of values, when you sort these values they
all come together, right. So, all the equal

00:00:53.370 --> 00:00:56.870
values will be in a contiguous block. So,
it is much easier to find how many copies

00:00:56.870 --> 00:01:00.469
of each value are there.
And in particular, if you want only one copy

00:01:00.469 --> 00:01:04.970
of every value, if you want to remove all
duplicates of the array, then you scan the

00:01:04.970 --> 00:01:09.080
sorted array from beginning to end and for
each block of values keep just one copy. So,

00:01:09.080 --> 00:01:14.120
there are very many different reasons why
one may want to sort an array to make further

00:01:14.120 --> 00:01:17.120
computation on the array much easier.

00:01:17.120 --> 00:01:25.470
So, let us imagine how you would like to sort
an array. So, forget about arrays and think

00:01:25.470 --> 00:01:29.330
about just sorting something, which is given
to you as a physical collection of object.

00:01:29.330 --> 00:01:33.830
So, say, you are teaching assistant for a
course and the instructor, the teacher who

00:01:33.830 --> 00:01:40.780
is teaching the course has corrected the exams,
now wants you to sort the exam papers in order

00:01:40.780 --> 00:01:46.190
of marks. So, say, your task is to arrange
them in descending order, how would you go

00:01:46.190 --> 00:01:48.950
about this task?

00:01:48.950 --> 00:01:56.530
So, one naive strategy is the following. You
would go through the entire stack and keep

00:01:56.530 --> 00:02:01.070
track of the smallest mark that you have seen.
At the end of your pass you have the paper

00:02:01.070 --> 00:02:06.950
in your hand, which has smallest mark among
the marks allotted to all the students. So,

00:02:06.950 --> 00:02:10.720
you move this to a new pile, then you repeat
the process. You go through the remaining

00:02:10.720 --> 00:02:14.220
papers after having discarded the smallest
one into the new pile and look for the next

00:02:14.220 --> 00:02:18.780
smallest one, move that on top of the new
pile and so on. So, after the second pass

00:02:18.780 --> 00:02:22.150
you have second smallest mark on the pile.
After the third pass you have the third smallest

00:02:22.150 --> 00:02:27.060
mark on the pile and as you can imagine, after
n passes you have moved all n papers from

00:02:27.060 --> 00:02:30.500
the old pile to the new pile in descending
order.

00:02:30.500 --> 00:02:37.530
So, this particular strategy can be illustrated
as follows. So, supposing we have this list

00:02:37.530 --> 00:02:42.250
or array of six elements. So, in the first
pass we look for the smallest value. So, the

00:02:42.250 --> 00:02:47.860
smallest value in this case is 21. So, we
move 21 to a new list and remove it from the

00:02:47.860 --> 00:02:52.940
original list. Now, we repeat the scan among
the remaining values. The value 32 is the

00:02:52.940 --> 00:02:58.030
smallest one, so we remove that and move it
to new list. We keep doing this. So, at the

00:02:58.030 --> 00:03:07.150
next step, we move 55 and then we move 64
and then we move 74 and then we move 89, right.

00:03:07.150 --> 00:03:12.720
So, in this process if this had been a vertical
stack, 21 would be at the bottom, 89 would

00:03:12.720 --> 00:03:16.760
be at the top, and so we would have the list
sorted from top to bottom in descending order.

00:03:16.760 --> 00:03:21.710
In this case, it is from right to left in
descending order or from left to right in

00:03:21.710 --> 00:03:22.710
ascending order.

00:03:22.710 --> 00:03:30.900
So, this strategy is called selection sort.
So, we select in each round the next element,

00:03:30.900 --> 00:03:34.870
which is the smallest, and therefore the next
to be put out in the sorted order and move

00:03:34.870 --> 00:03:39.810
it to its correct position, that is to the
end of the final sorted list.

00:03:39.810 --> 00:03:46.420
Now, this version of selection sort that we
just described, builds a second list. In other

00:03:46.420 --> 00:03:50.819
words, in order to sort one pile we have to
create a second pile of papers. Now, we can

00:03:50.819 --> 00:03:56.000
easily eliminate the second pile of papers
if we do the following. When we find the minimum

00:03:56.000 --> 00:03:59.990
element, we know it must go to the beginning
of the list. So, instead of creating a new

00:03:59.990 --> 00:04:04.319
list we move it to the beginning of the current
list. Of course, in the beginning of the current

00:04:04.319 --> 00:04:08.290
list there is another value. So, we have to
do something with that value. You just exchange

00:04:08.290 --> 00:04:12.020
the positions.
So, we find the minimum position and swap

00:04:12.020 --> 00:04:16.370
the value at that minimum position with the
value at the first position. Now, the smallest

00:04:16.370 --> 00:04:19.810
value in the entire array has moved to the
beginning. So, now, we start from the second

00:04:19.810 --> 00:04:23.490
element onwards and look for the minimum.
Again, this will be the second smallest. So,

00:04:23.490 --> 00:04:27.700
we, now having found that we will move that
to the second position in the array. So, we

00:04:27.700 --> 00:04:32.840
keep doing this and without using a second
list we are able to do the same sorting that

00:04:32.840 --> 00:04:34.180
we did before.

00:04:34.180 --> 00:04:40.270
So, to see how this works we take the same
array that we had before. As we said, in the

00:04:40.270 --> 00:04:45.490
first round we identified 21 as the minimum
element, which is marked in red and the 1st

00:04:45.490 --> 00:04:50.490
position is 74. So, we would like 21 to be
at the beginning of this list. So, since 74

00:04:50.490 --> 00:04:57.280
is there, we exchange 21 and 74 and we get
this new list. In this new list, now 21 is

00:04:57.280 --> 00:05:01.930
marked in green to indicate that it is in
its final position. It is the smallest value,

00:05:01.930 --> 00:05:05.600
it has moved to where it should be in the
sorted list. So, now we scan the remaining

00:05:05.600 --> 00:05:11.020
elements and we identify that 32 is the smallest
element. Now, 32 already happens to be in

00:05:11.020 --> 00:05:15.600
the 2nd position. So, we could think of exchanging
it with itself or doing nothing depending

00:05:15.600 --> 00:05:21.070
on how you want to interpret it. So, 32 now
becomes marked in green, so that it stays

00:05:21.070 --> 00:05:25.720
in the correct position.
Now, in the remaining list 55 is the smallest

00:05:25.720 --> 00:05:31.060
element mark in red, but it has to be at position
3, which is occupied by 89 marked in yellow.

00:05:31.060 --> 00:05:37.180
So, we exchange these two and now we have
55 in 3rd position. So, we keep doing this.

00:05:37.180 --> 00:05:42.699
So, at the next step, we will identify 64
and swap it into the 4th position and then

00:05:42.699 --> 00:05:47.250
we find, that 74 is already in the correct
position. So, we leave it where it is and

00:05:47.250 --> 00:05:51.620
finally, of course, 89 is the only element.
So, when you have a list of one element there

00:05:51.620 --> 00:05:54.180
is no sorting do be done.

00:05:54.180 --> 00:06:01.889
So, this procedure can be described by a very
simple iterative algorithm. So, what we do

00:06:01.889 --> 00:06:07.229
is, that we have, if you remember, we start
by scanning the entire array, that is, from

00:06:07.229 --> 00:06:15.220
0 to n minus 1, we look for the minimum element
in that segment, right. So, we have an iteration,

00:06:15.220 --> 00:06:20.919
which basically starts at the starting position
and then from the starting position onwards

00:06:20.919 --> 00:06:24.669
it assumes, that the beginning is the, is,
is the minimum value and whenever you find

00:06:24.669 --> 00:06:30.520
a smaller value, you mark that as the minimum
position. Now, having done all this right

00:06:30.520 --> 00:06:39.710
we have now found the minimum from A 0 to
A n minus 1, then you move this value to the

00:06:39.710 --> 00:06:45.110
beginning. So, you swap the starting position
and the minimum position. Now, we have the

00:06:45.110 --> 00:06:48.360
smallest value at A 0.
So, now, you go back to this loop and now

00:06:48.360 --> 00:06:55.360
you move starting position from 0 to 1. So,
you do the same scan for A 1 to A n minus

00:06:55.360 --> 00:07:00.190
1, right and now starting position is 1. So,
at the end you swap the second smallest element

00:07:00.190 --> 00:07:06.639
to A 1, then you do it for A 2 to A n minus
1 and so on, right. So, this is the simple

00:07:06.639 --> 00:07:12.030
iterative version of selection sort where
we just start with the entire array, move

00:07:12.030 --> 00:07:15.900
the smallest element to the first element,
first position, then we take the rest of the

00:07:15.900 --> 00:07:20.550
array from A 1 onwards move the smallest element
to A 1, then start with A 2, find the smallest

00:07:20.550 --> 00:07:23.630
element, move it to A 2 and so on.

00:07:23.630 --> 00:07:31.460
So, how much time does this algorithm take?
So, clearly in order to find the minimum element

00:07:31.460 --> 00:07:36.360
in an unsorted segment of length k we have
to scan the entire segment and this takes

00:07:36.360 --> 00:07:42.040
K steps and in each iteration the segment
to be scanned reduces by 1. So, we start by

00:07:42.040 --> 00:07:46.900
scanning all n elements, then we scan n minus
1 elements, then we scan n minus 2 elements

00:07:46.900 --> 00:07:52.389
and so on. So, we have over all the number
of steps is n plus n minus 1 plus n minus

00:07:52.389 --> 00:08:00.230
2 down to 1, which is just the usual summation
i is equal to 1 to n of i. And this we know

00:08:00.230 --> 00:08:05.400
is n into n plus 1 by 2 which is order n square,
right. So, this naive algorithm selection

00:08:05.400 --> 00:08:09.500
sort in this iterative implementation is n
square.

00:08:09.500 --> 00:08:17.410
Now, there is another way of looking at selection
sort. So, remember we said, that we start

00:08:17.410 --> 00:08:21.611
by finding the minimum element moving it to
the front and then doing the same thing. Whenever

00:08:21.611 --> 00:08:27.300
you say do the same thing it is useful to
think of this as a recursive algorithm just

00:08:27.300 --> 00:08:32.380
to convince yourself, that what you are doing
is correct. So, in order to sort in general

00:08:32.380 --> 00:08:37.499
A from some position i to n minus 1, what
we do is we find the minimum value in the

00:08:37.499 --> 00:08:42.499
segment, that is, from A i to A n minus 1
and move it to the beginning, which is A i,

00:08:42.499 --> 00:08:48.649
right.
So, we have an array A and then we are at

00:08:48.649 --> 00:08:53.959
a position i and the last position n minus
1. We are trying to sort this. So, what we

00:08:53.959 --> 00:09:00.110
are saying is, we will find the minimum somewhere
and then exchange the value here and now what

00:09:00.110 --> 00:09:06.209
is now achieved by this is, that this position
is now correct, right. So, the value at A

00:09:06.209 --> 00:09:12.790
i is now in the correct position and therefore,
we now, only need to sort from i plus 1 to

00:09:12.790 --> 00:09:16.899
n minus 1 and how do we do this? Recursively.
We just apply selection sort. So, we apply

00:09:16.899 --> 00:09:22.300
selection sort to A from i plus 1 to n minus
1 and then this procedure stops when we have

00:09:22.300 --> 00:09:23.300
only one element.

00:09:23.300 --> 00:09:27.079
So, if you are going to start from A i is
equal to n minus 1 to n minus 1, then we do

00:09:27.079 --> 00:09:32.879
nothing, right. So, this, the reason to think
of it recursively. One reason is, that the

00:09:32.879 --> 00:09:38.639
code becomes a little easier to read. So,
you say, that you want to sort A from start

00:09:38.639 --> 00:09:44.769
to n where start is the index of the unsorted
segment where it begins and n is the total

00:09:44.769 --> 00:09:50.100
size. So, the last position is exactly n minus
1. So, if start is n minus 1 or bigger, then

00:09:50.100 --> 00:09:56.740
you do nothing, you just return, otherwise
you find the smallest value in this segment

00:09:56.740 --> 00:10:01.989
from start to n minus 1, right. So, this is
the same loop we did earlier.

00:10:01.989 --> 00:10:06.420
We start with the minimum position being the
beginning of the segment and then we keep

00:10:06.420 --> 00:10:10.209
walking forwards and whenever we find a value
which is smaller than the minimum position,

00:10:10.209 --> 00:10:15.259
we update it and at the end of this loop we
exchange the position that we have found the

00:10:15.259 --> 00:10:19.300
value at that position with the starting position.
So, now, the correct value, so some value

00:10:19.300 --> 00:10:26.589
from say here has moved to the correct position
and now we recursively sort A starting at

00:10:26.589 --> 00:10:32.470
position start plus 1 up to n. So, is this
any different in complexity?

00:10:32.470 --> 00:10:39.959
So, let us write, so remember when we did
recursive calculations we said, that typically,

00:10:39.959 --> 00:10:44.290
you would write a recurrence, right. You will
express the complexity of the algorithms itself

00:10:44.290 --> 00:10:51.389
in a recursive way. So, suppose t n is the
number of steps you need to run selection

00:10:51.389 --> 00:10:57.929
sort in length n, ok. So, the first thing
is, it requires n steps in order to find the

00:10:57.929 --> 00:11:02.259
minimum and move it to the beginning and then
having moved it to the beginning the rest

00:11:02.259 --> 00:11:06.272
of the array that is left to sort is of the
size of n minus 1. So, you need time recursively

00:11:06.272 --> 00:11:14.100
t n minus 1, right. So, therefore, you have
t n. So, this is the time to find the minimum.

00:11:14.100 --> 00:11:20.279
t n is, t n is n plus t n minus 1 which is
the recursive step.

00:11:20.279 --> 00:11:26.249
And we said, that if we are sorting an array
of size 1, we do not have to do anything,

00:11:26.249 --> 00:11:32.769
we just return. So, t of 1 is 1. So, t of
n is n plus t n minus 1. But now, if I take

00:11:32.769 --> 00:11:38.939
t n minus 1 and expand it using the same expression,
I get n minus 1 plus t n minus 2. Now, if

00:11:38.939 --> 00:11:44.399
I expand t n minus 2, I will get n minus 2
plus t n minus 3 and so on. And so this will

00:11:44.399 --> 00:11:47.920
expand out to exactly what we got for the
recursive, for iterative algorithm, namely

00:11:47.920 --> 00:11:55.569
n plus n minus 1 plus n minus 2 down to n,
right. So, what we have seen in this unit

00:11:55.569 --> 00:11:59.309
is that we have seen, that a very natural
algorithm, which we would apply if we did

00:11:59.309 --> 00:12:05.059
things by hand called selection sort can be
formalized both iteratively and recursively

00:12:05.059 --> 00:12:08.100
and it gives us a complexity, which is order
n square.

