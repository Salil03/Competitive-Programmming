WEBVTT
Kind: captions
Language: en

00:00:01.030 --> 00:00:06.519
Having looked at the longest common subword
and subsequence problem, we now look at a

00:00:06.519 --> 00:00:09.410
closely related problem called Edit Distance.

00:00:09.410 --> 00:00:16.160
So, the aim is to measure how similar two
pieces of texture, it is so called document

00:00:16.160 --> 00:00:20.770
similarity problem. So, let us look at the
following two sentences; the first sentence

00:00:20.770 --> 00:00:26.410
says the students who were able to appreciate
the concept optimal substructure property

00:00:26.410 --> 00:00:32.480
and its use in designing algorithms. The second
sentence says the lecture taught the students

00:00:32.480 --> 00:00:39.990
to appreciate how the concept of optimal substructures
can be used in designing algorithms. So, the

00:00:39.990 --> 00:00:48.020
third sentence here indicates how one might
obtain one of these two from the other.

00:00:48.020 --> 00:00:52.179
If you have used certain document preparation
systems which allow you to track changes,

00:00:52.179 --> 00:00:56.809
it will typically indicate the changes between
one version of a document and other version

00:00:56.809 --> 00:01:02.200
like this. So, here the green indicates letters
which have been, so if we called as version

00:01:02.200 --> 00:01:09.170
1 and this version 2, then in going from version
one1 to version 2, what we have done is you

00:01:09.170 --> 00:01:13.420
are introduced the letters in green. So, you
have inserted these characters, you have deleted

00:01:13.420 --> 00:01:19.159
the letters marked in red with a line through
them and in this yellow we have replace. So,

00:01:19.159 --> 00:01:27.009
we have replaced the t by v and an s by n.
So, we have 28 characters, we can count that

00:01:27.009 --> 00:01:34.979
there are 28 characters which have been inserted
including spaces and other, 18 characters

00:01:34.979 --> 00:01:40.430
have been deleted and 2 characters have been
substituted.

00:01:40.430 --> 00:01:47.509
So, now, this can be a basis of measuring
how close two documents are to each other.

00:01:47.509 --> 00:01:52.110
So, the edit distance with the minimum number
of edit operations required to transform one

00:01:52.110 --> 00:01:56.719
document to another, so we have to define
what we mean by editing operations. So, let

00:01:56.719 --> 00:02:01.170
us just start with very basic operation, either
you can insert a character or you can delete

00:02:01.170 --> 00:02:04.890
a character or you can replace one character
by another one in one step.

00:02:04.890 --> 00:02:08.880
So, replacing of course could be a think taught
of us deleting and inserting, so that could

00:02:08.880 --> 00:02:12.599
be a two step operations, I delete the character
and then I insert the character I want. But,

00:02:12.599 --> 00:02:20.080
I am going to allow changing one letter a
by b or s by t as a single operation. So,

00:02:20.080 --> 00:02:24.680
in our example we claimed that 28 characters
were inserted, 18 were deleted and 2 were

00:02:24.680 --> 00:02:27.620
substituted. So, the total number of changes
we made is 48.

00:02:27.620 --> 00:02:32.470
If the edit distance is suppose be the minimum
number of changes, it cannot be more then

00:02:32.470 --> 00:02:36.700
48, because they already shown that it is
possible to do in 48 characters, possible

00:02:36.700 --> 00:02:41.190
to do it in more clever way less than 48.
So, the edit distance is at most 48 for the

00:02:41.190 --> 00:02:45.030
two sentence that we shown earlier.

00:02:45.030 --> 00:02:50.670
So, this distance is also called the Levenshtein
distance, because it was first proposed by

00:02:50.670 --> 00:02:57.870
the Soviet, now Russian scientist called Vladimir
Levenshtein and this like the longest common

00:02:57.870 --> 00:03:02.780
subsequence problem, it is extremely useful
in practice. So, the first thing is to suggest

00:03:02.780 --> 00:03:07.350
spelling corrections. Now, if somebody types
something that is a wrong, then it is spelling

00:03:07.350 --> 00:03:11.930
corrective will have to suggest the correct
word from the dictionary to replace it. So,

00:03:11.930 --> 00:03:13.950
which word should the spelling corrective
choose?

00:03:13.950 --> 00:03:19.390
So, one criterion for choosing is to identify
among all the words in the dictionary that

00:03:19.390 --> 00:03:26.000
are possible which one is closest to the one
that has been typed. So, this can be measured

00:03:26.000 --> 00:03:31.080
in terms of this edit distance and then that
menu will pop up saying did you mean to type

00:03:31.080 --> 00:03:35.189
this. This also happens when you type queries
in search engines. So, if you type something

00:03:35.189 --> 00:03:39.860
to Google, Google will sometimes change your
query to a word which is meaningful, because

00:03:39.860 --> 00:03:44.930
it recognizes that you mistyped a name or
a concept.

00:03:44.930 --> 00:03:51.390
We also said that the longest common subsequence
problem that we saw earlier is useful in Genetics,

00:03:51.390 --> 00:03:55.519
in Bioinformatics and in the same way edit
distance also, if you want to compare the

00:03:55.519 --> 00:04:00.209
genetic information in two different species,
then it is natural to become to compare them

00:04:00.209 --> 00:04:05.170
in terms of the content of the DNA and DNA
are just long strips. So, you want to find

00:04:05.170 --> 00:04:10.629
out how easy or difficult it is to transform
one piece of DNA to another and depending

00:04:10.629 --> 00:04:17.940
on that we can tell whether two species are
closed to each other or not.

00:04:17.940 --> 00:04:24.300
So, if you go back to the longest common subsequence
problem, so one way of thinking of longest

00:04:24.300 --> 00:04:30.020
common subsequence is supposing I just delete
all the parts which are not part of the LCS,

00:04:30.020 --> 00:04:40.840
so I had things like bisect and secret. So,
now, in this if I deleted the b and i from

00:04:40.840 --> 00:04:47.830
here and the r and e from here, then I am
left with exactly the longest common subsequence.

00:04:47.830 --> 00:04:54.210
The other way of thinking about it is let
identity, I start with one word and I am transforming

00:04:54.210 --> 00:04:59.800
it to this word, so I first delete the b and
i and then I insert here the r e.

00:04:59.800 --> 00:05:04.910
So, I do not operate on both words and delete
from both, I operate only on the first word.

00:05:04.910 --> 00:05:09.830
So, I delete the words, I delete the letters
I do not want, because I not have a second

00:05:09.830 --> 00:05:13.740
word and I insert the letter, so I do want
which are there in the second not in the first

00:05:13.740 --> 00:05:17.580
and in this way I transform the first word
to the second word and this is equivalent

00:05:17.580 --> 00:05:25.620
to deleting from both and come it to a common
subsequence. So, this tells us that LCS is

00:05:25.620 --> 00:05:32.870
somehow equivalent to computing the edit distance,
if I only allow delete and insert. So, the

00:05:32.870 --> 00:05:36.710
interesting thing about edit distance is that
it also allows a substitution of one character

00:05:36.710 --> 00:05:43.240
and other. So, it might give us a slightly
different metric from longest common subsequence.

00:05:43.240 --> 00:05:52.060
So, going back to longest common subsequence,
it says that if two letters match at the beginning

00:05:52.060 --> 00:05:57.650
of a word, then it is useful to assume that
the common subsequence includes that. So,

00:05:57.650 --> 00:06:02.069
I have this one which says that a i is equal
to b j, so I include this in my subsequence

00:06:02.069 --> 00:06:08.300
and then I solve the rest of the problem.
Otherwise, I take the max of the two sub problems

00:06:08.300 --> 00:06:11.810
that I get by dropping a i or b j.

00:06:11.810 --> 00:06:17.930
Now, in the edit distance problem we have
a similar criterion, if a i is equal to b

00:06:17.930 --> 00:06:23.620
j, then I have nothing to do. So, the edit
distance of word starting at i and j is the

00:06:23.620 --> 00:06:28.240
same as the edit distance starting at i plus
1 j plus 1. Recall that we are now doing the

00:06:28.240 --> 00:06:32.789
opposite of longest common subsequence, we
are now trying to minimize the number of changes

00:06:32.789 --> 00:06:37.090
in order to maximize the number of matches.
So, if we see that something is already matched,

00:06:37.090 --> 00:06:39.729
then no changes needed, so we just move ahead
to the next position.

00:06:39.729 --> 00:06:48.090
Now, if they do not match now three things
are possible, so I have a i, a i plus 1 and

00:06:48.090 --> 00:06:54.629
so on and I have b j, b j plus 1 and so on.
So, in the first thing I can do is I can directly

00:06:54.629 --> 00:07:00.740
make this into b j, in which case I have now
made the first letters exactly equal and so

00:07:00.740 --> 00:07:08.430
I just need to look at i plus 1 j plus 1.
The other thing which I can do is to remove

00:07:08.430 --> 00:07:16.780
this a i all together, I just remove this
a i. So, now, this disturbance is gone, but

00:07:16.780 --> 00:07:22.810
I am still left to the rest to the problem,
so now, I have to now see if i plus 1 onwards

00:07:22.810 --> 00:07:28.560
matches j onwards.
And finally, the last thing which I could

00:07:28.560 --> 00:07:39.759
have done is to introduce that this b j at
the beginning, so now, this means that these

00:07:39.759 --> 00:07:46.740
two things now match up. So, now, I have to
look at a i onwards and b j plus 1 onwards

00:07:46.740 --> 00:07:50.800
and whichever of these three requires the
minimum work overall is the one i want. So,

00:07:50.800 --> 00:07:56.259
I want to take 1 plus in the solution i plus
1 j plus 1 or 1 plus solution i plus 1 j or

00:07:56.259 --> 00:08:00.220
1 plus solution for i j plus 1 and take the
minimum of these three.

00:08:00.220 --> 00:08:08.190
So, this gives us the final inductive structure
that we want. So, ED the Edit Distance for

00:08:08.190 --> 00:08:14.169
the word starting at i and j, if a i is equal
to b j it is ED of i plus 1 j plus 1. If it

00:08:14.169 --> 00:08:21.879
is not equal, then it is 1 plus the minimum
of the edit distance of these three different

00:08:21.879 --> 00:08:28.260
sub problems and as usual we extend this to
m plus 1 n plus 1, but the interpretation

00:08:28.260 --> 00:08:34.480
is now different. If one of the words is empty,
then the number of changes I need to make

00:08:34.480 --> 00:08:37.800
is to transform everything else or insert
everything from that word you use.

00:08:37.800 --> 00:08:44.590
So, if I am looking at b j, b j plus 1 to
b n and beside I have nothing, then what is

00:08:44.590 --> 00:08:47.500
the edit distance. Well, I have to basically
insert this many letters. How many letters

00:08:47.500 --> 00:08:55.500
are there? N n minus j plus 1, so the edit
distance when u is empty and v has z position

00:08:55.500 --> 00:09:02.220
j is n minus j plus 1. Likely, likewise b
is empty and u is not, it is n minus i plus

00:09:02.220 --> 00:09:06.480
1, we have to insert all those like this.
So, this is a slight difference, it is not

00:09:06.480 --> 00:09:14.590
zero, but it is the cost of using up the letters
which are there, which are missing in this

00:09:14.590 --> 00:09:15.590
word.

00:09:15.590 --> 00:09:22.920
So, the inductive substructure in edit distance
is exactly the same as in LCS. Every position

00:09:22.920 --> 00:09:30.810
depends on i plus 1 j plus 1 and the i plus
1 j and i j plus 1. So, we have the same three

00:09:30.810 --> 00:09:36.580
neighbors depended C that we had as we did
before and us usual we can start at the bottom

00:09:36.580 --> 00:09:42.210
right corner and work backwards row by row
or corner by corner. So, in this case remember

00:09:42.210 --> 00:09:47.250
that the boundary condition is not zero, but
it is n minus j plus 1, so as I go up, the

00:09:47.250 --> 00:09:52.520
number increases.
So, this is my boundary and now I can just

00:09:52.520 --> 00:09:57.540
apply my recursive thing which says that t
matches, for edit distance at t is zero, because

00:09:57.540 --> 00:10:01.840
I have nothing to do and there is nothing
to beyond them. Everywhere else, because I

00:10:01.840 --> 00:10:07.100
do not match, the edit distance is just going
to be the minimum of the remaining three.

00:10:07.100 --> 00:10:14.170
So, it is minimum to the remaining three plus
1, so in this case if I pick, look at this

00:10:14.170 --> 00:10:19.340
for example, the minimum of 0, 1 and 2 is
0 plus 1 is 1.

00:10:19.340 --> 00:10:25.500
The minimum of 4, 2 and 3 is 2, plus 1 is
3 and so on, so it is the minimum of those

00:10:25.500 --> 00:10:32.310
plus 1 to make the current. So, I keep doing
this and I go left, eventually I will find

00:10:32.310 --> 00:10:40.040
that the minimum edit distance between bisect
and secret is actually 4, I need to make four

00:10:40.040 --> 00:10:45.920
changes, just using the inductive definition
that we have done earlier. And as before now

00:10:45.920 --> 00:10:50.230
the question is how do I recover the solution
from this, so I follow the path. So, why did

00:10:50.230 --> 00:10:54.010
I get a 4 there, because it is the minimum
of it is three neighbours and b is not equal

00:10:54.010 --> 00:10:57.360
to s. What is the minimum of these three?
It is 3, so I went back.

00:10:57.360 --> 00:11:00.990
Similarly, why is this 3 here, because this
is the minimum of these, so I went down. So,

00:11:00.990 --> 00:11:12.020
every time I go down, it amounts to saying
that I go from i j to i plus 1 j and if you

00:11:12.020 --> 00:11:17.130
remember in our case, i plus 1 j and i i is
corresponding to deleting. Similarly, at this

00:11:17.130 --> 00:11:23.850
place I go a right. This means I go from i
j, i j plus 1, this corresponds to inserting.

00:11:23.850 --> 00:11:28.340
So, what I can read of from here is that when
I am going to delete this v, I delete this

00:11:28.340 --> 00:11:34.570
i, then I come here, I insert this r and I
insert this e. And these are exactly the four

00:11:34.570 --> 00:11:40.040
changes that I need to make in order to transform
bisect into secret.

00:11:40.040 --> 00:11:47.120
So, the pseudo code for every distance is
very similar to the longest common subsequence.

00:11:47.120 --> 00:11:54.470
The only major change done is in the initialization,
the values at the boundary are not zero, but

00:11:54.470 --> 00:11:59.870
whatever is required to complete the editing.
Then, as usual I start at the bottom right

00:11:59.870 --> 00:12:07.230
end and I do columns in right to left rows
from bottom to top, if the current value if

00:12:07.230 --> 00:12:13.210
the two values that I am looking at u of r
and v of c are the same, then I just postponed

00:12:13.210 --> 00:12:16.640
the edit distance to the next thing, I have
nothing to do here. Otherwise, I take the

00:12:16.640 --> 00:12:19.580
minimum of the subproblems and add 1 for the
current changes and finally, I have returned

00:12:19.580 --> 00:12:26.560
the value 0 and 0.

00:12:26.560 --> 00:12:30.800
The complexity is order m times n, it is exactly
the same as the previous one, because after

00:12:30.800 --> 00:12:36.210
we fill up this table of size m times n and
it takes a constant time to compute. Now,

00:12:36.210 --> 00:12:40.050
in all these three problems there is another
issue which we have not addressed. So, let

00:12:40.050 --> 00:12:41.580
us deal with it now.

00:12:41.580 --> 00:12:46.450
So, this is a space complexity. So, we have
this table that we have to compute which we

00:12:46.450 --> 00:12:54.540
have a green is m times n, but notice that
the way we computed it for example, was to

00:12:54.540 --> 00:13:00.050
compute this column, then this column, then
this column and so on. So, at any given point,

00:13:00.050 --> 00:13:03.250
when I am computing this second column for
example, I only read the first column. When

00:13:03.250 --> 00:13:08.220
I need the third column, this column is now
not needed anymore, because the third column

00:13:08.220 --> 00:13:11.040
depends only on the second column from the
right.

00:13:11.040 --> 00:13:14.790
So, if I need, if I fill column by column
I only need the next column, the column on

00:13:14.790 --> 00:13:20.550
my right and the current column or if I need
row by row, the next row and the current row.

00:13:20.550 --> 00:13:25.190
So, in other words while Iâ€™m just keeping
two columns or two rows, I can completely

00:13:25.190 --> 00:13:31.110
compute this thing back to 0 0. So, therefore,
there was actually no need to rule m times

00:13:31.110 --> 00:13:37.310
n size table as storage. I still have to compute
n times, but the time complexity remains m

00:13:37.310 --> 00:13:45.160
times n. So, time is m times n what we are
saying is that this space can be reduced if,

00:13:45.160 --> 00:13:51.470
let us say that n is the smaller of the two,
this space can be reduced topper n by just

00:13:51.470 --> 00:13:55.440
keeping two columns.
And now you might ask how do I recover the

00:13:55.440 --> 00:13:59.441
solution, because in the solution I trace
back the path on the whole thing, well you

00:13:59.441 --> 00:14:04.390
can actually keep track incrementally as you
are going, you can build up the solution associated

00:14:04.390 --> 00:14:09.660
to each entry incrementally, so even that
can be done in order n space. So, you do not

00:14:09.660 --> 00:14:15.520
need this table at all even to compute back
the witness for the given numerical solution.

00:14:15.520 --> 00:14:21.200
So, in all these problems where we have a
very limited neighborhood dependency in our

00:14:21.200 --> 00:14:27.930
dynamic programming, you can actually often
make do with much less space, than it seems

00:14:27.930 --> 00:14:30.529
to require in terms of the actual table as
given to you.

