WEBVTT
Kind: captions
Language: en

00:00:01.050 --> 00:00:06.670
For our last example of dynamic programming
to this week, now we look at the problem of

00:00:06.670 --> 00:00:10.890
the efficiently multiplying the sequence of
matrices.

00:00:10.890 --> 00:00:17.919
So, as you probably know to multiply two matrices
A and B, we need compatible dimensions, so

00:00:17.919 --> 00:00:26.679
if we have A and B, then we need that the
number of columns in A must match the number

00:00:26.679 --> 00:00:35.290
of rows in B. So, we have m times n matrix
A and an n times p matrix B and the final

00:00:35.290 --> 00:00:39.570
matrix is going to be your times m times p,
that the same number of rows as A must have

00:00:39.570 --> 00:00:45.079
same number of columns as B. And the way you
compute that product A B, so if I want the

00:00:45.079 --> 00:00:51.870
i j th entry in A B, then I will take the
i th row in A and I’ll somehow multiply

00:00:51.870 --> 00:00:57.839
it with the j th column B. So, I will take
the first entry here, the first entry there,

00:00:57.839 --> 00:01:04.140
so I will take A i 1 and B 1 j, multiply them
A i 2 B 2 j multiply them, finally A i n B

00:01:04.140 --> 00:01:09.190
n j multiply add them all.
So, this takes order n steps, because I am

00:01:09.190 --> 00:01:14.970
computing order n pairwise products and then
adding them all. So, therefore, I have to

00:01:14.970 --> 00:01:21.580
compute finally m times p entries, each entry
requires a linear order n amount work. So,

00:01:21.580 --> 00:01:26.780
the total cost of multiplying two matrices
in terms of basic arithmetic operations is

00:01:26.780 --> 00:01:33.890
of the order of m times n times p. So, this
is the basic fact that we need for the problem.

00:01:33.890 --> 00:01:40.020
So, now the concern is not computing the product
of two matrices but computing the product

00:01:40.020 --> 00:01:45.330
of 3 or more. So, supposing I want to multiply
three matrices A, B and C, at a time I can

00:01:45.330 --> 00:01:52.010
even multiply I need 2. So, either I have
to multiply it as A times B, let an intermediate

00:01:52.010 --> 00:01:59.120
matrix A B and then multiply by C or I can
do B times C and then multiply it by A from

00:01:59.120 --> 00:02:03.500
B itself.
So, matrix multiplication is not commutative,

00:02:03.500 --> 00:02:13.420
we do not have this in general. So, it is
important that the order is the same, but

00:02:13.420 --> 00:02:19.440
within that in which sequence I do this simplification
does not matter. So, it is associative, I

00:02:19.440 --> 00:02:23.780
can bracket it by as A times B followed by
C or A times B followed by C, either way I

00:02:23.780 --> 00:02:30.090
have to do two matrix multiplications and
what associativity means is that the answer

00:02:30.090 --> 00:02:33.260
will not change, the final product would remain
the same.

00:02:33.260 --> 00:02:38.569
But, what is interesting for us, now is that
the complexity of computing the answer can

00:02:38.569 --> 00:02:43.810
change depending on which order I do it, whether
I do it as A times B followed by C or first

00:02:43.810 --> 00:02:46.580
at B times C and then might be multiply by
A.

00:02:46.580 --> 00:02:52.290
So, let us look at a very trivial example.
So, I have three matrices of this kind, so

00:02:52.290 --> 00:02:58.641
A is 1 and these are matrix which looks like
this, it has 1 row and 100 columns, B is a

00:02:58.641 --> 00:03:03.900
matrix which looks like this, it has 100 rows
and 1 column and C is again a matrix, which

00:03:03.900 --> 00:03:12.150
looks like this. So, this is my A, this is
my B and this is my C. So, now, supposing

00:03:12.150 --> 00:03:21.050
I do B times C first, if I do B times C what
happens is in this 100 will now blow up and

00:03:21.050 --> 00:03:27.430
I will get a big matrix which is 100 by 100.
Because, I have 100 rows here and 100 columns

00:03:27.430 --> 00:03:32.500
there and so the final thing is going to be
number of rows in B and number of columns

00:03:32.500 --> 00:03:37.372
in C. So, the B times C matrix is actually
100 by 100 and how many steps it will take,

00:03:37.372 --> 00:03:43.630
it takes m into n into p which is 100 into
1 into 100 which is 10,000 steps. Now, I have

00:03:43.630 --> 00:03:48.990
A which is 1 by 100 and B which is 100 by
100, so I am going to produce something which

00:03:48.990 --> 00:03:55.640
is again 100, 1 by 100 but I am going to take
1 into 100 into 100, we call m into n into

00:03:55.640 --> 00:04:01.470
p, another ten thousand.
So, together this particular sequence requires

00:04:01.470 --> 00:04:07.710
20,000 steps, if I did the other way on the
other hand, if I computed this product first,

00:04:07.710 --> 00:04:10.770
then I have collapse it to a simple 1 by 1
matrix. So, the number of rows here is 1 and

00:04:10.770 --> 00:04:15.350
the number of columns is there 1, so A B is
1 by 1 matrix and it takes only 100 steps

00:04:15.350 --> 00:04:19.930
to compute. And now, again I have a 1 by 1
times of 100 by 1 matrices, so again it takes

00:04:19.930 --> 00:04:24.699
only 100 steps, so this takes only 200 steps.
So, you can see that there can be a dramatic

00:04:24.699 --> 00:04:29.990
difference in the complexity depending on
whether you, the bracketed is A B followed

00:04:29.990 --> 00:04:34.240
by C or A followed by B C.

00:04:34.240 --> 00:04:40.610
So, in general we’ll have a sequence of
M such matrices, it is right, so M 1, M 2

00:04:40.610 --> 00:04:46.039
up to M n and their dimensions will be r 1
C 1, r 2 C 2 up to r n C n number of rows,

00:04:46.039 --> 00:04:50.889
number of columns. The dimensions will be
given to us, so that they can be multiplied.

00:04:50.889 --> 00:04:56.349
Remember that all we need, assuming the entries
of course, can be combined by sensible multiplication

00:04:56.349 --> 00:05:00.370
addition operations, what we need to be able
to multiply two matrices, is that the dimensions

00:05:00.370 --> 00:05:02.650
should match.
So, we are guaranteed that the column of each

00:05:02.650 --> 00:05:06.050
matrix, the number of columns is equal to
the number of rows in the next matrix, so

00:05:06.050 --> 00:05:12.319
that product is well defined. And our goal
is to find an optimum way to compute this

00:05:12.319 --> 00:05:17.470
product, what is the sequence of basic operations
multiplying two matrices together there we

00:05:17.470 --> 00:05:22.099
need to perform to get the minimum overall
cost. And this is equivalent to finding an

00:05:22.099 --> 00:05:26.310
optimum way of bracketing. So, remember when
I did A times B times C, the choice of whether

00:05:26.310 --> 00:05:30.620
to put the bracket like this, how to put the
bracket like this.

00:05:30.620 --> 00:05:36.809
In general, if I give you now A times B times
C times D, then you can do many things, you

00:05:36.809 --> 00:05:43.870
can do A B, C D and then multiply or you can
do C D, then B C D, then A B C D or you can

00:05:43.870 --> 00:05:49.279
do A B, then A B C, then A B C D. So, there
are many different ways in which you can partially

00:05:49.279 --> 00:05:55.030
compute pairs of product, products of pairs
and built up the whole thing. So, we want

00:05:55.030 --> 00:05:58.509
to find the optimum way to do this.

00:05:58.509 --> 00:06:07.656
So, let’s try and identify the inductive
structure in this part. So, our goal is to

00:06:07.656 --> 00:06:14.800
compute this long product M 1 to M n, but
remember that at every stage we can only multiply

00:06:14.800 --> 00:06:20.460
two matrices at a time. So, at the final stage
you would multiply two some mat, some two

00:06:20.460 --> 00:06:27.339
such matrices. Now, we can regroup by bracketing,
but we cannot reorder. So, if we did the final

00:06:27.339 --> 00:06:33.369
stage we would have had two groups, so you
would have done some product from the left

00:06:33.369 --> 00:06:36.699
to the midpoint and some product from the
midpoint to the end.

00:06:36.699 --> 00:06:45.610
So, for some k we would have computed M 1
to M k and M k plus 1 to M n. In the first

00:06:45.610 --> 00:06:49.629
part after doing all this, we will have as
many rows as M 1 and as many columns as M

00:06:49.629 --> 00:07:01.210
k, so it will be r 1 times C k. Second one
will be r k plus 1 to C n and we know that

00:07:01.210 --> 00:07:06.169
C k is going to be equal to r k plus 1, so
that these two kindly multiplied together.

00:07:06.169 --> 00:07:12.770
So, the final cost is going to be m into n
into p which is r 1 into C k into C n, so

00:07:12.770 --> 00:07:18.069
we know how much the last step takes.
Assuming that it was broken at M k, the last

00:07:18.069 --> 00:07:23.910
multiplication causes this much. Now, to get
the total cost of doing it with this particular

00:07:23.910 --> 00:07:31.599
choice of k, we have to get the cost of computing
M 1 to M k and M k plus 1 to M n.

00:07:31.599 --> 00:07:38.659
So, we have this final situation and now we
have these two sub problems, so we have this

00:07:38.659 --> 00:07:42.849
two sub problems and the total cost is going
to be the cost of the first sub problem. However,

00:07:42.849 --> 00:07:48.159
it much takes to compute M 1 to M k; however,
much it takes to compute M k plus 1 to M n

00:07:48.159 --> 00:07:52.249
plus the cost of the last step which is to
multiply these two sub problems after that

00:07:52.249 --> 00:07:56.990
produce one matrix each to multiply those
two matrices together. But, we have said that

00:07:56.990 --> 00:08:03.149
this k could be anywhere between 1 and n,
so which k should we choose.

00:08:03.149 --> 00:08:07.229
So, the spirit of these kind of problems that
we have been seen this inductive things is

00:08:07.229 --> 00:08:13.809
that we do not try to make the choice. We
say we have no idea in advance which k is

00:08:13.809 --> 00:08:18.499
good, so we just try out all possible case
and take the best one, in this case the minimum

00:08:18.499 --> 00:08:19.499
value.

00:08:19.499 --> 00:08:27.149
In other words, the cost for multiplying M
1 to M n in terms of total number of operations

00:08:27.149 --> 00:08:33.589
should be the minimum value of k between 1
and n, it has to be strictly less than n,

00:08:33.589 --> 00:08:40.270
because the second part will be n k plus 1.
So, between 1 and n or multiplying the matrices

00:08:40.270 --> 00:08:47.410
1 to k, multiplying the matrix k plus 1 to
n and adding the cost of the last multiplication.

00:08:47.410 --> 00:08:55.200
So, now in turn if I look at this for example,
in a break it out, it could break up at some

00:08:55.200 --> 00:09:04.019
intermediate point M j. So, I will add some
M j plus 1 to M k, so I would get arbitrary

00:09:04.019 --> 00:09:07.250
segments from 1 to n as my sub problems.

00:09:07.250 --> 00:09:14.829
So, a natural thing is to define the inductive
structure on an arbitrary segment from M i

00:09:14.829 --> 00:09:22.540
to M j where of course, i is less than j.
So, we want the minimum value for any k in

00:09:22.540 --> 00:09:29.550
the middle, k between i and j or going for
M i to M k and then from M k plus 1 to M j

00:09:29.550 --> 00:09:35.620
and the cost of the last multiplication which
is r 1 into C k into C j. So, as before we

00:09:35.620 --> 00:09:40.790
will just use the index, so instead of writing
cost of M 1, cost of M 2, then whatever we

00:09:40.790 --> 00:09:48.300
will write i j, cost of i j is the cost of
multiplying M i to M j in that whole sequence.

00:09:48.300 --> 00:09:52.910
So, let us look at the final inductive form
of the equation that we need to compute. So,

00:09:52.910 --> 00:09:56.790
the base case is when we are looking at a
sequence of length 1, so if you are computing

00:09:56.790 --> 00:10:04.069
for example, M 1, M 2, M 3, M 4, then one
possibility that are break it up as M 1 times

00:10:04.069 --> 00:10:08.740
M 2, M 3, M 4. Now, if I am doing this break
up then the cost of doing M 1 is nothing,

00:10:08.740 --> 00:10:12.899
because if I am computing from 1 to 1, I am
doing no multiplication. So, the cost of i

00:10:12.899 --> 00:10:18.759
i is 0 and then otherwise I use the recursive
formulation we had before.

00:10:18.759 --> 00:10:24.860
We take the minimum value for k ranging form
i, but not rather strictly less than j of

00:10:24.860 --> 00:10:34.091
the cost of i to k, cost k plus 1 to j and
r i times C k and C j. And of course, we will

00:10:34.091 --> 00:10:38.426
only compute this when i is less than equal
to j, we will never be able to, we will never

00:10:38.426 --> 00:10:43.810
want to compute it when the index j is smaller
than i. Now, it is instructed to check what

00:10:43.810 --> 00:10:50.649
happens when I do something like cost i i
plus 1. So, what this will says that I want

00:10:50.649 --> 00:10:59.220
to take M i M i plus 1, now my only possible
value for k, so k should be between i and

00:10:59.220 --> 00:11:02.610
strictly less than i plus 1.
So, that means the only possible value for

00:11:02.610 --> 00:11:09.600
k is i, so this will break up this thing as
M i to M i and M i plus 1 to M i plus 1 and

00:11:09.600 --> 00:11:14.009
then inductively those will give me cost 0
and then I will only get the cost of multiplying

00:11:14.009 --> 00:11:20.000
this pair which will exactly come out of this
pair. So, there is no problem with this base

00:11:20.000 --> 00:11:26.649
case, we only need the base case when the
two indices are exactly equal.

00:11:26.649 --> 00:11:40.779
So, now, as before we will have this matrix
to fill up, because we have this is not used,

00:11:40.779 --> 00:11:47.600
because we require, so i is going this way.
So, we have the first index going this way

00:11:47.600 --> 00:11:52.810
and the second index going that way, so we
basically never need to look at values where

00:11:52.810 --> 00:11:57.180
the ending point is before the starting point,
so we only need to lookup half of the time.

00:11:57.180 --> 00:12:04.160
And now if you are trying to compute the position
i j, then we will need cost i k, that is in

00:12:04.160 --> 00:12:11.379
this row we will need values between for smaller
values than j and we will need values of the

00:12:11.379 --> 00:12:16.899
form j k, k j in other in this column.
So, we will need the values below and to the

00:12:16.899 --> 00:12:26.759
left which is spectral diagonal, so one way
of doing this is to fill up this way, so that

00:12:26.759 --> 00:12:30.600
wherever we fill up, we have the values below
already and we also have the other values

00:12:30.600 --> 00:12:34.899
here left. So, we will fill up this matrix
from bottom top, we can also fill it up by

00:12:34.899 --> 00:12:39.260
diagonal, but it is very painful to program
it. So, it is better to do it either row by

00:12:39.260 --> 00:12:42.100
row or column, so you can also start like
this way, you could also do in this way.

00:12:42.100 --> 00:12:47.230
Since that wherever you start, you have the
values below and you get that, so you start

00:12:47.230 --> 00:12:51.790
in the diagonal and work right or up. So,
either you start at the top left and work

00:12:51.790 --> 00:12:55.286
down the diagonal and each diagonal, each
column we do bottom to top. Now, you start

00:12:55.286 --> 00:12:59.550
in the bottom right and work up the diagonal
and each row you do left to right, so either

00:12:59.550 --> 00:13:00.830
these would done.

00:13:00.830 --> 00:13:11.171
So, here is a pseudo code for that, so we
first initialize the diagonal to be 0 and

00:13:11.171 --> 00:13:15.610
now we do what we said before, we said we
start all the columns . So, this should actually

00:13:15.610 --> 00:13:22.370
be in a column. So, column 1 we do not have
to do because that is the diagonal in which

00:13:22.370 --> 00:13:30.300
we started column 2 onwards, so 2 to n. Then
for every row starting from the diagonal up

00:13:30.300 --> 00:13:36.220
to the top row, we now need to compute this
minimum. So, we initially assume that the

00:13:36.220 --> 00:13:40.230
value to be filtered is infinity, now infinity
could just need the product of all the dimensions

00:13:40.230 --> 00:13:44.089
plus 1, because you know that’s not going
to, the cost is not going to exceed that.

00:13:44.089 --> 00:13:49.379
So, you can choose a large value and what
we do is now you check for each value of k,

00:13:49.379 --> 00:13:56.951
you find that inductive thing. You look at
r to k, k plus 1 to C and then r times C k

00:13:56.951 --> 00:14:04.649
times C C. So, you lookup this particular
value which is the inductive thing and then

00:14:04.649 --> 00:14:08.410
if it is smaller than the value you have seen
so far, so this is basically computing that

00:14:08.410 --> 00:14:16.189
min over k 
by setting into infinity and then looking

00:14:16.189 --> 00:14:20.779
and updating every time. So, this is just
a direct implementation of the recursive of

00:14:20.779 --> 00:14:26.639
the inductive thing and it is just enumerating
the subproblems in a way which respects the

00:14:26.639 --> 00:14:30.329
dependency as we have seen before.

00:14:30.329 --> 00:14:35.730
So, one interesting thing to notice that we
are filling up an order n square table, now

00:14:35.730 --> 00:14:39.689
when we looked at longest common subsequence
or edit distance, we said that the complexity

00:14:39.689 --> 00:14:44.810
of the problem time wise was exactly the complexity
of the size of the table. We had an M times

00:14:44.810 --> 00:14:50.220
M table it takes M times M time to fill it
up, because in those two problems we were

00:14:50.220 --> 00:14:53.060
filling up each entry looking at exactly three
neighbors.

00:14:53.060 --> 00:14:59.319
So, we had a constant look up, now here what
happens is that when I am above the diagonal

00:14:59.319 --> 00:15:04.439
at some distance in order to fill this entry,
I need to scan this row and this column. So,

00:15:04.439 --> 00:15:10.209
the amount of time it takes to fill one entry
in my matrix could be linear. In the extreme

00:15:10.209 --> 00:15:14.959
case when I am very powerful in the diagonal,
I could be spending order n time to fill that

00:15:14.959 --> 00:15:21.750
entry. So, each intermediate value of the
matrix could require looking at n intermediate,

00:15:21.750 --> 00:15:25.319
each value each position could require looking
at n intermediate value.

00:15:25.319 --> 00:15:30.509
So, though this table is of size n square,
the actual complexity of filling the table

00:15:30.509 --> 00:15:37.509
is of size n cube that is why this is an interesting
problem, because it says that you cannot directly

00:15:37.509 --> 00:15:43.279
conclude the complexity of a dynamic programming
algorithm from the size of the table that

00:15:43.279 --> 00:15:47.639
we are trying to update. Because it also depends
on the amount to the effort you have to take

00:15:47.639 --> 00:15:49.249
to update each entry in the table.

