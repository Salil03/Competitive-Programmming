WEBVTT
Kind: captions
Language: en

00:00:00.550 --> 00:00:06.860
So, in this unit we are going to look at searching
and sorting for a value in a list of values.

00:00:06.860 --> 00:00:11.460
So, let us review how lists of values are
actually stored in a computer.

00:00:11.460 --> 00:00:17.150
So, there are two basic ways of storing a
sequence as you know arrays and lists.

00:00:17.150 --> 00:00:21.999
Now, functionally they may looks similar,
but from a complexity theory point of view,

00:00:21.999 --> 00:00:25.739
from an efficiency point of view, how the
data is organized makes a difference.

00:00:25.739 --> 00:00:29.480
So, let us just review some basics ideas about
arrays and lists.

00:00:29.480 --> 00:00:32.810
So, an array to begin with is a single block
of memory.

00:00:32.810 --> 00:00:39.690
So, if you have an array, should think of
it as something which has consecutive elements

00:00:39.690 --> 00:00:41.129
storing the values in the array.

00:00:41.129 --> 00:00:48.750
So, if you have an array A of size n, then
A 0 is immediately followed by A 1 and so

00:00:48.750 --> 00:00:51.120
on until A n minus 1.

00:00:51.120 --> 00:00:56.989
So, the crucial fact now is that if I know
where the array starts, then if I want to

00:00:56.989 --> 00:01:04.110
get to some value A i, then I just have to
multiply by i, the size of each unit of array

00:01:04.110 --> 00:01:06.260
to find out exactly where A i is.

00:01:06.260 --> 00:01:12.680
So, this amounts to saying that we can access
any value A i, any position i in the array

00:01:12.680 --> 00:01:16.390
in constant time regardless of whether i is
the beginning or at the end because we just

00:01:16.390 --> 00:01:18.320
have to compute the offset.

00:01:18.320 --> 00:01:24.030
So, we have the starting position and then
given i, we can compute directly in one shot

00:01:24.030 --> 00:01:28.430
just doing arithmetic with respect to the
starting address, the position of A i.

00:01:28.430 --> 00:01:34.280
Now, on the other hand, if I want to insert
an element between A i and A i plus 1, this

00:01:34.280 --> 00:01:39.030
becomes a bit complicated that because, supposing
I now want to push a value here; that means,

00:01:39.030 --> 00:01:44.510
I have to take these values and move them
down,; that means, each of these value has

00:01:44.510 --> 00:01:46.250
to be shifted by 1.

00:01:46.250 --> 00:01:50.480
Therefore, the time taken to insert an element
depends on the position, but in the worst

00:01:50.480 --> 00:01:52.840
case I might have to shift all the elements
by 1.

00:01:52.840 --> 00:01:55.620
So, this could take time proportional to the
size of the array.

00:01:55.620 --> 00:01:58.460
So, this could be a order n operations.

00:01:58.460 --> 00:02:03.570
The same way contraction can require me to
take an array and then if I want to remove

00:02:03.570 --> 00:02:07.450
this element, then I have to shift all of
these elements up by 1.

00:02:07.450 --> 00:02:12.510
So, if I want to expand or contract an array,
it is an expensive operation, but I can access

00:02:12.510 --> 00:02:17.511
any given element in an array in a fixed cost
time which is independent of the position.

00:02:17.511 --> 00:02:21.450
And I can just treat it as like any other
access, like accessing a variable x or y or

00:02:21.450 --> 00:02:25.310
anything else simple in my program.

00:02:25.310 --> 00:02:30.730
A list on the other hand is generally a flexible
structure and as elements are added, they

00:02:30.730 --> 00:02:35.230
gets scattered around the memory with no fixed
relationship to each other.

00:02:35.230 --> 00:02:41.520
So, typically a list will have values in different
parts of the memory and the idea is that each

00:02:41.520 --> 00:02:42.520
value will points to the next.

00:02:42.520 --> 00:02:47.180
So, supposing this is the beginning of the
list, then this will point to the next element,

00:02:47.180 --> 00:02:51.321
this will point to the third element, this
will point to the fourth element and so on.

00:02:51.321 --> 00:02:57.680
So, because of this linking structure usually
in most introductory data structures courses,

00:02:57.680 --> 00:03:00.319
lists are often referred to as linked list.

00:03:00.319 --> 00:03:04.819
So, linked list is just a concrete way of
implementing such a flexible structure.

00:03:04.819 --> 00:03:11.380
So, now what this means is that, if I want
to find where say l 2 is so, let us assume

00:03:11.380 --> 00:03:15.520
that this is l 0, l 1 and l 2.

00:03:15.520 --> 00:03:20.840
Then, I have no idea in general, where l 2
is located, but I know where l 0 is located,

00:03:20.840 --> 00:03:23.930
because my list name in my program l will
point to l 0.

00:03:23.930 --> 00:03:28.340
So, I will have to follow these arrows until
I reach l 2.

00:03:28.340 --> 00:03:35.890
So, in general if I want to go to A i, I have
to start at A 0, then follow my link to A

00:03:35.890 --> 00:03:36.890
1 and so, on.

00:03:36.890 --> 00:03:38.210
So, this will take me i steps,.

00:03:38.210 --> 00:03:42.730
So, therefore, the further down in a list
I need to go, the longer it takes me.

00:03:42.730 --> 00:03:44.350
So, accessing A i is proportional to i.

00:03:44.350 --> 00:03:49.450
So, in general if I have to access the i-th
element of a list it is a linear time operation.

00:03:49.450 --> 00:03:54.290
On the other hand, inserting and deleting
is comparatively easy, if I know where I am,

00:03:54.290 --> 00:03:59.069
supposing I want to insert something between
l 2 and l 3, then what I would do is I would

00:03:59.069 --> 00:04:03.890
first construct a new node here and then I
will do what I would call plumbing.

00:04:03.890 --> 00:04:10.790
So, I will remove this link and I would instead,
insert a link from l 2 to the new node and

00:04:10.790 --> 00:04:14.730
from the new node to l 3 and I know which
links to add, because this is a node I have

00:04:14.730 --> 00:04:15.730
just created.

00:04:15.730 --> 00:04:17.769
So, I know its location and l 2 points to
l 3.

00:04:17.769 --> 00:04:23.409
So, I can transfer that information to the
new node so, that these links can be established.

00:04:23.409 --> 00:04:26.629
And a similar thing happens when I want to
delete a node, if I want to delete this node

00:04:26.629 --> 00:04:33.439
for example, then what I have to do is, I
just take this link and I bypass it and go

00:04:33.439 --> 00:04:34.439
directly.

00:04:34.439 --> 00:04:37.999
So, by just shuffling these links around,
in a local sense in a constant amount of time,

00:04:37.999 --> 00:04:41.610
we can insert or delete at any point in a
list.

00:04:41.610 --> 00:04:45.599
But, finding the position requires me to start
at the beginning and go the end, which takes

00:04:45.599 --> 00:04:46.770
linear time.

00:04:46.770 --> 00:04:50.340
So, this distinction has an impact on what
we can do.

00:04:50.340 --> 00:04:56.449
Suppose, we want to take a sequence of values
and we want to take a value at position i

00:04:56.449 --> 00:04:58.949
and position j and I want to exchange them.

00:04:58.949 --> 00:05:05.509
So, if I know the positions i and j, in an
array I can easily get to A i and A j in constant

00:05:05.509 --> 00:05:06.509
time and exchange them.

00:05:06.509 --> 00:05:12.240
So, this is exactly like swapping x and y
and no difference in swapping x and y, and

00:05:12.240 --> 00:05:13.419
swapping A i and A j.

00:05:13.419 --> 00:05:17.960
But, if it is a list, then I have to walk
down to find this, then I have to walk down

00:05:17.960 --> 00:05:18.979
to find that.

00:05:18.979 --> 00:05:20.809
So, I have find these two things and then
I have to exchange.

00:05:20.809 --> 00:05:26.100
So, it will take me a linear time just to
locate the positions to exchange.

00:05:26.100 --> 00:05:29.800
On the other hand, as we have already seen,
if you wanted to delete an element from the

00:05:29.800 --> 00:05:34.999
middle of a list or we want to insert an element
into a list, this takes constant time, provided

00:05:34.999 --> 00:05:36.599
we are already at A i.

00:05:36.599 --> 00:05:41.830
So, if we reach A i and we find at this position
you want to do something we can do that operation,

00:05:41.830 --> 00:05:43.840
insertion or deletion in constant time.

00:05:43.840 --> 00:05:48.349
But, at that position, if you want to insert
a value or contract the array, then we have

00:05:48.349 --> 00:05:55.089
to shift a whole number of elements forwards
or backwards and this will take linear time.

00:05:55.089 --> 00:06:01.059
So, sometimes this impacts what we can do,
and algorithms that work well on one data

00:06:01.059 --> 00:06:04.409
structure will not work in the other, though
they are abstractly representing the same

00:06:04.409 --> 00:06:09.069
thing, a sequence of values from one to n
or 0 to n minus 1.

00:06:09.069 --> 00:06:12.650
As an example of this, we will see soon binary
search.

00:06:12.650 --> 00:06:17.409
Binary search works on arrays, but does not
work on list, because it requires us to repeatedly

00:06:17.409 --> 00:06:20.319
probe the array at some index i in an efficient
way.

