WEBVTT
Kind: captions
Language: en

00:00:01.599 --> 00:00:06.259
So in the last lecture of this course, we
will look at this celebrated question about

00:00:06.259 --> 00:00:12.119
P and NP, which is often mentioned as one
of the last and most important open problems

00:00:12.119 --> 00:00:14.490
in Computer Science.

00:00:14.490 --> 00:00:21.170
So, we have seen that a checking algorithm
is something which allows us to verify whether

00:00:21.170 --> 00:00:26.090
or not a given problemÕs solution is valid.
So, a checking algorithm does not necessarily

00:00:26.090 --> 00:00:32.050
solve the problem itself, but what it can
do is take an input to the problem, a potential

00:00:32.050 --> 00:00:37.710
solution to that problem, and validate whether
or not that solution is indeed one. So, without

00:00:37.710 --> 00:00:41.850
having to solve the problem itself, it can
just check with a given solution is a valid

00:00:41.850 --> 00:00:44.519
solution or not.

00:00:44.519 --> 00:00:51.269
So, the class NP is a class of problems for
which such checking algorithms exist with

00:00:51.269 --> 00:00:58.660
the additional constraint that the check runs
in polynomial time in the size of the input.

00:00:58.660 --> 00:01:03.960
So, the checking should be efficient, so in
all the problems, we have seen in the last

00:01:03.960 --> 00:01:10.631
lecture, this is in fact true. Factorization
is in NP, because given two factors; we can

00:01:10.631 --> 00:01:14.740
multiply them efficiently to get the answer,
if we want and check.

00:01:14.740 --> 00:01:18.930
Satisfiability, again, because we just have
to take the assignment of true, false to the

00:01:18.930 --> 00:01:23.970
formula variables and verify, whether the
formula evaluates to true after that. Again,

00:01:23.970 --> 00:01:30.729
traveling salesman with the bounded version,
we can take a set of a given path, check it

00:01:30.729 --> 00:01:34.909
is a simple cycle, add up the weights and
verify that the bound is satisfied, likewise

00:01:34.909 --> 00:01:39.280
vertex cover and independent set. So, these
are all in NP, because the solution can be

00:01:39.280 --> 00:01:44.240
validated efficiently with respect to the
input size.

00:01:44.240 --> 00:01:49.460
One thing to note is that in problems like
traveling salesman, vertex cover and independent

00:01:49.460 --> 00:01:55.619
set, we took an optimization problem and converted
it into a bounded checking problem. But we

00:01:55.619 --> 00:02:01.560
also say that the bound could then be exercised
using binary search in order to find the actual

00:02:01.560 --> 00:02:06.869
answer, so this binary search has the logarithmic
factor. So, overall in some sense there is

00:02:06.869 --> 00:02:11.520
no loss of generality, because you take a
polynomial times step, and then you multiplied

00:02:11.520 --> 00:02:13.980
by logarithmic thing, so everything is still
the same.

00:02:13.980 --> 00:02:18.170
So, there is no difference journey between
the pure checking problems like satisfiability

00:02:18.170 --> 00:02:22.270
and the modified checking problems which involve
introducing a bound, a traveling salesman

00:02:22.270 --> 00:02:24.170
or vertex cover.

00:02:24.170 --> 00:02:32.240
So, why is this class called NP, so NP comes
from the word non deterministic polynomial

00:02:32.240 --> 00:02:40.190
time, so this is a historical reference. So,
it refers to the fact that these correspond

00:02:40.190 --> 00:02:45.300
to problems where you can non deterministically
guess the solution, you can magically produce

00:02:45.300 --> 00:02:51.954
the solution and then in polynomial time,
you can verify whether the solution is correct

00:02:51.954 --> 00:02:54.240
or not.
So, the actual origin of this term comes from

00:02:54.240 --> 00:02:58.720
computability theory, from theory of non deterministic
turing machines. So, if we have studied that,

00:02:58.720 --> 00:03:03.190
then you will know, why it is called NP, but
if you are not studied that, it is not so

00:03:03.190 --> 00:03:09.941
important us to realize, what it implies for
algorithms. So, NP comes from non deterministic

00:03:09.941 --> 00:03:14.590
polynomial time, which in terms comes from
turing machines.

00:03:14.590 --> 00:03:20.390
So, the two classes that people talk about
a P and NP. So, we have just seen what NP

00:03:20.390 --> 00:03:24.870
is, so what is P? So, P is just the class
of problems which we have been trying to explore

00:03:24.870 --> 00:03:29.900
in this course. These are problems for which
you have a worst case algorithm which runs

00:03:29.900 --> 00:03:34.070
in polynomial time. So, recall that we said
right at the beginning that we are looking

00:03:34.070 --> 00:03:37.760
at problems of the form N squared, N cubed
then all that, we probably looking at even

00:03:37.760 --> 00:03:41.710
less in terms of practical things or things
like N log N, but we certainly do not want

00:03:41.710 --> 00:03:45.590
to be a N and N factorial.
So, P is a class of all problems with regular

00:03:45.590 --> 00:03:51.851
polynomial time complexity in terms of worst
case. Now, by all definition, everything in

00:03:51.851 --> 00:03:59.700
P is also in NP, because we do not need to
get a solution to check it, because it is

00:03:59.700 --> 00:04:04.910
in P, we can actually generate the solution
ourselves. So, checking algorithm ask somebody

00:04:04.910 --> 00:04:09.681
to give us an input and a propose solution
and then validate it. A problem in P, we can

00:04:09.681 --> 00:04:13.790
actually generate the solutions, so we can
validate again and therefore, every problem

00:04:13.790 --> 00:04:18.070
in P is actually in NP.
So, the question that people want to know

00:04:18.070 --> 00:04:23.500
is whether P is equal to NP. So, it is a converse
group, is it possible that whenever I have

00:04:23.500 --> 00:04:29.200
an efficient checking algorithm, I also have
an efficient algorithm to generate a solution.

00:04:29.200 --> 00:04:33.420
So, intuitively this is does not seen to be
the case, as we observed, the teacher who

00:04:33.420 --> 00:04:38.590
was checking the factorization homework, need
not even know how to factorize, teacher only

00:04:38.590 --> 00:04:45.220
needs to know, how to multiply, so it seems
intuitively much simpler to check a solution,

00:04:45.220 --> 00:04:51.520
then to actually generate one. So, let us
see whether this intimation can be made formal.

00:04:51.520 --> 00:05:01.000
So, why do people believe that P is not equal
to NP? Well, one of the reasons is just from

00:05:01.000 --> 00:05:06.500
experience or it is empirical. So, we have
seen many natural problems, factorization,

00:05:06.500 --> 00:05:11.460
satisfiability, traveling salesman, vertex
cover, independent set, these are all in NP.

00:05:11.460 --> 00:05:16.070
We have seen that vertex cover and independent
set can be reduced to each other. Today, we

00:05:16.070 --> 00:05:20.360
will see that some other NP problems can also
be reduced each other.

00:05:20.360 --> 00:05:27.130
So, in fact, you can find that all these problem
actually are inter reducing, this means that

00:05:27.130 --> 00:05:31.990
the effectively have the same level of hardness.
Because, when things are reduced, one between

00:05:31.990 --> 00:05:36.660
one and other, either you can transport efficient
solutions or you can claim inefficients. But

00:05:36.660 --> 00:05:40.490
effectively there all of the same type, you
can solve one, you can solve the other in

00:05:40.490 --> 00:05:43.810
roughly the same amount of time.
So, all it takes is solve any one of these

00:05:43.810 --> 00:05:47.712
and all of these problems will then have an
efficient solution. But people have been trying

00:05:47.712 --> 00:05:51.350
these problems from different angles from
many years, now and nobodies have found one.

00:05:51.350 --> 00:05:55.960
Therefore, there is good experimental evidence
that there is no good solution for these.

00:05:55.960 --> 00:06:02.830
So, let us look at these inter reducibilityÕs
a little more closely. So, we start with Boolean

00:06:02.830 --> 00:06:08.830
satisfiability, recall that in Boolean satisfiability,
we have clauses, clauses are composed by disjunction

00:06:08.830 --> 00:06:16.970
of literals, so we take x or not y or z. So,
we have these all stunt together to form a

00:06:16.970 --> 00:06:23.889
clause, put these clauses together with an
act. So, in general, we argued that it is

00:06:23.889 --> 00:06:28.180
hard to think of how to find the satisfying
assignment, but if we get an assignment of

00:06:28.180 --> 00:06:33.450
valuation, values for the variables, we can
quickly check whether it makes true or not.

00:06:33.450 --> 00:06:39.760
So, restricted form of satisfiability is called
-SAT. In -SAT, we have only clauses like

00:06:39.760 --> 00:06:47.370
x or not y or z or we could have two also,
x or y and so on. So, we could have even trivial

00:06:47.370 --> 00:06:51.330
things like z, but remember, if we have a
clause it says that, the only way to make

00:06:51.330 --> 00:06:56.160
it, this forces mid to make z true, because
there is no option. If I add x or y, I can

00:06:56.160 --> 00:07:01.300
make x true or y true, so our clause like
this does not contribute much more problem,

00:07:01.300 --> 00:07:05.170
because it forces a valuation for a particular
variable, and then I can reduce the problem

00:07:05.170 --> 00:07:09.940
to one which has or . So, -SAT has typically
two variables or three variables, but not

00:07:09.940 --> 00:07:14.449
have more than three, it does not have four
or five variables.

00:07:14.449 --> 00:07:22.830
So, the first claim is that -SAT is as general
a SAT. So, we have show this just by a simple

00:07:22.830 --> 00:07:27.970
example. So, supposing I have a given clause,
which has five variables like this. So, what

00:07:27.970 --> 00:07:34.090
I want to do is, I want to have only three
variables, so what I will do, slice of this

00:07:34.090 --> 00:07:37.660
part. So, I will keep the first two and I
slice of this part, so I will introduce a

00:07:37.660 --> 00:07:43.880
new variable a and I will say it is v or not
w or a and I put a not with rest.

00:07:43.880 --> 00:07:54.139
So, now what is this tell me, so this tells
me that supposing in this case, that these

00:07:54.139 --> 00:08:03.670
are both false. Then, in order to make this
true and must make a true, but a is true,

00:08:03.670 --> 00:08:10.110
then this is false on the other side, so that
means that this clauses is true, one of these

00:08:10.110 --> 00:08:14.880
has true. So, in other words, it is saying
both a v and w, not w are false, then one

00:08:14.880 --> 00:08:18.040
of the other three variables must be true,
which is exactly what the original problem;

00:08:18.040 --> 00:08:25.420
one of these five must be true. On the other
hand, if v or not w is true, then I can effort

00:08:25.420 --> 00:08:30.600
to set a false, if a is false not even become
true, then I am no application of the remaining

00:08:30.600 --> 00:08:31.600
variables.

00:08:31.600 --> 00:08:39.349
So, the claim is that by this expansion by
removing by this one, splitting away the first

00:08:39.349 --> 00:08:43.539
two variables and adding this in intermediate
thing linking the two clauses at produce two

00:08:43.539 --> 00:08:54.220
clauses, which have same satisfiability as
the original clause. Now, again I have unfortunately

00:08:54.220 --> 00:08:58.379
too many variables here, so what I will do
is, I will now again keep two and split the

00:08:58.379 --> 00:09:03.339
response.
So, I will keep not a x a little new variable

00:09:03.339 --> 00:09:09.860
b, and then I will take not b and take remaining
b, at this point, fortunately I now reduce

00:09:09.860 --> 00:09:12.360
everything into three variables, I can stop
it, if I have four variable still, I have

00:09:12.360 --> 00:09:17.740
do same thing a little c and not c and so
on. So, in this way, I can take any clause

00:09:17.740 --> 00:09:24.240
which has more than three literals and systematically
decompose it by adding new literals into sequence

00:09:24.240 --> 00:09:29.220
of three literal clauses.
So, I can convert any clause which is not

00:09:29.220 --> 00:09:33.980
in -SAT into a sequence of -SAT clauses
and how big is sequence, well it is going

00:09:33.980 --> 00:09:38.819
to be portion to the number of literals in
the clause. So, the blow up in my formula

00:09:38.819 --> 00:09:43.130
is going to be linear in the original formula,
that is important, because we said that will

00:09:43.130 --> 00:09:49.170
be do reductions, we want the reduction part
to be efficient to say that, we are not spending

00:09:49.170 --> 00:09:52.670
so much time of the reduction, other we cannot
transfer efficient see claims at those.

00:09:52.670 --> 00:09:57.939
So, what this tells us in that, if SAT is
hard does we believe, then so is -SAT, because

00:09:57.939 --> 00:10:01.269
I reduce SAT to -SAT.

00:10:01.269 --> 00:10:07.850
So, far we have seen reductions which are
not very perhaps surprising, we have seen

00:10:07.850 --> 00:10:14.209
independent set and vertex cover, but these
are similar problems. Similarly, we have seen

00:10:14.209 --> 00:10:19.594
SAT and -SAT, these are similar problems.
Now, what we are going to do is, we are going

00:10:19.594 --> 00:10:25.589
to bridge the gap between these two different
problems. We are going to look at -SAT and

00:10:25.589 --> 00:10:30.230
say that -SAT actually you can reduce to
independent set, which is the little bit more

00:10:30.230 --> 00:10:32.860
surprising, because they seen come from variable
different domains.

00:10:32.860 --> 00:10:40.649
So, here is a typical -SAT formula. So, we
have , , , clauses and each of them as

00:10:40.649 --> 00:10:45.730
at most three literal, so this one has two
literal, so other one that theÉ So, since

00:10:45.730 --> 00:10:50.199
we have -SAT, then we have a structure which
is bounded by three. So, we will represent

00:10:50.199 --> 00:10:57.610
every clause by this triangle and in the triangle
will put a label which indicates the literal.

00:10:57.610 --> 00:11:04.569
So, not x is replace by not x is in this thing,
y and so this not x or y or z not z is this

00:11:04.569 --> 00:11:12.220
triangle. Similarly, this is not x or not
y or z, so in this way every clause contributes

00:11:12.220 --> 00:11:17.410
the triangle to may graph.
So, what is this triangle signify, this triangle

00:11:17.410 --> 00:11:25.040
signifies that if may independent set picks
one of these things, say y, then it cannot

00:11:25.040 --> 00:11:31.639
pick the other two. So, what this is saying
is this is going to make exactly one of these

00:11:31.639 --> 00:11:38.339
things, it is going to identify for me which
of the literals true in order to make this

00:11:38.339 --> 00:11:42.860
formula actually work out with. So, it is
kind of giving me a witness from each clause.

00:11:42.860 --> 00:11:49.389
So, not it well to be valid witness y is
here, then I cannot pick not wide to be the

00:11:49.389 --> 00:11:53.619
witness to the next hour, because y and not
y contribute each other. So, in addition to

00:11:53.619 --> 00:11:59.300
the triangle, I have these green edges saying
that variable and it is compliment will be

00:11:59.300 --> 00:12:05.769
connected by green edge. So, there should
be some more green edges perhaps connecting

00:12:05.769 --> 00:12:14.239
this y to that not y is, so there should be
clause, so this y to that not y.

00:12:14.239 --> 00:12:18.269
So, every variable is connected to is compliment
to indicate that if one is there, the other

00:12:18.269 --> 00:12:24.589
cannot be there. So, what we independent set
is saying is this is time to pick out a solution,

00:12:24.589 --> 00:12:34.709
is trying to pick out a solution by looking
at each clause. And saying that may be I pick

00:12:34.709 --> 00:12:39.670
y here, I pick y here, then I am go to rule
out these things and I will maybe I can now

00:12:39.670 --> 00:12:45.410
I pick y there, then I to pick something here.
So, maybe I pick x here, if I pick x here,

00:12:45.410 --> 00:12:47.410
I ruled out that not x, you have to ruled
out this not x.

00:12:47.410 --> 00:12:52.730
Now, I am trouble, because I do not have anything,
so maybe I should could not a pick that x.

00:12:52.730 --> 00:12:57.429
So, therefore, I go back and say that, this
should pick this not x, this not x will ruled

00:12:57.429 --> 00:13:05.470
out this x, ruled out this x, force meet to
keep this z. Now, if I have an independent

00:13:05.470 --> 00:13:11.449
set of size , then I am done, so I can say
that the solution now I want is that x goes

00:13:11.449 --> 00:13:21.819
to false, y goes to true and z goes to true.
So, the existence of independent set on this

00:13:21.819 --> 00:13:25.259
particular thing of size , which picks out
per cost. So, notice that within a clause,

00:13:25.259 --> 00:13:31.290
I can only pick . So, if I have four clauses
and if I insist on the size are the independent

00:13:31.290 --> 00:13:36.110
set being the number of process, then I would
definitely have got one witness per literal.

00:13:36.110 --> 00:13:40.389
And those witnesses at we mutually consist,
because I connect z and not z x and not x

00:13:40.389 --> 00:13:45.239
everywhere by edges which rule out the same
variable feb by founding reset true in one

00:13:45.239 --> 00:13:50.529
times, false in one times.
So, this independent set now picks out those

00:13:50.529 --> 00:13:54.249
literal which four, which make my formula
true. So, if there is an independent set of

00:13:54.249 --> 00:13:58.139
size , then every clause can be made true
and this set of four clauses. And therefore,

00:13:58.139 --> 00:14:03.110
I have a solution to -SAT and if there is
no independent set of size , there is no

00:14:03.110 --> 00:14:07.460
solution. So, -SAT reduces independent set
which is a bit more surprising, when our reduction

00:14:07.460 --> 00:14:11.160
as we set from SAT to -SAT, which are both
similar looking problems.

00:14:11.160 --> 00:14:15.139
Over from independent set to vertex cover
and backward which are very directly structural

00:14:15.139 --> 00:14:19.319
related problem in the same type of graph.
So, this is the surprising thing is Boolean

00:14:19.319 --> 00:14:26.720
satisfiability and vertex issues, I am independent
vertices and graph are connect.

00:14:26.720 --> 00:14:32.220
So, we are shown that -SAT reduces -SAT,
-SAT reduces independent set, independent

00:14:32.220 --> 00:14:37.879
set and vertex cover are mutually reduce able.
Therefore, for instance because I can now

00:14:37.879 --> 00:14:46.739
compose these reductions, SAT now reduces
to vertex and you can find in the literature

00:14:46.739 --> 00:14:50.569
such reduction for various other problem that
traveling salesman, integer, linear programming

00:14:50.569 --> 00:14:53.399
and so on.
Now, all these is important per remember that

00:14:53.399 --> 00:14:57.730
we are looking in this context to reductions,
where the pre processing and post processing

00:14:57.730 --> 00:15:01.730
step at polynomial time. Because, we want
to say there is no time loss in the reduction,

00:15:01.730 --> 00:15:05.660
therefore, all the complexity is in the solution,
if I have a simple solution for b, I have

00:15:05.660 --> 00:15:06.929
a simple solution for a, when I reduce a to
b.

00:15:06.929 --> 00:15:12.559
If I have a complete solution for a, then
I cannot say that the solution reduction is

00:15:12.559 --> 00:15:16.529
what may set complex, it is because reduction
simple, it must be only the fact with two

00:15:16.529 --> 00:15:21.769
problems are similar that they are actually
having the same complexity. So, given this

00:15:21.769 --> 00:15:26.639
when all these problems are inter reduce able,
it means all of them are equally hard.

00:15:26.639 --> 00:15:34.279
Now, the famous theorem by Cook and Levin
says that every problem NP can be reduces

00:15:34.279 --> 00:15:38.359
to stack. Now, this is the rather amazing
theorem, because this is that take everything

00:15:38.359 --> 00:15:45.869
an NP, anything there I can reduce the SAT.
So, there is some reduction by taking an instant

00:15:45.869 --> 00:15:48.870
that problem, I can converted into next month
of SAT, so all those insert of sat and go

00:15:48.870 --> 00:15:52.199
back it is.
So, we have definitely not going to try and

00:15:52.199 --> 00:15:58.089
prove this theorem here, it is enough to know
that this proof is by encoding a suitably

00:15:58.089 --> 00:16:04.619
general module of computation. So, the original
proofs of Cook use during machines, you can

00:16:04.619 --> 00:16:08.529
take Boolean circles are register machines,
anything which is universal, anything which

00:16:08.529 --> 00:16:13.519
can compute every problem an NP. And then
argue that the computation of that problem,

00:16:13.519 --> 00:16:19.269
so if something as NP, there is an NP computation,
there is a checking problem, checking algorithm.

00:16:19.269 --> 00:16:24.690
So, you can encode the behavior of that checking
algorithm for that problem in SAT and therefore,

00:16:24.690 --> 00:16:32.290
it turns out that SAT is equivalent are everything
reduces to SAT.

00:16:32.290 --> 00:16:38.809
So, this gives us the notion of completeness,
we say the SAT is complete, because it belongs

00:16:38.809 --> 00:16:45.949
to NP and every problem in NP reduces to it,
this is the definition of NP completeness.

00:16:45.949 --> 00:16:50.990
A problem is NP complete, if first of all
it has a checking algorithm belongs to NP,

00:16:50.990 --> 00:16:56.959
efficient checking algorithm. And in addition
every problem in NP reduces to it by a polynomial

00:16:56.959 --> 00:17:03.839
time reduction. So, SAT by definition by the
Cook Levin theorem is NP complete, because

00:17:03.839 --> 00:17:07.149
it belongs to NP, we know.
And the Cook Levin theorem establishes at

00:17:07.149 --> 00:17:12.929
every problem in NP reduces to it, but now
we have seen that sat itself reduces to -SAT.

00:17:12.929 --> 00:17:18.150
So, every problem can be reduce to SAT and
then in a further polynomial step reduce to

00:17:18.150 --> 00:17:23.889
-SAT. So, every problem now reduces to -SAT,
the three sat is also NP, so -SAT is also

00:17:23.889 --> 00:17:32.360
NP complete. So, this is the generic technology
now, so you have some problem which is NP

00:17:32.360 --> 00:17:37.750
complete.
And then I reduce it my problem here that

00:17:37.750 --> 00:17:45.590
makes b also NP complete, because provide
b is an NP, if it is not an NP, then it is

00:17:45.590 --> 00:17:50.090
something weaker called NP hard, it is at
least a hard every problem NP, but may not

00:17:50.090 --> 00:17:57.860
be NP itself. So, NP hard says that, it is
every problem reduces to it, but you are not

00:17:57.860 --> 00:18:01.389
sure whether not belongs to NP, you do not
have a checking algorithm for it.

00:18:01.389 --> 00:18:06.190
So, there are few problems like this for which
checking algorithm is not easy to describe,

00:18:06.190 --> 00:18:11.230
but you cannot certainly show reduction. But
otherwise if can do both, you can find a checking

00:18:11.230 --> 00:18:16.211
algorithm and every problem, you have found
some problem which in NP which NP complete

00:18:16.211 --> 00:18:20.669
problem which reduces to it, then it is also
NP completed.

00:18:20.669 --> 00:18:27.450
So, this brings us back to the question of
whether or not P is equal to NP. So, many

00:18:27.450 --> 00:18:32.380
useful problems which are extremely important
day to day life scheduling, bin packing. So,

00:18:32.380 --> 00:18:37.990
bin packing is basically now if I want to
put various objects into a container in an

00:18:37.990 --> 00:18:44.730
optimum way or traveling salesman tours, we
want find optimal tours, all these are very

00:18:44.730 --> 00:18:49.019
important real life problems, which people
would like the life solve efficiently.

00:18:49.019 --> 00:18:53.460
The theory of NP completeness tells us that
all of these problems are actually inter reduce

00:18:53.460 --> 00:18:58.580
able, and therefore equivalent to each other,
I can solve one, I can solve them on. Now,

00:18:58.580 --> 00:19:02.990
we have this experimental evidence that since
these are important problem are large number

00:19:02.990 --> 00:19:08.480
of smart people have been looking at this
problems from even before the time that computer

00:19:08.480 --> 00:19:12.230
science was invented. People have been looking
at scheduling problem and bin packing problems

00:19:12.230 --> 00:19:17.269
for very Õs of years.
Therefore, these problems, if they have not

00:19:17.269 --> 00:19:22.640
yet yield it and efficient solution, then
it looks likely that there is no efficient

00:19:22.640 --> 00:19:29.340
solution. Therefore, from an empirical point
of view from purely experimental evidence,

00:19:29.340 --> 00:19:35.769
it seems to be strongly suggest that N P is
different from P. But this is not a proof

00:19:35.769 --> 00:19:39.990
unfortunately, mathematically one has to be
argue that N P is different from P by giving

00:19:39.990 --> 00:19:44.590
a proof by saying that is the reason why problems
some problems some N P complete problem can

00:19:44.590 --> 00:19:49.550
never be solve using a polynomial time. This
is what is called as lower bound, so we need

00:19:49.550 --> 00:19:59.049
to establish a lower bound.
For some N P complete problem and this is

00:19:59.049 --> 00:20:03.510
very hard, this is very proved challenging,
N P completeness was identify by Cook and

00:20:03.510 --> 00:20:09.150
Levin with early Õs. So, it is now more
than years, since the theory of N P completeness

00:20:09.150 --> 00:20:14.100
itself as invented and a lot of people and
looks at problem and nobody have yet found

00:20:14.100 --> 00:20:19.759
a direct way of doing this. So, formal proof
is elusive and is worth a million dollars,

00:20:19.759 --> 00:20:24.389
because there is a price given by the Clay
Math Institute.

00:20:24.389 --> 00:20:29.649
So, this is one of the celebrated open problems
and mathematics. So, with the Clay Institute

00:20:29.649 --> 00:20:35.230
as an awarded a large price. So, somebody
does prove that this is the indeed not the

00:20:35.230 --> 00:20:42.009
case, then there is a large price at stick.
So, with this it seems on appropriate place

00:20:42.009 --> 00:20:44.630
to end this course.
So, I thank you all of this time.

