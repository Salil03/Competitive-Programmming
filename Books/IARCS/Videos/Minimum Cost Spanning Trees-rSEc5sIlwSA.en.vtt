WEBVTT
Kind: captions
Language: en

00:00:01.459 --> 00:00:06.450
Having seen a variety of algorithms for shortest
paths on weighted graphs, we now move to a

00:00:06.450 --> 00:00:11.830
completely different problem that of computing,
what is called Minimum Cost Spanning Tree.

00:00:11.830 --> 00:00:16.400
So, to motivate the problem, let us consider
the following example.

00:00:16.400 --> 00:00:22.369
Suppose, we are in a district which has a
road network and after a bad cyclone, the

00:00:22.369 --> 00:00:23.369
roads have all being damaged.

00:00:23.369 --> 00:00:28.759
So, the first priority of the government is
to restore the roads, so that relief can be

00:00:28.759 --> 00:00:33.360
sent to various parts of the district and
also people can start moving around again.

00:00:33.360 --> 00:00:37.770
So, the priority is to restore enough roads,
so that everybody can move around.

00:00:37.770 --> 00:00:43.149
So, the first criteria for the government
to restore road is to ensure connectivity.

00:00:43.149 --> 00:00:48.430
So, given this which set of roads should the
government restore first?

00:00:48.430 --> 00:00:55.480
So, if the main criterion is minimum connectivity,
then it should be clear that there is no point

00:00:55.480 --> 00:00:58.010
in restoring roads which form a loop.

00:00:58.010 --> 00:01:03.539
For instance, supposing we restore all these
four roads, then we could have deleted any

00:01:03.539 --> 00:01:08.579
one of these roads, say 3 to 4 or 2 to 3 and
still one can get from any of these four towns

00:01:08.579 --> 00:01:12.070
to any four other towns in the district.

00:01:12.070 --> 00:01:17.960
So, removing an edge from a loop cannot disconnect
a graph and our aim is to find some sub set

00:01:17.960 --> 00:01:22.140
of edges within this graph which are connected
in such a way that this is a minimal such

00:01:22.140 --> 00:01:23.540
set of edges.

00:01:23.540 --> 00:01:28.299
So, what we want is a connected sub graph
of this original graph which does not have

00:01:28.299 --> 00:01:33.549
any loops which is acyclic and this is precisely
what is called a tree.

00:01:33.549 --> 00:01:39.060
So, tree by definition is a connected acyclic
graph.

00:01:39.060 --> 00:01:42.829
And in particular, we start to the arbitrary
graph and we are looking for a tree which

00:01:42.829 --> 00:01:47.590
sits inside the graph, which is a sub graph
in terms of the number of the edges, which

00:01:47.590 --> 00:01:49.810
connects all the vertices in the original
graph.

00:01:49.810 --> 00:01:55.880
So, such a tree is called a spanning tree,
it spans the vertices of the original graph,

00:01:55.880 --> 00:01:58.939
but it forms a tree out of the sub set of
three edges.

00:01:58.939 --> 00:02:04.649
So, in this graph for instance, one spanning
tree we could form, are red edges shown here,

00:02:04.649 --> 00:02:09.090
1 to 2, 2 to 3, 3 to 4 and 4 to 5.

00:02:09.090 --> 00:02:12.330
Of course, we could form other spanning tree
for instance this is green one, this is 1

00:02:12.330 --> 00:02:16.350
to 3, 2 to 3, 2 to 5 and 4 to 5.

00:02:16.350 --> 00:02:22.050
So, there are many possible spanning trees
that one can construct on a given graph.

00:02:22.050 --> 00:02:26.750
Now, suppose that the graph also has weights.

00:02:26.750 --> 00:02:31.260
In this example, the weight for instance could
be the cost of repairing a road.

00:02:31.260 --> 00:02:35.480
So, supposing restoring the road has a cost
and now the government would like to not only

00:02:35.480 --> 00:02:39.760
restore connectivity, but do it I mean at
minimum cost.

00:02:39.760 --> 00:02:46.670
So, if for instance, the government chose
to repair this tree of roads, then the total

00:02:46.670 --> 00:02:51.760
cost is 18 plus 6, 24 plus 70, 94 plus 20,
114.

00:02:51.760 --> 00:02:56.680
So, it could incur cost of 114 to the store,
this spanning tree.

00:02:56.680 --> 00:03:01.470
On the other hand, if the government chooses
green spanning tree, then the cost reduces

00:03:01.470 --> 00:03:06.550
to 10 plus 6 is16 plus 20 is 36 plus 8 is
44.

00:03:06.550 --> 00:03:11.450
So, different spanning trees now will come
at different cost and the goal would be to

00:03:11.450 --> 00:03:13.480
reduce the cost to minimum.

00:03:13.480 --> 00:03:18.090
In this particular example, you can check
this green tree, which has cost 44 is actually

00:03:18.090 --> 00:03:22.360
the minimum cost spanning tree on this particular
graph.

00:03:22.360 --> 00:03:30.340
So, before we move ahead to algorithms to
compute minimum cost spanning trees, let us

00:03:30.340 --> 00:03:33.510
look at some basic facts about trees.

00:03:33.510 --> 00:03:38.500
So, remember that by definition, a tree is
a connected acyclic graph.

00:03:38.500 --> 00:03:46.250
So, the graph in general will have n vertices,
so the claim is that any tree has exactly

00:03:46.250 --> 00:03:48.860
n minus 1 edges.

00:03:48.860 --> 00:03:52.920
So, this is very easy to prove, there are
many different ways of proving it, here is

00:03:52.920 --> 00:03:54.130
one way of thinking about it.

00:03:54.130 --> 00:03:59.370
So, supposing we have a tree, so initially
the tree is connected by a definition, so

00:03:59.370 --> 00:04:02.490
the entire graph forms one connected component.

00:04:02.490 --> 00:04:06.650
Remember, that when we did breadth first and
depth first search, we said that we can take

00:04:06.650 --> 00:04:09.920
a node and look at everything connected to
it and it forms a connected component.

00:04:09.920 --> 00:04:15.820
So, this tree defines one single connected
component, if you look at it as a graph in

00:04:15.820 --> 00:04:16.820
isolation.

00:04:16.820 --> 00:04:24.340
Now, because it is a tree, if I have an edge
from i to j, there cannot be any other path

00:04:24.340 --> 00:04:29.819
going from i to j by some other edges, because
if not that path plus this edge would form

00:04:29.819 --> 00:04:30.819
a cycle.

00:04:30.819 --> 00:04:35.539
So, if there is an edge from i to j and I
remove it, then by definition this component

00:04:35.539 --> 00:04:38.370
containing i and component containing j must
get disconnected.

00:04:38.370 --> 00:04:42.389
So, if I started with one component, now I
get two components.

00:04:42.389 --> 00:04:46.820
So, I delete the first edge from the graph
from my tree and I have one component more.

00:04:46.820 --> 00:04:51.050
Now, I delete one more edge by the same argument
whichever component that edge belongs will

00:04:51.050 --> 00:04:52.050
split again.

00:04:52.050 --> 00:04:57.960
So, each time I delete an edge, I increase
a number of components I have, but then, I

00:04:57.960 --> 00:05:02.699
know that in the end, if I have n isolated
vertices, I can have utmost n component.

00:05:02.699 --> 00:05:05.870
So, I cannot have more than n components,
if I have n vertices.

00:05:05.870 --> 00:05:08.099
So, I can only do this deletion n minus one
times.

00:05:08.099 --> 00:05:13.060
So, I start with a tree, I keep deleting edges
until everything is disconnected, I can only

00:05:13.060 --> 00:05:17.319
do this n minus 1 times and I must do it n
minus 1 times get everything disconnected

00:05:17.319 --> 00:05:22.199
therefore, the tree must had exactly n minus
1 edges.

00:05:22.199 --> 00:05:28.979
Now, if I take a tree and then I add an edge,
it must create a cycle, we already saw this

00:05:28.979 --> 00:05:34.229
in this previous argument that we said, so
supposing I have a tree, so a tree in general

00:05:34.229 --> 00:05:35.229
looks something like this.

00:05:35.229 --> 00:05:39.610
So, it is a graph, it has a kind of no cycles,
but many things branching out.

00:05:39.610 --> 00:05:43.659
Now, if anywhere if I create a tree, supposing
I add an edge and supposing I take some i

00:05:43.659 --> 00:05:47.289
there and some j here, we may decide to add
an edge.

00:05:47.289 --> 00:05:50.030
So, we know that because it is a tree, there
is already connection.

00:05:50.030 --> 00:05:53.789
So, there is some path which in this case
to this vertex from i to j.

00:05:53.789 --> 00:05:57.460
So, therefore, that path p plus this edge
forms a cyclic.

00:05:57.460 --> 00:06:02.620
So, in a tree I have exactly n minus 1 edges
and when I add any extra edge, no matter which

00:06:02.620 --> 00:06:06.689
edge I add, it will definitely form a cycle.

00:06:06.689 --> 00:06:13.830
So, another consequence of all these definitions
is that between any two paths, any two vertices

00:06:13.830 --> 00:06:16.909
in a tree, there can only be one unique path.

00:06:16.909 --> 00:06:21.270
So, supposing there are actually two paths,
so let us look at two vertices, here we have

00:06:21.270 --> 00:06:23.550
drawn them as i and j and suppose there are
two parts.

00:06:23.550 --> 00:06:30.249
So, if I follow the two parts, then it is
very clear that because there are two different

00:06:30.249 --> 00:06:32.870
ways are going there, there will be some loops
somewhere in between.

00:06:32.870 --> 00:06:37.750
So, notice that it need not to be a loop including
i and j, it could be somewhere in between

00:06:37.750 --> 00:06:41.620
i and j, but if you consider all the cases
carefully, you can convince yourself, there

00:06:41.620 --> 00:06:45.879
is no way to have two distinct paths from
i to j without creating a loop.

00:06:45.879 --> 00:06:51.870
And we have a loop, then the graph is no longer
acyclic, so it is not a tree which is our

00:06:51.870 --> 00:06:53.550
assumption to be given.

00:06:53.550 --> 00:07:01.419
So, we are actually the following claim that
we have these three properties, that G is

00:07:01.419 --> 00:07:07.979
connected, G is acyclic and G has n minus
1 edges, then any of these two implies the

00:07:07.979 --> 00:07:08.979
third.

00:07:08.979 --> 00:07:13.599
So, G is connected and G is acyclic by definition
it is a tree, we have just shown the first

00:07:13.599 --> 00:07:15.500
arguments that any tree has n minus 1 edges.

00:07:15.500 --> 00:07:19.430
So, the fact that the first two imply the
third is what we have already shown.

00:07:19.430 --> 00:07:24.990
Now, you can easily convince yourself to find
a formal prove that if G is acyclic and has

00:07:24.990 --> 00:07:28.819
n minus 1 edges then in fact, it must be connected,
everything must be connected everything.

00:07:28.819 --> 00:07:33.150
And finally, if G is connected and it has
n minus 1 edges, then it can be acyclic graph,

00:07:33.150 --> 00:07:35.029
it cannot have any graphs.

00:07:35.029 --> 00:07:39.180
So, these are various ways of looking at trees
and sometimes we might use one property or

00:07:39.180 --> 00:07:40.180
another property.

00:07:40.180 --> 00:07:45.949
So, it is useful to keep these things in the
back of our mind when we talk about trees

00:07:45.949 --> 00:07:47.069
in general.

00:07:47.069 --> 00:07:51.729
So, our target right now is to build a minimum
cost spanning tree.

00:07:51.729 --> 00:07:57.280
So, there are two naturally greedy strategies
that one can think of.

00:07:57.280 --> 00:08:01.550
One is, since you are looking for a minimum
cost tree to start with this smallest stage

00:08:01.550 --> 00:08:03.841
and incrementally build the tree.

00:08:03.841 --> 00:08:09.160
So, we keep adding edges to the existing tree,
so that the new graph remains a tree and it

00:08:09.160 --> 00:08:12.189
grows as little as possible it terms of cost.

00:08:12.189 --> 00:08:16.689
This will give raise to an algorithm which
is called primÕs algorithm.

00:08:16.689 --> 00:08:20.449
It will also turn out to be very similar to
DijkstraÕs shortest path algorithm with a

00:08:20.449 --> 00:08:22.669
single source.

00:08:22.669 --> 00:08:28.120
The other strategy we can have is to look
at edges in ascending order of cost and keep

00:08:28.120 --> 00:08:31.610
adding them, so long as we do not violate
the tree property.

00:08:31.610 --> 00:08:35.590
Now, this is different from PrimÕs Algorithm,
because here we do not built a tree to start

00:08:35.590 --> 00:08:40.280
with, we keep adding edges, so that we do
not create a cycle, but we could have disconnected

00:08:40.280 --> 00:08:44.620
groups of edges, but eventually there will
all connected to form a tree.

00:08:44.620 --> 00:08:49.270
So, we will see these in more detail in the
next 2 lectures, but let us just look at an

00:08:49.270 --> 00:08:52.660
initiative example of how these two strategies
work.

00:08:52.660 --> 00:09:00.590
So, let us look at these two algorithms intuitively
we will come to them more detail later, so

00:09:00.590 --> 00:09:02.270
let us start with PrimÕs Algorithm.

00:09:02.270 --> 00:09:06.520
Remember that the strategy in PrimÕs Algorithm
is to start with the smallest weight edge

00:09:06.520 --> 00:09:08.430
and then incrementally grow a tree.

00:09:08.430 --> 00:09:12.940
So, we start with a smallest edge here which
is the edge weight 6 between 2 and 3.

00:09:12.940 --> 00:09:18.540
Now, we have to look at the existing tree
which consists of this part of the graph and

00:09:18.540 --> 00:09:23.580
decide whether to add one of these four edges
to extend it.

00:09:23.580 --> 00:09:29.250
We cannot add that edge over here, we cannot
add this edge, because it would not form a

00:09:29.250 --> 00:09:31.000
tree, it would be disconnected from this edges.

00:09:31.000 --> 00:09:33.750
So, we can add any of these, but we choose
the smallest one.

00:09:33.750 --> 00:09:36.510
So, in this case, we choose the edge with
weight 10.

00:09:36.510 --> 00:09:41.840
So, the next step in the tree is to add the
edges 1, 2 and now, we have this tree.

00:09:41.840 --> 00:09:48.790
Now, if we look at possible edges that we
can add, we have this edge, we have this edge

00:09:48.790 --> 00:09:50.220
and we have this edge.

00:09:50.220 --> 00:09:54.820
Now, the smallest among these is the edges
with weight 18, but if I had that we get a

00:09:54.820 --> 00:09:55.820
cycle.

00:09:55.820 --> 00:09:57.400
So, this is not a good edge to add.

00:09:57.400 --> 00:10:01.460
So, therefore, we must add one of the other
2, again to pick the smaller one, which in

00:10:01.460 --> 00:10:05.150
this case is the edge labeled with weight
20.

00:10:05.150 --> 00:10:12.910
So, then we get this tree which has now this
shape, this is a given tree.

00:10:12.910 --> 00:10:15.990
Now, we can add, we cannot add this is we
know.

00:10:15.990 --> 00:10:21.840
So, we can either add the edges 70 or the
edges labeled with weight 8 and obviously

00:10:21.840 --> 00:10:22.840
8 is smaller.

00:10:22.840 --> 00:10:25.070
So, finally, we add that in this is a tree
that we can get.

00:10:25.070 --> 00:10:30.830
So, this is the final tree, we get from PrimÕs
Algorithm, let us starting from the smallest

00:10:30.830 --> 00:10:34.870
edge and incrementally growing the tree.

00:10:34.870 --> 00:10:39.620
The other strategy we said was to start with
the edges in ascending order.

00:10:39.620 --> 00:10:42.460
So, we start with edges with it, then 8, then
there mean.

00:10:42.460 --> 00:10:46.930
So, we have this is the first one, this is
the second one and this is third one and so

00:10:46.930 --> 00:10:47.930
on.

00:10:47.930 --> 00:10:53.110
So, we consider the edges in this order, 1,
2, 3, 4, 5 and 6.

00:10:53.110 --> 00:10:59.810
So, we have the weights in 18, 20, then finally
70.

00:10:59.810 --> 00:11:04.800
So, every 6 edges when we consider them in
this order, so among these of course, if smallest

00:11:04.800 --> 00:11:06.430
is 6, so we add.

00:11:06.430 --> 00:11:11.640
So, this is the starter of our tree, now the
next one is 8 and that does not form a cycle,

00:11:11.640 --> 00:11:13.130
it does not violate a tree property.

00:11:13.130 --> 00:11:16.920
So, we add that, notice now the crucial difference
between PrimÕs and KruskalÕs algorithm at

00:11:16.920 --> 00:11:21.010
this point, we do not have a tree, we have
two separate trees in some sense.

00:11:21.010 --> 00:11:25.110
So, we have two different acyclic component
within this graph which are not connected

00:11:25.110 --> 00:11:27.870
each other, but we are just going in order
of an edges.

00:11:27.870 --> 00:11:31.790
So, next we will see 10 is the next edges
that we can add, this does not form a cycle.

00:11:31.790 --> 00:11:34.940
So, we add that, so in some sense, we have
grown this component and left that component

00:11:34.940 --> 00:11:35.940
grown.

00:11:35.940 --> 00:11:40.360
Now, the next one would be 18, but if you
add 18, it would form a cycle.

00:11:40.360 --> 00:11:45.610
So, we skip 18, we move to the next one, this
is 20, 20 is fine and 20 will in fact, connect

00:11:45.610 --> 00:11:47.230
the two component to form a tree.

00:11:47.230 --> 00:11:52.650
So, we add 20, now we are done, because we
have added n minus 1 edges, there are five

00:11:52.650 --> 00:11:55.570
vertices, we got 4 edges and therefore, we
are definitely got a tree.

