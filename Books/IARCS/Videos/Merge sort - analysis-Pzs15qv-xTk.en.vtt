WEBVTT
Kind: captions
Language: en

00:00:01.610 --> 00:00:06.650
So, we have seen how to use a divide and conquer
strategy, to implement a sorting algorithm

00:00:06.650 --> 00:00:12.330
called merge sort. So, now we want to analyze
whether the merge sort actually behaves, better

00:00:12.330 --> 00:00:17.910
than our order n square intuitive sorts like
insertion sort and selection sort.

00:00:17.910 --> 00:00:24.160
So, in order to analyze merge sort, we first
need to look at the merge operation itself.

00:00:24.160 --> 00:00:30.020
So, remember that when we merge two sorted
lists, what we do is, we take both lists side

00:00:30.020 --> 00:00:34.010
by side and we keep copying the smaller of
the two elements at the head of each list

00:00:34.010 --> 00:00:35.220
into the final list C.

00:00:35.220 --> 00:00:44.330
So, this was the code that we wrote last time.
So, basically we have a list A, which runs

00:00:44.330 --> 00:00:54.079
from 0 to m minus 1 and we have another list
B, which runs from 0 to n minus 1 and we produce

00:00:54.079 --> 00:01:02.149
the output in a third list C which has indices
from 0 to m plus n minus 1. So, what we do

00:01:02.149 --> 00:01:09.320
is, we start by putting an index i, j into
these two lists and index k into the list

00:01:09.320 --> 00:01:13.650
C and we compare these two values and we take
the smaller of the two values and move it.

00:01:13.650 --> 00:01:17.610
And then we move this and then we keep moving
these two indices and all the while we keep

00:01:17.610 --> 00:01:21.960
moving k. So, the question is how long does
this take?

00:01:21.960 --> 00:01:30.190
So, in each iteration notice that we add one
element to C, but the size of C is exactly

00:01:30.190 --> 00:01:35.810
m plus n, because there are m elements in
A and there are n elements in B and each of

00:01:35.810 --> 00:01:41.930
them will eventually make it to C. So, there
are m plus n elements and in each iteration

00:01:41.930 --> 00:01:47.890
of this loop, the loop that we had before,
in each iteration of this loop, one element

00:01:47.890 --> 00:01:51.840
gets added to C, either in this if or in this
if, k is incremented.

00:01:51.840 --> 00:01:56.410
So, this list as you can see will make, k
will make progress in every iteration. So,

00:01:56.410 --> 00:02:01.860
there is a bound of m plus n steps for this
loop and in the loop, we will if you count

00:02:01.860 --> 00:02:05.330
very carefully, we have a comparison, we may
have one more comparison, we have an assignment

00:02:05.330 --> 00:02:09.649
and so on. But, you can check that there are
no more than seven steps involved, so some

00:02:09.649 --> 00:02:14.470
constant number of steps regardless, so which
branch we take in this, so we have m plus

00:02:14.470 --> 00:02:17.410
n iterations, each of which has some constant
number of steps.

00:02:17.410 --> 00:02:23.410
So, we have over all order m plus n steps,
but m plus n is of course, bounded by 2 times

00:02:23.410 --> 00:02:28.830
the maximum of m plus n. So, we can just say
that this thing takes order of maximum m plus

00:02:28.830 --> 00:02:32.910
n. If m is roughly the same as n which will
typically be the case in merge sort, because

00:02:32.910 --> 00:02:38.030
we split it in half, the two will differ by
at most 1 in terms of length. Then, we find

00:02:38.030 --> 00:02:42.700
that merging is a linear time operation, so
we want to merge two lists, it takes time

00:02:42.700 --> 00:02:46.030
proportional to the length of the two lists
together.

00:02:46.030 --> 00:02:52.910
So, now coming to merge sort itself, what
we want to do is, we want to take a list of

00:02:52.910 --> 00:03:01.340
size n and we want to split it into two lists
of size n by 2. And then, we sort these separately

00:03:01.340 --> 00:03:03.030
and then we merge.

00:03:03.030 --> 00:03:09.069
So, in order to do this, it is very clear
that if we look at t n as the time taken by

00:03:09.069 --> 00:03:14.880
merge sort on an input of size n, then this
requires us to sort two lists of size n by

00:03:14.880 --> 00:03:21.430
2 and then, as we have seen it takes order
n time in order to merge that. Now, in order

00:03:21.430 --> 00:03:29.790
to compute this t of n explicitly, we will
assume that n is a power of 2. Now, it turns

00:03:29.790 --> 00:03:35.360
out that merge sort does not in any way require
n to be a power of 2, not even an even number.

00:03:35.360 --> 00:03:39.950
If it is not even, then when we split it into
two parts, they will not be equal, because

00:03:39.950 --> 00:03:42.590
we cannot split an odd number into two equal
parts.

00:03:42.590 --> 00:03:46.340
But, it does not a matter, the algorithm will
still work correctly, this assumption that

00:03:46.340 --> 00:03:52.129
n is 2 to the k is only a signification for
us to be able to come up with a nice calculation.

00:03:52.129 --> 00:03:58.560
So, we have two problems of size n by 2, 2
times of t of n by 2 and then we have a merge

00:03:58.560 --> 00:04:02.390
of n. So, how do we solve something like this.
So, of course, we also have a base case which

00:04:02.390 --> 00:04:07.430
says that when we have only one element, it
takes no time except to just check that you

00:04:07.430 --> 00:04:13.440
have only one element, so t of 1 is 1.
So, if you have a solution I mean an expression

00:04:13.440 --> 00:04:17.959
like this two recurrences like this, then
how do we solve them. So, the basic idea is

00:04:17.959 --> 00:04:22.109
to keep the simplest way to do it. Of course,
you can come up with more sophisticated way

00:04:22.109 --> 00:04:26.119
which we will not go into right now. But,
one simple way is you just keep expanding

00:04:26.119 --> 00:04:31.680
using the same analysis, the same expression,
until you come down to the base case.

00:04:31.680 --> 00:04:39.440
So, we start with the base case t 1 equal
to 1 and the general case t n is 2 times t

00:04:39.440 --> 00:04:45.879
of n by 2 plus n. So, now what we can do is,
we can use the same equation to expand t of

00:04:45.879 --> 00:04:52.479
n by 2. So, we expand t of n by 2, then we
find that t of n by 2 becomes 2 times t of

00:04:52.479 --> 00:04:56.789
n by 4 plus n by 2, because I take whatever
is here divide 2, n by 2 by 2 is n by 4 and

00:04:56.789 --> 00:05:00.430
I take whatever is here and plug it in here,
so n by 2 comes.

00:05:00.430 --> 00:05:07.120
Now, if I expand this out carefully, then
this 2 and this 2, rather than write it as

00:05:07.120 --> 00:05:11.139
4 and I will write it as 2 squared, I will
also observe and this will be useful that

00:05:11.139 --> 00:05:21.090
this 4 is again 2 squared and then this n
by 2 is multiplied, so this n by 2 is multiplied

00:05:21.090 --> 00:05:26.219
by 2. So, I get 2 times n by 2, so that is
n plus n, so I get 2 n.

00:05:26.219 --> 00:05:31.139
So, it is not an accident that I have 2 squared,
2 squared and 2 n as we will see, if you do

00:05:31.139 --> 00:05:38.509
one more step, now if I take this expression
t of n by 2 square and I apply the same rule

00:05:38.509 --> 00:05:47.449
to this, then this t of n by 2 squared expands
out like this. It is n by 2 square divide

00:05:47.449 --> 00:05:53.430
by 2 is n by 2 cube, so I get 2 times t n
by 2 cube plus n by 2 square. Now, this and

00:05:53.430 --> 00:06:00.639
this will cancel, so I get 1 n here, I already
have 2 n, so I get 3 n and this 2 into 2 square,

00:06:00.639 --> 00:06:06.869
I will write as 2 cube, so I am going from
2 square t n by 2 square plus 2 n to cube

00:06:06.869 --> 00:06:13.949
t n by 2 cube plus 3 n. So, it is easy to
verify that if you do this j times we will

00:06:13.949 --> 00:06:19.360
have 2 to the power j times t of n by 2 to
the power j plus j n.

00:06:19.360 --> 00:06:24.449
So, now when do we reach the base case, we
reach the base case when n by 2 to the power

00:06:24.449 --> 00:06:34.180
j goes to 1. So, when does this happen? Well,
n by 2 to the power j is equal to the 1, it

00:06:34.180 --> 00:06:42.169
means that 2 to the power j is equal to n,
so j is nothing but, log of n to the base

00:06:42.169 --> 00:06:49.419
2. So, we will always use log n in general
to mean log of n to the base 2, unless otherwise

00:06:49.419 --> 00:06:56.789
specified.
So, after log of n steps, we end up with something

00:06:56.789 --> 00:07:03.080
which looks like this, it has 2 to the j t
n by 2 to the j, after log n steps, j is log

00:07:03.080 --> 00:07:10.930
n, so I have 2 to the log n, then t of n by
this, so this is t of 1 now, so this is just

00:07:10.930 --> 00:07:18.629
1, so this multiplied by 1. And then, I have
j times n, so j is log n, so j is log n and

00:07:18.629 --> 00:07:27.949
n is n. So, I have after doing this expansion
log n times I end up with 2 to the log n plus

00:07:27.949 --> 00:07:34.490
log n times n, 2 to the log n by definition
is just n, that is the definition of log that

00:07:34.490 --> 00:07:40.089
is the exponent of 2 which gives you n.
So, this is n and I have this gives n log

00:07:40.089 --> 00:07:46.389
n and we know from general things that n is
big O of n log n. So, this is bounded by 2

00:07:46.389 --> 00:07:52.449
times n log n. So, we can say that over all
merge sort takes time O n log n. So, we have

00:07:52.449 --> 00:07:56.819
achieved a significant improvement, because
remember that, so far both insertion sort

00:07:56.819 --> 00:08:01.800
and selection sort were O n square and we
have come down from O n square to O n log

00:08:01.800 --> 00:08:05.770
n by using this divide and conquer strategy.

00:08:05.770 --> 00:08:12.300
So, why is this a big deal, we saw in the
beginning that O n log n is much more efficient

00:08:12.300 --> 00:08:19.990
than O n square. If we assume as we have said
that a reasonably standard desktop machine

00:08:19.990 --> 00:08:25.979
can do 10 to the 8 operations per second,
then the size of the feasible input of what

00:08:25.979 --> 00:08:31.699
we can sort with a sorting algorithm, goes
from 10,000 for an n square algorithm to 10

00:08:31.699 --> 00:08:36.940
million or 1 crore for an n log n algorithm.
So, therefore if you really have to sort large

00:08:36.940 --> 00:08:41.500
volumes of data, n log n makes it feasible
for us do so in a reasonable amount to time,

00:08:41.500 --> 00:08:45.250
whereas n square would take years as we saw
before.

00:08:45.250 --> 00:08:52.430
So, before we conclude there are some nice
things to notice. So, this merge operation

00:08:52.430 --> 00:08:56.850
which we have used in merge sort, is actually
a very useful operation on any sorted list.

00:08:56.850 --> 00:09:01.589
So, one thing that we do in merge is that
we actually combine the list without losing

00:09:01.589 --> 00:09:08.800
anything. So, if we merge two lists such,
let us say 1, 2, 4 and 2, 3, 6 then in our

00:09:08.800 --> 00:09:15.890
final thing, we will have 2 copies of 2, because
there are 2 copies and then 3, 4, 6.

00:09:15.890 --> 00:09:21.060
So, sometimes we may want to not have this,
we may want to keep only one copy, we may

00:09:21.060 --> 00:09:28.370
want to treat this as sets, so if I take this
as a set 1, 2, 4 and a set 2, 3, 6, then the

00:09:28.370 --> 00:09:32.800
resulting union of the two set is 1, 2, 3,
4, 6 you have only one copy of 2. Then, we

00:09:32.800 --> 00:09:39.279
can easily do this in our merge procedure
by just saying that when I find, so earlier

00:09:39.279 --> 00:09:48.670
we had two cases, we had A i less than or
equal to B j and then we had A i greater than

00:09:48.670 --> 00:09:51.970
B j.
So, in the first case, we copied from A i,

00:09:51.970 --> 00:09:55.709
the second case we copied from B j and in
either case we only incremented either i or

00:09:55.709 --> 00:10:01.529
j along with k. In this case, we say that
if the two sides are equal, we keep one copy

00:10:01.529 --> 00:10:05.639
of it in the final list, but we skip over
both these copies, we increment all three

00:10:05.639 --> 00:10:10.790
pointers. So, if we are at this position and
this position, then in our output we will

00:10:10.790 --> 00:10:15.990
copy a 2 and then we will move this pointer
to the right and this pointer to the right,

00:10:15.990 --> 00:10:25.430
so I do not copy 2 twice, so this is one thing
that we can do.

00:10:25.430 --> 00:10:32.170
The other thing that we can do is to intersect
two lists, so if we again have 1, 2, 3 may

00:10:32.170 --> 00:10:41.329
be 2, 3, 6 then may be we want to make sure
that we have in our output only 2 and 3. So,

00:10:41.329 --> 00:10:45.610
now what we do is, when we start looking at
these two, if they are not equal, then obviously

00:10:45.610 --> 00:10:49.720
they are not in the intersection. But, which
one should we leave, well 2 could still be

00:10:49.720 --> 00:10:52.040
there, because 1 is smaller, so we move this
pointer right.

00:10:52.040 --> 00:10:57.649
So, if A i smaller than B j we increment i,
now if say when A i, B j are the same, we

00:10:57.649 --> 00:11:02.230
would as we did for union, we will move the
2 out and we will merge, we will remove both

00:11:02.230 --> 00:11:06.879
pointers, so now both pointers come to this
position. Now, again we will say that we have

00:11:06.879 --> 00:11:11.100
3 and we will continue and then when we see
the other way around, if B j is smaller than

00:11:11.100 --> 00:11:15.170
A i, we will increment j and not i.
So, the important thing to note is that merge

00:11:15.170 --> 00:11:19.800
is a very generic operation, we can do what
we did earlier which is to actually shuffle

00:11:19.800 --> 00:11:24.560
the two sorted lists into one big sorted list,
where no elements are lost or we can remove

00:11:24.560 --> 00:11:29.379
duplicates, while we are doing is, treated
as a set union operation or we can only keep

00:11:29.379 --> 00:11:32.079
the common parts which is set intersection
operation.

00:11:32.079 --> 00:11:36.690
So, to check that you have understood this,
maybe you should try out the following exercise.

00:11:36.690 --> 00:11:41.319
So, supposing we want to do what is called
list difference, so set difference is sometime

00:11:41.319 --> 00:11:49.540
written like this. So, if I take the set 1,
2, 3 and the set say 3, 4, 6 and I ask the

00:11:49.540 --> 00:11:53.851
set difference, it says whatever is in A,
but not in B, so the answer should be in this

00:11:53.851 --> 00:11:58.240
case 1 and then 2, but not 3, because 3 is
there in both.

00:11:58.240 --> 00:12:02.009
So, we can do the same thing for list. So,
for example, if I have list 1, 2, 3 and list

00:12:02.009 --> 00:12:06.470
3, 4, 6 then I may want to keep in the list
only 1, 2. So, just check whether you can

00:12:06.470 --> 00:12:13.319
adapt merge in the way we have done now for
union and intersection in order to do list

00:12:13.319 --> 00:12:14.560
difference.

00:12:14.560 --> 00:12:21.230
So, merge sort though it is an order n log
n sorting algorithm and therefore it is significantly

00:12:21.230 --> 00:12:27.029
faster than insertion sort or selection sort,
it does have some short comings. The main

00:12:27.029 --> 00:12:32.800
problem with merge sort is that it requires
extra space. See, when I take A and B and

00:12:32.800 --> 00:12:40.240
I merge it into C, it is almost impossible
to do this without storing the merged array

00:12:40.240 --> 00:12:46.500
in a separate place. Because, if I start merging
in place, then the sorted order of A and B

00:12:46.500 --> 00:12:49.959
gets messed up or I have to keep shifting
things and so the merge is no larger in linear

00:12:49.959 --> 00:12:52.089
time.
So, if I want a linear time merge of A and

00:12:52.089 --> 00:12:58.759
B, this can only be achieved by using an external
list of the size which is the sum of two lists

00:12:58.759 --> 00:13:03.819
in order to store it. This means that if you
are sorting large arrays and also extra space

00:13:03.819 --> 00:13:09.029
is being used, because I keep duplicating
the space in order to do the merge operation.

00:13:09.029 --> 00:13:12.449
And of course, the other thing about merge
sort which is very difficult to overcome is

00:13:12.449 --> 00:13:16.350
that it is inherently recursive and I mean
there is no way to actually easily make it

00:13:16.350 --> 00:13:21.540
iterative, because we need to construct the
sorted things and then merge them.

00:13:21.540 --> 00:13:27.810
So, we need to store these recursive solutions
at each point in order to combine. So, the

00:13:27.810 --> 00:13:33.639
recursive call and return can be expensive
also. So, although merge sort is a very attractive

00:13:33.639 --> 00:13:38.800
sort in terms of its theoretical complexity,
it is not sometimes used in practice, because

00:13:38.800 --> 00:13:43.410
of these limitations and we will see how to
overcome this in some other way.

00:13:43.410 --> 00:13:48.279
So, the main reason we need extra space in
merge sort, is because of the merge operation

00:13:48.279 --> 00:13:53.360
as we saw in order to combine A and B into
a list C in linear time you need extra space.

00:13:53.360 --> 00:13:57.610
Now, suppose and the reason this happens is
because we could have something like the left

00:13:57.610 --> 00:14:05.879
side could be say 2, 4, 6 and the right side
could be say 1, 3, 5 and now we need to take

00:14:05.879 --> 00:14:08.959
things from both sides. So, sometimes I need
think something from here, then I need take

00:14:08.959 --> 00:14:11.769
something from here, then I need take something
from here and so on.

00:14:11.769 --> 00:14:16.120
So, though each of the two half is sorted,
there are elements in left which must go to

00:14:16.120 --> 00:14:21.410
right and there are elements from right which
must go to the left. So, now, if we could

00:14:21.410 --> 00:14:25.750
come up with a way to avoid doing this, so
such that everything in the red part is smaller

00:14:25.750 --> 00:14:29.320
than everything in the green part, then once
I have sorted the red part and I have sorted

00:14:29.320 --> 00:14:33.189
then green part then automatically everything
in the red part stays to the left of everything

00:14:33.189 --> 00:14:36.290
in the green part.
So, if I had had instead of this, if I had

00:14:36.290 --> 00:14:42.649
had on the left I had started with say 2,
1, 3 and in the right I had started with 6,

00:14:42.649 --> 00:14:49.069
4, 5 and then, I had locally sorted these
things. So, I got 1, 2, 3 and then here I

00:14:49.069 --> 00:14:54.350
got 4, 5, 6 then after this if I guaranteed
the this the split was such that everything

00:14:54.350 --> 00:14:58.529
on the left is smaller than everything on
the right, after doing this divide and then

00:14:58.529 --> 00:15:03.759
solving the sub problems there is no combination
there is no need to merge. So, our next sorting

00:15:03.759 --> 00:15:06.859
algorithm will look at a strategy to implement
this idea.

