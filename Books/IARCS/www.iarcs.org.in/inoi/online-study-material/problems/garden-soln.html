<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a class="active" id="first" href="index-1.html">Problems</a></li>
	    <li><a href="../topics">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2>
        <a href="..\topics\sliding-window.html">Sliding Window Algorithms</a>&rarr;Garden (IOI 2005)
      </h2>

      <p>
        A garden is arranged as a rectangular grid of squares.
        Each square contains a number of roses.  We want to hire
        two gardeners to take care of the roses.  Each gardener
        is expected take care of exactly K roses, where K is a
        fixed number.  Each gardener wants to work on a
        rectangular patch.  To avoid the gardeners interfering
        with each other, they should work on with both patches
        disjoint (though it is permissible for the two rectangles
        to share a common boundary).  Each rectangular patch
        comes with a cost, which is the perimeter of the patch.
        The aim is to find two non overlapping rectanglular
        patches, each containing exactly K roses, so that the
        total cost of the two patches is minimal.  (If the two
        rectangles share a portion of the boundary, this is to be
        counted in the perimeter of both rectangles).
      </p>

      <p>
        Here the number of rows and columns is &le; 250, number
of roses &le; 5000, K &le; 2500.
      </p>


      <div id="solution">
        <h2>Solution</h2>
      </div>

      <p>
        It is not sufficient to greedily find one rectangle of
        minimum perimeter and then search for the second one.  In
        the minimum cost pair, neither rectangle may be of
        minimum size overall.
      </p>

      <p><em>Observation</em></p>

      <p>
        If we take two non-overlapping rectangles, they can
        always be separated by a vertical or horizontal line.
      </p>

      <pre>
       ---------------------              -----------------------
      |      .              |            |       -------         |
      |  --  .              |            |      |       |        |
      | |  | .  -----       |            |      |       |        |
      | |  | . |     |      |            |       -------         |
      |  --  . |     |      |            |.......................|
      |      . |     |      |            |    ---------------    |
      |      .  -----       |            |   |               |   |
      |      .              |            |    ---------------    |
       ---------------------              -----------------------
      </pre>

      <p>
        Thus, we can try all possible ways of splitting the
        original rectangle using either horizontal or vertical
        line.  For each split, we have to find the single best
        rectangle in each part.
      </p>

      <p>
        In this way, we have reduced the problem from jointly
        identifying two rectangles with minimum cost to that of
        finding one minimum cost rectangle within a given
        rectangle.
      </p>

      <p>
        How can we systematically enumerate all rectangles?
      </p>

      <p>
        Assume we are using fixed height rectangles.
        Systematically choose each row of the garden to be the
        "base row".  For each choice of base row, check each band
        that uses this base row.  Symmetrically, fix a base
        column for vertical bands.
      </p>

      <pre>
       ---------------------
      |                     |
      |---------------------|
      |                     |
      |  Band of height k   |
      |                     |
      |=====================|Base row
      |                     |
      |                     |
       ---------------------
      </pre>

      <p>
        This still requires us to calculate the number of roses
        in a given rectangle.  How can we do this efficiently
        without actually adding up all values within the
        rectangle?
      </p>

      <p>
        Calculate number of roses for special kind of rectangles,
        which start at top left corner of the original rectangle.
      </p>

      <pre>
         1  2  3  4  5  6  7  8  9   ...  m
         -----------------------------------
      1 |  |  |  |  |  |  |  |  |  | ... |  |
         -----------------------------------
      2 |  |  |  |  |  |  |  |  |  | ... |  |
         -----------------------------------
      3 |  |  |  |  |  |  |  |  |  | ... |  |
         -----------------------------------
      . |  |  |  |  |  |  |  |  |  | ... |  |
      .  -----------------------------------
      . |  |  |  |  |  |  |  |  |  | ... |  |
         -----------------------------------
      n |  |  |  |  |  |  |  |  |  |  |  |  |
         -----------------------------------
      </pre>

      <p>
        Count(i,j) is the number of roses in the rectangle whose
        top left corner is (1,1) and bottom right corner is
        (i,j).  We can compute Count(i,j) if we know the
        neighbouring values:
      </p>

      <pre>
       -------------------------------
      |           .         .         |
      |           .         .         |
      |           .         .         |
      |......(i-1,j-1) ----- (i-1,j)  |
      |           |         |         |
      |           |         |         |
      |....... (i,j-1) ----- (i,j)    |
      |                               |
       -------------------------------
      </pre>

      <ul>
        <li>  Count(i,j) = Count(i-1,j) + Count(i,j-1) - Count(i-1,j-1) + Roses(i,j)<br>
                where Roses(i,j) is number of roses at (i,j).
      </li></ul>

      <p>
        Now, given a rectangle with top left corner (u,v) and bottom right corner
        (x,y), the count of this rectangle is:
      </p>

      <ul>
        <li>  Count(x,y) - Count(u,y) - Count(x,v) + Count(u,v)
      </li></ul>

      <pre>
       -------------------------------
      |        .         .            |
      |        .         .            |
      |        .         .            |
      |.. (u,v) --------- (u,y)       |
      |        |         |            |
      |        |         |            |
      |        |         |            |
      |        |         |            |
      |.. (x,v) --------- (x,y)       |
      |                               |
       -------------------------------
      </pre>

      <p>
        Now, sitting on base row i we want to compute the best
        K-rose rectangle whose bottom edge is on i and whose top
        edge is on row i-k.
      </p>

      <pre>
       ---------------------
      |                     |
      |---------------------|
      |                     |
      |  Band of height k   |
      |                     |
      |=====================|Base row
      |                     |
      |                     |
       ---------------------
      </pre>

      <p>
        For this, we use the sliding window technique from the 
        <a href="..\topics\sliding-window-one-empty-plot.html">Empty
        Plot</a> problem.
      </p>

      <pre>
       ---------------------
      |                     |
      |--l-----r------------|
      |  .     .            |
      |  .     .            |
      |  .     .            |
      |=====================|Base row
      |                     |
      |                     |
       ---------------------
      </pre>

      <p>
        Given l and r, we can find the number of roses in this
        rectangle, using the counts we have calculated.  This is
        really a one dimensional sliding window problem.  If the
        count in the rectangle defined by l and r is less than or
        greater than K we expand/contract the window as before.
        If the count is exactly K, we compute the perimeter and
        note it down.
      </p>

      <p>
        In this way, we can compute the best rectangle sitting on
        base row i as the minimum among all best rectangles whose
        top row ranges from 1 to k-1.  For each top row, the
        sliding window takes time N.  There are M rows above i,
        so this takes MN time.
      </p>

      <p>
        Similarly, we can find all rectangles whose top row is
        the base row i and bottom row varies from i+1,&hellip;,M.
      </p>

      <p>
        We do this for every base row, so this takes time M times
        MN = M<sup>2</sup>N overall.
      </p>

      <p>
        In a similar way, we fix base columns and find the best
        rectangles to the left and right.  This takes N times MN
        = N<sup>2</sup>M overall.
      </p>

      <hr class="noscreen">
      <br>


    </div>
  </div> <!-- Right column end -->


    <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Problems related to</h3>
      <ul class="menu">
        <li><a href="index-1.html#binarysearch">Searching</a></li>
        <li><a href="index-1.html#sorting">Sorting</a></li>
        <li><a href="index-1.html#graphs">Basic Graph Algorithms</a></li>
        <li><a href="index-1.html#dp">Dynamic Programming</a></li>
        <li><a href="index-1.html#greedy">Greedy Algorithms</a></li>
        <li><a href="">Computing Shortest Paths</a></li>
        <li><a href="index-1.html#heaps">Heaps</a></li>
        <li><a href="index-1.html#permutations">Permutations</a></li>
        <li><a href="index-1.html#dags">Directed Acyclic Graphs</a></li>
        <li><a href="index-1.html#prefix-sums">Computing Prefix Sums</a></li>
        <li><a href="index-1.html#sliding-window">Sliding Window Algorithms</a></li>
        <li><a href="index-1.html#advanced-graph-algorithms">Advanced Graph Algorithms</a></li>
        <li><a href="index-1.html#dp-trees">Dynamic Programming on Trees</a></li>
        <li><a href="index-1.html#range-queries">Range Queries</a></li>
        <li><a href="index-1.html#network-flows">Network Flows</a></li>
        <li><a href="index-1.html">Games and Strategies</a></li>
        <li><a href="index-1.html#geometry">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

  <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="../topics">Topics</a>|</li>
                  <li><a href="">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
