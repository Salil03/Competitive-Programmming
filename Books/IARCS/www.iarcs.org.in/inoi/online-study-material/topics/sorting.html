<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a href="..\problems\index.html">Problems</a></li>
	    <li><a class="active" id="first" href="index-1.html">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2><a href="">Sorting</a></h2>

      <p>
	We want to sort an array with N elements.  Naive
	algorithms such as bubblesort and insertion sort take
	N<sup>2</sup> operations to sort the array.  Better
	sorting algorithms work in time proportional to N log N.
	Is this improvement worth it?
      </p>

      <p>
	Consider the problem of searching for a value in an array
	of size 10000.  We can either sort the array and then use
	binary search (that takes time log N) or do an exhaustive
	linear search.
      </p>

      <p>
	Exhaustive search takes time N, in general, since we may
	have to scan the entire array.  For our example, we can
	thus search for a single value in 10000 steps.
      </p>

      <p>
	Binary search takes time log N (all our logs are to the
	base 2).  Recall that 2<sup>10</sup> = 1032 so log 1000
	is approximately 10.  Since 10000 = 1000 * 10, log 10000
	= log 1000 + log 10 = 10 + 4 = 14.
      </p>

      <p>
	If we are searching for a single value, we can use
	exhaustive search and do the job in 10000 steps.  If we
	sort the array using an N<sup>2</sup> sorting algorithm
	and then use binary search, we spend 10000*10000 =
	10<sup>8</sup> steps sorting it, followed by 14 steps to
	search.
      </p>

      <p>
	If we repeat this search 10000 times, we would spend 10000*10000 operations
	doing exhaustive search and 10000*10000 + 14*10000 = 10014*10000 operations
	doing sorting plus binary search.  For any value above 10014, sorting will
	start to make itself effective---if we check when 10000*M = 10000*10000 +
	14*M, we get M a little above 10014.
      </p>

      <p>
	On the other hand, suppose we use an N log N sorting algorithm.  Then, the
	sort phase takes time 14*10000.  So, to see when sorting+binary search
	beats exhaustive search, we need to check when 10000*M = 14*10000 + 14*M,
	which is approximately when M = 14.  Thus, if we do even 15 searches, it
	helps to sort.
      </p>

      <p>
	What if the array grows from 10000 to 100000?  Since log 100000 is about
	17, the equations we have are
      </p>

      <ul>
	<li> N<sup>2</sup> sorting:     100000*M = 100000*100000 + 17*M
	<li> N log N sorting: 100000*M = 100000*17 + 17*M
      </li></ul>

      <p>
	Thus, we need to about 100017 exhaustive searches to justify justify an N<sup>2</sup>
	sorting algorithm, but only 17 searches to justify an N log N sorting
	algorithm.
      </p>

      <p>
	More importantly, if we use an N log N sorting algorithm, for values much
	less than the size of the array, we can use sorting to significantly speed
	up the search process.
      </p>

      <p>
	The reason why bubblesort etc are inefficient is that they duplicate
	comparisons.  One way to avoid this is to break up the array into non
	overlapping segments, sort these and then combine these portions
	efficiently.
      </p>

      <p>
	For instance, suppose we have a box with slips of paper with numbers
	between 100 and 300 to be sorted.  We could first separate the slips into
	two bunches: those with values below 200 and those with values above 200.
	We can sort these bunches separately.  Since all the values in the second
	bunch dominate those in the first bunch, we can combine them easily into a
	single sorted bunch.
      </p>


      <h3><span>Some efficient sorting algorithms</span></h3>

      <ul>
	<li> <a href="mergesort.html">Mergesort</a>
	<li> <a href="quicksort.html">Quicksort</a>
	<li> <a href="stablesort.html">Stable sorting</a>
      </li></ul>

      <h3><span>Problems based on sorting</span></h3>

      <ul>
	<li> <a href="..\problems\shoemaker.html">Shoemaker</a>
	<li> <a href="..\problems\utopia.html">Utopia (IOI 2002)</a>
      </li></ul>
    </div>
  </div> <!-- Right column end -->


    <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Basic topics</h3>
      <ul class="menu">
	<li><a href="introduction.html">Introduction</a></li>
	<li><a href="efficiency.html">Efficiency</a></li>
	<li><a href="binarysearch.html">Searching</a></li>
	<li><a href="sorting.html">Sorting</a></li>
	<li><a href="graphs.html">Basic Graph Algorithms</a></li>
	<li><a href="dp.html">Dynamic Programming</a></li>
	<li><a href="greedy.html">Greedy Algorithms</a></li>
	<li><a href="shortest-paths.html">Computing Shortest Paths</a></li>
	<li><a href="heaps.html">Heaps</a></li>
	<li><a href="permutations.html">Permutations</a></li>
	<li><a href="dags.html">Directed Acyclic Graphs</a></li>
	<li><a href="prefix-sums.html">Computing Prefix Sums</a></li>
	<li><a href="sliding-window.html">Sliding Window Algorithms</a></li>
      </ul>

      <h3>Advanced topics</h3>
      <ul class="menu">
	<li><a href="advanced-graph-algorithms.html">Advanced Graph Algorithms</a></li>
	<li><a href="dp-trees.html">Dynamic Programming on Trees</a></li>
	<li><a href="range-queries.html">Range Queries</a></li>
	<li><a href="network-flows.html">Network Flows</a></li>
	<li><a href="games.html">Games and Strategies</a></li>
	<li><a href="geometry.html">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

  <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="">Topics</a>|</li>
                  <li><a href="..\problems\index.html">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
