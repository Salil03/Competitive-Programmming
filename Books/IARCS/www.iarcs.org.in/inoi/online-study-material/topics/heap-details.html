<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a href="..\problems\index.html">Problems</a></li>
	    <li><a class="active" id="first" href="index-1.html">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2><a href="heaps.html">Heaps</a></h2>

      <h3><span>Manipulating heaps</span></h3>

      <p>      
	A heap is a binary tree with two properties:
      </p>

      <ol>

	<li>
	  The tree is filled level by level, without any gaps, so
	  it is a complete binary tree where only the bottom most
	  level may be incomplete.
	</li>

	<li>
	  The value at each node is less than or equal to that of its parents.
	</li>

      </ol>

      <p>
	Here is an example of a heap.
      </p>

      <pre>
                         ---3---
                       /         \
                     14           11
                   /   \         /   \
                 16     19     13     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	Suppose we want to insert an element, say 10, into the heap.
      </p>

      <p>
	Since we must fill the heap level by level, we can only
	insert it in the first free position on the bottom row.
      </p>

      <pre>
                         ---3---
                       /         \
                     14            11
                   /   \          /   \
                 16     19      13     15
                /  \   /  \     /
              21   20 23   24 10
      </pre>

      <p>
	This violates the heap property, but only between 10 and its parent.  We
	can fix the problem by swapping 10 with its parent.
      </p>

      <pre>
                         ---3---
                       /         \
                     14            11
                   /   \          /   \
                 16     19      10     15
                /  \   /  \     /
              21   20 23   24 13
      </pre>

      <p>
	This transfers the problem one level up, so we swap again
	and then stop because there are no further heap
	violations.
      </p>

      <pre>
                         ---3---
                       /         \
                     14            10
                   /   \          /   \
                 16     19      11     15
                /  \   /  \     /
              21   20 23   24 13
      </pre>

      <p>
	The height of such a complete binary tree with n nodes is
	at most log n, so we have to "bubble up" the new value at
	most log n times till the heap is restored to a stable
	state.
      </p>

      <p>
	Clearly, the minimum value in a heap is found at the
	root.  Thus, assuming we can compute the parent and
	children of a node efficiently, we can:
      </p>

      <ul>
	<li>  insert a vertex in log n time</li>
	<li>  find the minimum in constant time</li>
      </ul>

      <p>
	But, in Dijkstra's algorithm, we also want to delete the
	minimum vertex so that it is not considered again later
	on.
      </p>

      <p>
	If we delete the minimum value 3 from our heap, we create
	a hole at the root.  How do we restore the structure?
      </p>

      <pre>
                         --[  ]--
                       /         \
                     14            10
                   /   \          /   \
                 16     19      11     15
                /  \   /  \     /
              21   20 23   24 13
      </pre>

      <p>
	In the new heap, we have one less element, so eventually
	the last slot currently used in the bottom row will be
	vacant.  So, one option is to just move this last value
	to the root.
      </p>

      <pre>
                         ---13--
                       /         \
                     14            10
                   /   \          /   \
                 16     19      11     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	Now, we have a possible violation of heap property at the
	root.  We examine 13 and its two children and swap it
	with the smaller of its children, to get the following
	tree.
      </p>

      <pre>
                         ---10--
                       /         \
                     14            13
                   /   \          /   \
                 16     19      11     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	This pushes the heap violation one step down.  Again we
	swap 13 with the smaller of its children, to get
      </p>

      <pre>
                         ---10--
                       /         \
                     14            10
                   /   \          /   \
                 16     19      13     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	Now we stop.  Once again, the number of steps we take is
	proportional to the height of the tree, so delete-min
	takes time log n.
      </p>

      <p>
	What about updating a value?
      </p>

      <p>
	Suppose we change 19 to 6?
      </p>

      <pre>
                         ---13--
                       /         \
                     14            10
                   /   \          /   \
                 16      6      11     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	The heap property is violated above 6, so we move it up
	as we do in insert:
      </p>

      <pre>
                         ---6---
                       /         \
                     13            10
                   /   \          /   \
                 16     14      11     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	Suppose, instead, we had increased the value at 19 to 29?
      </p>

      <pre>
                         ---13--
                       /         \
                     14            10
                   /   \          /   \
                 16     29      11     15
                /  \   /  \
              21   20 23   24
      </pre>

      <p>
	In this case, we push it down, as in delete-min, till we get a heap.
      </p>

      <pre>
                         ---13--
                       /         \
                     14            10
                   /   \          /   \
                 16     23      11     15
                /  \   /  \
              21   20 29   24
      </pre>

      <p>
	So, changing a value and restoring the heap structure can
	also be done in log n time.
      </p>

      <p>
	To summarize, assuming we can find the parent/child of a
	node efficiently and also find the last element of a heap
	efficiently, we can perform the following operations
	efficiently:
      </p>

      <ul>
	<li>  find-min     : constant time</li>
	<li>  insert       : log n time</li>
	<li>  delete-min   : log n time</li>
	<li>  update-value : log n time</li>
      </ul>

      <p>
	How do we store a heap so that we can manipulate it easily?
      </p>

      <pre>
                         ---13--
                       /         \
                     14            10
                   /   \          /   \
                 16     23      11     15
                /  \   /  \
              21   20 29   24
      </pre>

      <p>
	We read off the values, level by level, and store them in
	an array.  The heap above would be an array of the form
      </p>

      <p align="center">
	[ 13   14   10   16   23   11   15   21   21   20   29   24]
      </p>

      <p>
	Here is a picture of the heap with each value labelled by
	its position in the array.
      </p>

      <pre>
                         --13(1)--
                       /           \
                     14(2)           10(3)
                   /      \          /   \
                 16(4)    23(5)   11(6)  15(7)
                /  \      /   \
           (8)21 (9)20  29(10) 24(11)
      </pre>

      <p>
	From this, it is immediate that the children of a node at
	position j are found at positions 2j and 2j+1.  Likewise,
	the parent of a node a position j is at position
	floor(j/2), where floor(n) is the largest integer less
	than or equal to n.
      </p>

    </div>
  </div> <!-- Right column end -->


    <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Basic topics</h3>
      <ul class="menu">
	<li><a href="introduction.html">Introduction</a></li>
	<li><a href="efficiency.html">Efficiency</a></li>
	<li><a href="binarysearch.html">Searching</a></li>
	<li><a href="sorting.html">Sorting</a></li>
	<li><a href="graphs.html">Basic Graph Algorithms</a></li>
	<li><a href="dp.html">Dynamic Programming</a></li>
	<li><a href="greedy.html">Greedy Algorithms</a></li>
	<li><a href="shortest-paths.html">Computing Shortest Paths</a></li>
	<li><a href="heaps.html">Heaps</a></li>
	<li><a href="permutations.html">Permutations</a></li>
	<li><a href="dags.html">Directed Acyclic Graphs</a></li>
	<li><a href="prefix-sums.html">Computing Prefix Sums</a></li>
	<li><a href="sliding-window.html">Sliding Window Algorithms</a></li>
      </ul>

      <h3>Advanced topics</h3>
      <ul class="menu">
	<li><a href="advanced-graph-algorithms.html">Advanced Graph Algorithms</a></li>
	<li><a href="dp-trees.html">Dynamic Programming on Trees</a></li>
	<li><a href="range-queries.html">Range Queries</a></li>
	<li><a href="network-flows.html">Network Flows</a></li>
	<li><a href="games.html">Games and Strategies</a></li>
	<li><a href="geometry.html">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

  <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="">Topics</a>|</li>
                  <li><a href="..\problems\index.html">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
