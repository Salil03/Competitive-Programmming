<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a href="..\problems\index.html">Problems</a></li>
	    <li><a class="active" id="first" href="index-1.html">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2><a href="graphs.html">Basic Graph Algorithms</a></h2>

      <h3><span>Representing graphs</span></h3>

      <br>

      <div id="graphs-adjacency-matrix">
	<h3><span>Adjacency matrix</span></h3>
      </div>

      <p>
	Suppose we have 7 nodes 1,2,...,7 and the list of neighbours are given
	by {(1,2),(1,3),(2,3),(3,4),(5,6),(7,6),(5,7}.  If we draw this as a
	picture, we have the following.
      </p>
      
      <pre>
                   2
                 /   \
               /       \
             1 --------- 3 --------  4

             5 --------- 6
               \       /
                 \   /
                   7
      </pre>

      <p>
	We can represent the structure of a graph as an
	"adjacency matrix" A with 7 rows and columns (in general,
	n rows and n columns, where the number of nodes in the
	graph is n).  The entry A[i,j] = 1 if nodes i and j are
	neighbours, and is 0 otherwise.
      </p>

      <p>
	For the example above, the adjacency matrix is
      </p>

      <pre>
        0  1  1  0  0  0  0
        1  0  1  0  0  0  0
        1  1  0  1  0  0  0
        0  0  1  0  0  0  0
        0  0  0  0  0  1  1
        0  0  0  0  1  0  1
        0  0  0  0  1  1  0
      </pre>

      <p>
	For a weighted graph, we set A[i,j] to be the weight of
	the edge (i,j) rather than just 1 or 0.
      </p>

      <p>
	If we want to visit all the neighbours of node i, we scan
	row i from left to right and select all non-zero
	entries. In general, to check the neighbours of a node,
	we have to scan n entries, independent of the degree of
	the node.
      </p>

      <p>
	If the graph has relatively few edges, we can use a
	different representation.
      </p>

      <div id="graphs-adjacency-list">
	<h3><span>Adjacency list</span></h3>
      </div>

      <p>
	In this representation, for each node we explicitly
	maintain a list of all its neighbouras.  For example, the
	graph with edges
	{(1,2),(1,3),(2,3),(3,4),(5,6),(7,6),(5,7}, is
	represented as:
      </p>

      <ul>
        <li>1 &rarr;  [2,3]</li>
	<li>2 &rarr;  [1,3]</li>
	<li>3 &rarr;  [1,2,4]</li>
	<li>4 &rarr;  [3]</li>
	<li>5 &rarr;  [6,7]</li>
	<li>6 &rarr;  [5,7]</li>
	<li>7 &rarr;  [5,6]</li>
      </ul>

      <p>
	Which representation to use depends on the requirement.
      </p>

      <ul>
	<li>
	  To visit all neighbours of a node, adjacency lists are
	  more efficient since we don't have to skip over 0's as
	  we do in the adjacency matrix.
	</li>

	<li>
	  To answer a question of the form "Is (i,j) an edge in
	  the graph", we have to scan the list of neighbours of
	  i, which could be very large.  In an adjacency matrix,
	  we just have to check the value of A[i,j].
	</li>

      </ul>

      <p><b>Storing adjacency lists</b></p>

      <p>
	A node can have at most N-1 neighbours.  For simplicity,
	we could represent an adjacency list as a two dimensional
	array E of size [1..N]&times;[0..N-1].  Row i lists the
	neighbours of node i.  E[i][0] is the number of
	neighbours of i.  The entries E[i][1],...,E[i][E[i][0]]
	list out the actual neighbours.
      </p>

      <pre>
           0   1   2   3   4   5   6

      1)   2   2   3   x   x   x   x
      2)   2   1   3   x   x   x   x
      3)   3   1   2   4   x   x   x
      4)   1   3   x   x   x   x   x
      5)   2   6   7   x   x   x   x
      6)   2   5   7   x   x   x   x
      7)   7   5   6   x   x   x   x
      </pre>

      <p>
	For instance, E[6][0] is 2, saying that node 6 has two
	neighbours.  The actual neighbours are stored in E[6][[1]
	and E[6][2].
      </p>

      <p>
	This is not a desirable implementation of adjacency lists for two reasons:
      </p>

      <ul>
	<li>It uses N<sup>2</sup> space even when M is small.</li>

	<li>If we have to initialize this matrix, it takes
	  N<sup>2</sup> time.</li>
      </ul>

      <p>
	A more efficient option is to maintain two linear arrays.
      </p>

      <pre>
           Offset              Neighbours
       1      1    -------------->  2
       2      3    ------------     3
       3      5    ----------  |->  1
       4      9    --------  |      3
       5     10    ------  | |--->  1
       6     12    ----  | |        2
       7     14    --  | | |        4
                     | | | |        6
                     | | |  ----->  3
                     | |  ------->  6
                     | |            7
                     |  --------->  5
                     |              7
                      ----------->  5
                                    6
      </pre>

      <p>
	Offset[i] stores the position in Neighbours where the
	neighbours of vertex i begin.  To examine all neighbours
	of vertex i, scan Neighbours[Offset[i]],
	Neighbours[Offset[i]]+1, &hellip; Neighbours[Offset[i+1]]-1.
      </p>

      <p>
	Note, however, that adding edges in this representation
	is complicated. 
      </p>

      <p>
	Another way is to represent the list of neighbours using
	two arrays as follows.  Here, each neighbour points (via
	"Next") to the next neighbour, until the last neighbour
	which has Next = -1.
      </p>

      <pre>
           Offset                 Node  Next
       1      1    -------------->  2    2
       2      3    ------------     3   -1
       3      5    ----------  |->  1    4
       4      9    --------  |      3   -1
       5     10    ------  | |--->  1    6
       6     12    ----  | |        2    7
       7     14    --  | | |        4    8
                     | | | |        6    9
                     | | |  ----->  3   -1
                     | |  ------->  6   11
                     | |            7   -1
                     |  --------->  5   13
                     |              7   -1
                      ----------->  5   15
                                    6   -1
      </pre>

      <p>
	Suppose we now add a new neighbour to 2, say 7.  We
	append (7,-1) to the arrays (Node,Next) and modify the -1
	entry in Next[4] to point to the new position, 17.
      </p>

      <pre>
           Offset                 Node  Next
       1      1    -------------->  2    2
       2      3    ------------     3   -1
       3      5    ----------  |->  1    4
       4      9    --------  |      3   17 <--- Points to new nbr of 2
       5     10    ------  | |--->  1    6
       6     12    ----  | |        2    7
       7     14    --  | | |        4    8
                     | | | |        6    9
                     | | |  ----->  3   -1
                     | |  ------->  6   11
                     | |            7   -1
                     |  --------->  5   13
                     |              7   -1
                      ----------->  5   15
                                    6   -1
                                    7   -1
      </pre>

      <p>
	You can also use more complicated data structures to
	represent adjacency lists, if you are comfortable with
	them:
      </p>

      <ul>
	<li> An array of pointers, each pointing into a linked
	  list.  Entry i in the array points to the list of
	  neighbours of i.</li>

	<li> C++ vectors.</li>
      </ul>

      <p>Video lecture on <em>Representation of graphs</em>,
	<a href="https://onlinecourses.nptel.ac.in/explorer">
	  NPTEL online course</a> on
        <a href="https://onlinecourses.nptel.ac.in/noc15_cs02/preview">
  	  Design and Analysis of Algorithms</a>
        (<a href="http://www.cmi.ac.in/~madhavan/nptel-algorithms-2015/week3/pdf/nptel-week3-module2-graphrepresentation.pdf" target="_blank">Lecture slides</a>)</p>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/Y-6IGzmlG4Y" frameborder="0" allowfullscreen=""></iframe>

        <br><br>
	

    </div>
  </div> <!-- Right column end -->

   <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Basic topics</h3>
      <ul class="menu">
	<li><a href="introduction.html">Introduction</a></li>
	<li><a href="efficiency.html">Efficiency</a></li>
	<li><a href="binarysearch.html">Searching</a></li>
	<li><a href="sorting.html">Sorting</a></li>
	<li><a href="graphs.html">Basic Graph Algorithms</a></li>
	<li><a href="dp.html">Dynamic Programming</a></li>
	<li><a href="greedy.html">Greedy Algorithms</a></li>
	<li><a href="shortest-paths.html">Computing Shortest Paths</a></li>
	<li><a href="heaps.html">Heaps</a></li>
	<li><a href="permutations.html">Permutations</a></li>
	<li><a href="dags.html">Directed Acyclic Graphs</a></li>
	<li><a href="prefix-sums.html">Computing Prefix Sums</a></li>
	<li><a href="sliding-window.html">Sliding Window Algorithms</a></li>
      </ul>

      <h3>Advanced topics</h3>
      <ul class="menu">
	<li><a href="advanced-graph-algorithms.html">Advanced Graph Algorithms</a></li>
	<li><a href="dp-trees.html">Dynamic Programming on Trees</a></li>
	<li><a href="range-queries.html">Range Queries</a></li>
	<li><a href="network-flows.html">Network Flows</a></li>
	<li><a href="games.html">Games and Strategies</a></li>
	<li><a href="geometry.html">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

 <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="">Topics</a>|</li>
                  <li><a href="..\problems\index.html">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
