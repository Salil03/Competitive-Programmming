<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a href="..\problems\index.html">Problems</a></li>
	    <li><a class="active" id="first" href="index-1.html">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2><a href="sorting.html">Sorting</a></h2>

      <h3><span>Quicksort</span></h3>

      <p>
	Quicksort is a another divide-and-conquer algorithm.  Its
	worst case complexity is not good, but it avoids
	mergesort's problem of needing an extra array to store
	the final sorted output.  Also, though the worst case
	complexity is bad, it works well on the average.

      <p>
	Here is how quicksort works.
      </p>
      
      <ol>

	<li>
	  Call A[0], the first element of the given array A the
	  PIVOT element or the SPLITTER.
	</li>

	<li>
	  We regroup A[1] to A[N-1] into two parts.  The first
	  part consists of elements less than the splitter A[0]
	  while the second part consists of elements greater than
	  A[0].  (If there are duplicate entries in the array, we
	  may have elements equal to A[0].  We can place these,
	  for instance, in the first partition.)
	</li>

	<li>
	  After rearranging the elements, we move the splitter
          element in between the two partitions and recursively
          sort the lower and upper parts of the array (leaving
          out the splitter).
	</li>

      </ol>
      
      <p>
	Before we describe how to do this rearrangement
	efficiently, we observe that this procedure will not
	necessarily give us subproblems of size N/2 as we had
	assumed in the earlier analysis.  The sizes of the two
	partitions depend on the value of A[0].  In the worst
	case, A[0] may be the smallest or largest value in A,
	resulting in one of the two partitions being empty.
	However, such extreme cases are rare and it can be proved
	mathematically that on an average Quicksort runs in time
	proportional to N*log&nbsp;N.  More importantly,
	Quicksort works very well in practice and it is usually
	the algorithm used to implement built-in sorting
	routines.
      </p>
      
      <p>
	To achieve the rearrangement, we scan the array from A[1]
	to A[n-1].  At an intermediate point in the scan, we are
	examining A[i].  At this point, we should have
	partitioned A[1] to A[i-1] into two groups, those smaller
	than A[0] and those bigger than A[0].  We thus have two
	indices into the array, b and i.  The index b specifies
	the boundary between the lower and upper partitions
	within A[1] to A[i-1].  We can fix b to be either the
	last position in the lower partition or the first
	position in the upper partition.  Suppose we choose the
	latter.
      </p>

      <p>
	We then get an invariant as follows. After each iteration
	of the loop where we scan through A,
      </p>

      <ul>
	<li>
	  i marks the first element of the part of the array
	  that is yet to be scanned
	</li>

	<li>
	  b marks the beginning of the upper partition within
	  A[1] to A[i-1]
	</li>
	
      </ul>

      <p>
	Thus, at an intermediate point, the array looks like the
	following.
      </p>
      

      <pre>
	        0 1          b         i         n-1
	        -------------------------------------
	       | | <= A[0]  | > A[0]  | Yet to scan  |
	        -------------------------------------
      </pre>

      <p>
	When we scan A[i], we check whether it is smaller than
	A[0].  If so, it should move to the smaller partition, so
	we swap it with the entry at A[b] and increment both b
	and i.  If A[i] is not smaller than A[0], it is already
	in the correct partition so we leave b unchanged and just
	increment i.
      </p>

      <pre>
         i = 1; b = 1;
         while (i < n){
           if (A[i] <= A[0]){
             swap(A[b],A[i]);
             b++;
           }
           i++;
         }
      </pre>

      <p>
	Of course, at the end we should also insert the splitter
	between the two partitions, so we can add, after the loop;
      </p>
      

      <pre>
        swap(A[0],A[b-1]);  /* Insert splitter before upper partition */
      </pre>

      <p>
	We then recursively sort A[0]..A[b-2] and A[b]..A[n-1].
	As we mentioned earlier, in the worst case, one of these
	two intervals will have length n-1 while the other is
	empty, but on an average the array will split into
	approximately equal parts.
      </p>
      
      <p>
	In general, quicksort will be a recursive function which
	will be passed the array and the left and right endpoints
	of the interval to be sorted.  We use the convention that
	the left endpoint is the first index in the interval
	while the right endpoint is one position beyond the last
	index in the interval.  Thus, the initial call would be
	to quicksort(A,0,n), where n is the size of A.  In
	general, the function is
      </p>

      <pre>
	int quicksort(int *A, int l, int r){

	  if (r - l <= 1)){ return 0; }  /* Trivial array, do nothing */

	  /* Rearrange with respect to splitter, a[l] */
	  b = l+1;
	  for (i = l+1; i < r; i++){
	    if (A[i] <= A[l]){
	      swap(A[b],A[i]);
	      b++;
	    }
	  }
	  swap(A[l],A[b-1]);  /* Insert splitter before upper partition */

	  /* Recursive calls */
	  quicksort(a,l,b-1);
	  quicksort(a,b,r);
	}
      </pre>

      <br>

      <h3><span>Quicksort in real life</span></h3>

      <p>
	If we choose the pivot element to be first (or last)
	element in the array, the worst case input for quicksort
	is when the array is already sorted.  We argued that this
	will rarely happen and that in the average case,
	quicksort works well in time N log N.
      </p>

      <p>
	In certain practical situations, the worst case can and
	does happen with unexpected frequency.  Consider an
	application like a spreadsheet where you can display and
	manipulate a table of data.  One option typically
	provided to the user is to select a column and sort the
	entire table based on the values in that column.  It is
	often the case that the user first sorts the column in
	the wrong order (ascending or descending), realizes the
	mistake and then repeats the sort in the opposite
	direction.  If the column sorting algorithm is quicksort,
	the second sort provides a worst case input!
      </p>

      <p>
	One solution is to randomize the choice of pivot.  You
	can generate random numbers in C/C++ as follows:
      </p>

      <pre>
  	#include &lt;stdlib.h&gt;

  	int seed;
  	...
  	srandom(seed);  /* Initialize the random number generator*/

  	...

  	j = random();   /* Returns a integer random number */
      </pre>

      <p>
	If we initialize srandom() with the same value, the
	subsequent sequence of random numbers will be the same.
	In IOI, if you use randomization in your program, it is
	required that your random number generator always yields
	the same sequence for any input.  Thus, you should use a
	fixed value as a seed, not something "random" like the
	current system time etc.
      </p>

      <p>
	To generate a random number in the range 1..k, we can
	write
      </p>

      <pre>
        j = random()%k;
      </pre>

      <p>
	For quicksort, we need to choose a random pivot element
	between positions l and r-1.  We can do this by writing:
      </p>

      <pre>
        pivot = l+ random()%(r-l);
        swap(A[l],A[pivot]);
      </pre>

      <p>
	The second statement moves the pivot to the beginning of
	the array.  We can then use the earlier implementation of
	quicksort that assumes that the pivot is at the beginning
	of the array.
      </p>

      <div id="video-material">
        <h3><span>Video material</span></h3>
      </div>

      <p>Video lectures on <em>Quicksort</em>,
	<a href="https://onlinecourses.nptel.ac.in/explorer">
	  NPTEL online course</a> on
        <a href="https://onlinecourses.nptel.ac.in/noc15_cs02/preview">
  	  Design and Analysis of Algorithms</a>

      <ul>
        <li> Quicksort
        (<a href="http://www.cmi.ac.in/~madhavan/nptel-algorithms-2015/week2/pdf/nptel-week2-module7-quicksort.pdf" target="_blank">Lecture slides</a>)<p>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/RajaRfMJF4I" frameborder="0" allowfullscreen=""></iframe>

        <li> Analysis of Quicksort
        (<a href="http://www.cmi.ac.in/~madhavan/nptel-algorithms-2015/week2/pdf/nptel-week2-module8-quicksort-analysis.pdf" target="_blank">Lecture slides</a>)<p>

        <iframe width="560" height="315" src="https://www.youtube.com/embed/N8lzcGiQo9A" frameborder="0" allowfullscreen=""></iframe>

       </li></ul>

       <br><br>

    </div>
  </div> <!-- Right column end -->


    <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Basic topics</h3>
      <ul class="menu">
	<li><a href="introduction.html">Introduction</a></li>
	<li><a href="efficiency.html">Efficiency</a></li>
	<li><a href="binarysearch.html">Searching</a></li>
	<li><a href="sorting.html">Sorting</a></li>
	<li><a href="graphs.html">Basic Graph Algorithms</a></li>
	<li><a href="dp.html">Dynamic Programming</a></li>
	<li><a href="greedy.html">Greedy Algorithms</a></li>
	<li><a href="shortest-paths.html">Computing Shortest Paths</a></li>
	<li><a href="heaps.html">Heaps</a></li>
	<li><a href="permutations.html">Permutations</a></li>
	<li><a href="dags.html">Directed Acyclic Graphs</a></li>
	<li><a href="prefix-sums.html">Computing Prefix Sums</a></li>
	<li><a href="sliding-window.html">Sliding Window Algorithms</a></li>
      </ul>

      <h3>Advanced topics</h3>
      <ul class="menu">
	<li><a href="advanced-graph-algorithms.html">Advanced Graph Algorithms</a></li>
	<li><a href="dp-trees.html">Dynamic Programming on Trees</a></li>
	<li><a href="range-queries.html">Range Queries</a></li>
	<li><a href="network-flows.html">Network Flows</a></li>
	<li><a href="games.html">Games and Strategies</a></li>
	<li><a href="geometry.html">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

  <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="">Topics</a>|</li>
                  <li><a href="..\problems\index.html">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
