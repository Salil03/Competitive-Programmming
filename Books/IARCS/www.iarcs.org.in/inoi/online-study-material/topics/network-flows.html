<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>

<meta name="Description" content="">
<meta name="author" content="">
<meta name="keywords" content="">

<meta name="robots" content="all,follow">

<!-- CSS --> 
<link rel="stylesheet" href="styles\default.css" type="text/css" media="screen, projection, tv">
<link rel="stylesheet" href="styles\print.css" type="text/css" media="print">

<!-- Favicon -->
<link rel="shortcut icon" href="img\iarcslogo.png" type="image/x-icon">
</head>

<body id="top">
<div id="wrapper">

	<div class="header">
	<h1><span><a href="http://www.iarcs.org.in/inoi"><span id="color">Indian Computing Olympiad</span></a></span></h1>
	<p id="about">Training Material</p>

	<a href="#skip-menu" class="hidden">Skip menu</a> <!-- Skip menu -->
	<div id="menu-box">
	  <ul id="web">
	    <li><a href="..\contact\index.html">Contact</a></li>
	    <li><a href="..\iindex\index.html">Index</a></li>
	    <li><a href="..\problems\index.html">Problems</a></li>
	    <li><a class="active" id="first" href="index-1.html">Topics</a></li>
	    <li><a href="..\index-1.html">Home</a></li>
	  </ul>
	</div>

	</div> <!-- Header end -->

<hr class="noscreen">

<div id="skip-menu"></div>

<div class="page">
  <div class="col-r">
    <div class="col-r-in">

      <h2><a href="">Network flows</a></h2>

      <p><b>Note: Network flows are not part of the syllabus for IOI/IOITC.</b></p>

      <p>
	Given a network of pipes with a given capacity and two
	nodes, source and sink, what is the maximum flow that can
	be passed from source to sink?
      </p>

      <pre>
                 7
          -->u ------------->v
         /    \            /   \
        / 7    \       10 /     \5
       /        \        /       \
  source         \----  /         -->sink
       \        10     X         /
        \ 5           / \       /7
         \    <------/   \-->  /
          -->w-------------->z
                   7
      </pre>

      <ol> 

	<li>For each edge e, flow(e) &le; capacity(e)</li>

	<li> At each node, flow into the node is equal to the flow out of
	  the node (conservation of flow).</li>

      </ol>

      <p>
	In this case, the maximum flow is 12:
      </p>

      <ul>
	<li>send 5 along source&rarr;u&rarr;v&rarr;sink</li>
	<li>send 5 along source&rarr;w&rarr;z&rarr;sink.</li>
	<li>send 2 along source&rarr;u&rarr;v&rarr;w&rarr;z&rarr;sink</li>
      </ul>

      <p>
	Observe that the edges (u,v) and (z,sink) together
	disconnect the source from the sink.  This is called a
	"cut set".  Clearly, any flow that goes from source to
	sink must go through this cut set and cannot exceed the
	capacity of the cut, namely 14.  There may be many cut
	sets --- for instance, (source,u), (source,w) is also a
	cut set, with capacity 12.
      </p>

      <p>
	It is clear that the maximum flow in the graph cannot
	exceed the capacity of the minimum size cut in the graph.
      </p>

       <p>
	 Claim: The maximum flow from source to sink is equal to
	 the capacity of the minimum size cut in the graph.
       </p>

       <p>
	 How do we compute the maximum flow?
       </p>

       <p>
	 Suppose we start with a flow
       </p>

       <pre>
          5     5     5           <--flow
  source---->o---->o---->sink
          5    10     5           <--capacity
       </pre>
									       <p>
										 Now, we select another path (ignoring directions) to augment the
										 flow.
									       </p>

									       <p>
										 An augmenting path is a path from source to sink where
									       </p>

									       <ul>
										 <li>forward edges, flow &lt; capacity</li>
										 <li>backward edges, flow &gt; 0</li>
									       </ul>

									       <p>
										 e.g. we may have a path that looks like
									       </p>

									       <pre>
          4     6      3       2         <--flow
  source---->o----->o<-----o<------sink
          5     5      4       3         <--capacity
</pre>

<p>
For each edge on this path, we compute leeway(e), defined as:
</p>

<ul>
  <li>if e is a forward edge  : capacity(e) - flow(e)</li>
  <li>if e is a backward edge : flow(e)</li>
</ul>

<pre>
          4     6      3       2         <--flow
  source---->o----->o<-----o<------sink
          5     7      4       3         <--capacity
          1     1      3       1         <--leeway
</pre>

<p>
Augment flow upto min leeway along the path.  Here min leeway is 1, so you
can augment flow.  On reverse edges, cancel out the existing flow, so
reduce by the augmented amount.
</p>

<p>
After augmentation.
</p>

<pre>

          5     7      2       3         <--new flow
  source---->o----->o<-----o<------sink
          5     7      4       3         <--capacity
</pre>

<p>
Repeat the augmentation step till you cannot find an augmenting path.
(This algorithm is called the Ford-Fulkerson algorithm.)
</p>

<p>
Example:
</p>

<pre>
                    7
          -->u ------------->v
         /    \            /   \
        / 7    \       10 /     \5
       /        \        /       \
  source         \----  /         -->sink
       \        10     X         /
        \ 5           / \       /7
         \    <------/   \-->  /
          -->w-------------->z
                   7
</pre>

<p>
Start with a flow
</p>

<pre>

            5     5     5         <--flow
   source ---->u---->z---->sink
            7    10     7         <--capacity
</pre>

<p>
Find an augmenting path, for example:
</p>

<pre>
            5     0     0         <--flow
   source ---->u---->v---->sink
            7     7     5         <--capacity
            2     7     5         <--leeway

</pre>

<p> 
Add flow on this path
</p>

<pre>
            7     2     2         <--augmented flow
   source ---->u---->v---->sink
            7     7     5         <--capacity
</pre>

<p>
 Now, another augmenting path (with backward edges):
</p>

<pre>
            0     0     5     2     2       <--flow
   source ---->w---->z<----u---->v---->sink
            5     7     10    7     5       <--capacity
            5     7     5     5     3       <--leeway
</pre>

<p>
Augmented flow
</p>

<pre>
            3     3     2     5     5       <--flow
   source ---->w---->z<----u---->v---->sink
            5     7     10    7     5       <--capacity
</pre>

<p>
Finally, we have an augmenting path
</p>

<pre>
            3     3     5         <--flow
   source ---->w---->z---->sink
            5     7     7         <--capacity
            2     4     2         <--leeway
</pre>

<p>
Augmented flow
</p>

<pre>
            5     5     7         <--augmented flow
   source ---->w---->z---->sink
            5     7     7         <--capacity
</pre>

<p>
Add  s&rarr;w&rarr;z&rarr;u&rarr;v&rarr;t
</p>

<p>
How do we find augmenting paths?
</p>

<ul>
  <li>
  Use BFS.  At each node:
  <ul>
  <li>take a forward edge if flow &lt; capacity</li>
  <li>take a backward edge if flow &gt; 0</li>
  </ul>
  </li>

  <li>If you reach the sink, you have found an augmenting
  path.</li>
</ul>

<p>
In the worst case, you have to do one iteration for each unit of flow.  Let
F be the optimum flow.  Then, we have F iterations, each of which requires
finding an s-t path (BFS/DFS), so it takes mF time.  (This assumes that
flows are all integers).
</p>

<p>
Here is a worst case scenario:
</p>

<pre>
                                 10000      10000
                                     --->A---------->t
                                    /     \       -->
                                   /       \1    /
                                  s         --> / 9000
                                   ----------->B
                                           9000
</pre>

<p>
Here, if we always choose a path that includes the edge AB (or BA), each
step increases the max flow by exactly 1 unit, so it takes 19000 iterations
to terminate.  (Of course, we could have been lucky and chosen directly the
upper and lower paths to augment.)
</p>

<p>
<b>Claim:</b> If we always augment the flow by finding the shortest s-t path in
  terms of number of edges, the algorithm terminates in time O(mn).  (We
  will not prove this).  Notice that if we search for augmenting paths via
  BFS, we are guaranteed to find the shortest augmenting path at each
  stage.
</p>

<p>
Observe: If the capacities are integers, each time we augment the flow, we
  augment it by an integer.  So, the max flow will always be integral.
</p>

      <div id="video-material">
        <h3><span>Video material</span></h3>
      </div>

      <p>Video lecture on <em>Network flows</em>,
	<a href="https://onlinecourses.nptel.ac.in/explorer">
	  NPTEL online course</a> on
        <a href="https://onlinecourses.nptel.ac.in/noc15_cs02/preview">
  	  Design and Analysis of Algorithms</a>
        (<a href="http://www.cmi.ac.in/~madhavan/nptel-algorithms-2015/week8/pdf/nptel-week8-module4-network-flows.pdf" target="_blank">Lecture slides</a>)</p>

      <iframe width="560" height="315" src="https://www.youtube.com/embed/yxHDqjT6OQw" frameborder="0" allowfullscreen=""></iframe>

      <br><br>

      <h3><span>Problems based on network flows</span></h3>
      <ul>
	<li> <a href="..\problems\going-to-school.html">Going to school</a></li>
	<li> <a href="..\problems\evil-intentions.html">Evil intentions (IOITC 2005)</a></li>
      </ul>

    </div>
  </div> <!-- Right column end -->


    <hr class="noscreen">

  <div class="col-l">
    <div class="col-l-in">
      <h3>Basic topics</h3>
      <ul class="menu">
	<li><a href="introduction.html">Introduction</a></li>
	<li><a href="efficiency.html">Efficiency</a></li>
	<li><a href="binarysearch.html">Searching</a></li>
	<li><a href="sorting.html">Sorting</a></li>
	<li><a href="graphs.html">Basic Graph Algorithms</a></li>
	<li><a href="dp.html">Dynamic Programming</a></li>
	<li><a href="greedy.html">Greedy Algorithms</a></li>
	<li><a href="shortest-paths.html">Computing Shortest Paths</a></li>
	<li><a href="heaps.html">Heaps</a></li>
	<li><a href="permutations.html">Permutations</a></li>
	<li><a href="dags.html">Directed Acyclic Graphs</a></li>
	<li><a href="prefix-sums.html">Computing Prefix Sums</a></li>
	<li><a href="sliding-window.html">Sliding Window Algorithms</a></li>
      </ul>

      <h3>Advanced topics</h3>
      <ul class="menu">
	<li><a href="advanced-graph-algorithms.html">Advanced Graph Algorithms</a></li>
	<li><a href="dp-trees.html">Dynamic Programming on Trees</a></li>
	<li><a href="range-queries.html">Range Queries</a></li>
	<li><a href="network-flows.html">Network Flows</a></li>
	<li><a href="games.html">Games and Strategies</a></li>
	<li><a href="geometry.html">Geometry</a></li>
      </ul>


      <br>

    </div>
  </div> <!-- Left column end -->

  <div class="cleaner">&nbsp;</div>

        </div> <!-- Page end -->

        <div id="footer">
                <ul>
                  <li><a href="..\index-1.html">Home</a>|</li>
                  <li><a href="">Topics</a>|</li>
                  <li><a href="..\problems\index.html">Problems</a>|</li>
                  <li><a href="..\iindex\index.html">Index</a>|</li>
                  <li><a href="..\contact\index.html">Contact</a></li>
                </ul>

        <p><a href="#" onclick="print();" title="Javascript needed for a Print">Print</a> | <a href="#top">Top</a>&uarr;</p>
        </div> <!-- Footer end -->

</div> <!-- Wrapper end -->

<p id="backlinks">&copy;IARCS 2012&ndash;2016</p>
<p id="backlinks"><a href="http://www.pestujemeweb.cz/">Pěstujeme web</a> | visit: <a href="http://www.junglegym.cz/" title="Skluzavky Jungle Gym">Skluzavky</a></p>

</body>
</html>
